/*!
 * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.
 *
 * Visit these websites for more information.
 * - http://www.intranda.com
 * - http://digiverso.com
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
var _MIN_DESKEW_ANGLE = -44.9  //must be <45
var _MAX_DESKEW_ANGLE = 45  //must be <=45

var DEFAULT_CURSOR = "default";

var ImageView = ( function() {
    'use strict';
    var _debug = false;
    var _defaults = {
            global: {
                divId: "map",
                zoomSlider: ".zoom-slider",
                zoomSliderHandle: '.zoom-slider-handle',
                overlayGroups: [],
                zoomSpeed: 1.25,
                maxZoomLevel: 2,
                minZoomLevel: 1,
                allowPanning: true,
                enableMouseNavigation: true,	//false means that no mouse events are handled
                imageControlsActive: true,
                visibilityRatio: 0.1, 
                loadImageTimeout: 10 * 60 * 1000,
                maxParallelImageLoads: 2,
                adaptContainerHeight: false,
                adaptContainerWidth: false,
                fitToContainer: true,
                bottomMargin: () => 0,
                topMargin: () => 0,
                rightMargin: () => 0,
                rememberZoom: false,
                rememberRotation: false,
                panHomeOnZoomOut: true,
                showControls: false,
                useTiles: true
            },
            image: {
                initialRotation: 0,
                mimeType: "image/jpeg"
                }
        };
    
     var imageView =  {};
     
     /**
      * Basic constructor. Merges the given config into a copy of the default config
      */
     imageView.Image = function(config)  {     
         this.config = jQuery.extend(true, {}, _defaults);
         jQuery.extend(true, this.config, config);
         this.container = $( "#" + this.config.global.divId );
         if(_debug) {             
             console.log("initializing image view with config ", this.config);
         }

//         this.originalImageSize = {x:this.config.imageWidth, y:this.config.imageHeight};
//         this.imageViewWidth = parseFloat($('#'+this.config.div).css("width"));
//         this.imageViewHeight = parseFloat($('#'+this.config.div).css("height"));
     }
     
     /**
      * Loads the image from the config given in the constructor
      * @return a promise to be resolved once the viewer has been opened
      */
     imageView.Image.prototype.load = function() {
             if ( _debug ) {
                 console.log( '##############################' );
                 console.log( 'osViewer.init' );
                 console.log( '##############################' );
             }
             
             this.config.image.mimeType = this.config.image.mimeType.replace("jpeg","jpg");
             //create image source array
             var sources = this.config.image.tileSource;
             var promises = _loadSources(sources, this.config);
             return Q.all(promises).then(function(tileSources) {
                 tileSources = _scaleTileSources(tileSources, this);
                 var pr = this.loadImage(tileSources);
                 return pr;
             }.bind(this));
         };
         
         imageView.Image.prototype.setTileSource = function(sources) {
             var promises = _loadSources(sources, this.config);
                 return Q.all(promises).then(function(tileSources) {
                 tileSources = _scaleTileSources(tileSources, this);
                 var pr = this.viewer.open(tileSources);
                 return pr;
             }.bind(this));
         };

         
         imageView.Image.prototype.loadImage = function(tileSources) {
             if ( _debug ) {
                 console.log( 'Loading image with tilesource: ', tileSources );
             }
 
             var $div = $("#" + this.config.global.divId);
       
             var maxZoomLevel = this.config.global.maxZoomLevel
             if(this.config.image.originalImageWidth && $div.width() > 0) {
                 maxZoomLevel = this.config.global.maxZoomLevel*this.config.image.originalImageWidth/$div.width();
             }

             this.loadFooter();            
               
             var osConfig = {
                     tileSources: tileSources,
                     id: this.config.global.divId,
                     prefixUrl: this.config.resourcePath + "/javascript/openseadragon/images/",
                     immediateRender: false,
                     visibilityRatio: this.config.global.visibilityRatio,
                     sequenceMode: false,
                     degrees: this.config.image.initialRotation ? this.config.image.initialRotation : 0,
                     zoomPerClick: 1.0,
                     showRotationControl: true,
                     showNavigationControl: this.config.global.showControls,
                     minZoomLevel: this.config.global.minZoomLevel,//Math.min(this.config.global.minZoomLevel, this.config.global.minZoomLevel*this.config.image.originalImageWidth/$div.width()),
                     maxZoomLevel: maxZoomLevel,
                     zoomPerScroll: this.config.global.zoomSpeed,
                     panHorizontal: this.config.global.allowPanning,
                     panVertical: this.config.global.allowPanning,
                     mouseNavEnabled: this.config.global.enableMouseNavigation,
                     homeButton: this.config.global.zoomHome,
                     rotateLeftButton: this.config.global.rotateLeft,
                     rotateRightButton: this.config.global.rotateRight,
                     timeout: this.config.global.loadImageTimeout,
                     blendTime: .5,
                     alwaysBlend: false,
                     imageLoaderLimit: this.config.global.maxParallelImageLoads,
                     loadTilesWithAjax: true,
                     ajaxHeaders: {
                         "token" : this.config.global.webApiToken
                     },
                     viewportMargins: {
                         top: this.config.global.topMargin(),
                         left: 0,
                         right: this.config.global.rightMargin(),
                         bottom: this.config.global.bottomMargin()
                     } 
                 }
             if(_debug) {
                 console.log("osconfig ", osConfig);
                 console.log("margins = ", osConfig.viewportMargins);
             }
             
             this.viewer = new OpenSeadragon( osConfig );
             var result = Q.defer();
             this.observables = _createObservables(window, this);  
             if(this.config.global.rotationSlider || this.config.global.rotationInput) {                 
                 _setupRotation(this);
             }
             
             var image = this;
             this.observables.viewerOpen.subscribe(function(openevent, loadevent) {
            	 
            	 for ( var j=0; j< image.viewer.tileSources.length; j++) {
                     var tileSource = tileSources[j].tileSource;
                     //make sure again we have some values for original image size in config
                     if(!image.config.image.originalImageWidth) {
                         image.config.image.originalImageWidth = tileSource.width;
                     }
                     if(!image.config.image.originalImageHeight) {
                         image.config.image.originalImageHeight = tileSource.height;
                     }
                 }
                 result.resolve(image);                
             }, function(error) {            
                 result.reject(error);                
             });                
                 
                 
             // Calculate sizes if redraw is required
             
             this.observables.viewerOpen.
             merge(this.observables.redrawRequired)
             .subscribe(function(event) {            
                 if(_debug) {
                     console.log("viewer " + event.osState + "ed with target location ", event.targetLocation);                    
                 }
                 image.redraw();
             });
             
                 
             if ( imageView.Controls ) {
                 this.controls = new imageView.Controls(this.config, this);
//                 osViewer.controls.init( _defaults );
             }
             
             if ( imageView.ZoomSlider ) {
                 this.zoomSlider = new imageView.ZoomSlider(this.config, this);
                 this.onFirstTileLoaded()
                 .then(function() {
                     if(image.zoomSlider) {
                         image.zoomSlider.init();
                         
                     }
                 })
//                 osViewer.zoomSlider.init( _defaults );                
             }
             
             if ( imageView.Overlays ) {
                 this.overlays = new imageView.Overlays(this.config, this);
//                 osViewer.overlays.init( _defaults );                
             }                
             
             if ( imageView.DrawRect ) {
                 this.drawRect = new imageView.DrawRect(this.config, this);
//                 osViewer.drawRect.init();                
             }   
             
             if ( imageView.TransformRect ) {        
                 this.transformRect = new imageView.TransformRect(this.config, this);
//                 osViewer.transformRect.init();                
             }                
             
             this.observables.redrawRequired.connect();                
             return result.promise;
         }

     /**
      * @return the list of observables associated with this viewer
      */
     imageView.Image.prototype.getObservables = function() {
         return this.observables;
     }
     /**
      * @return true if a footerImage exists
      */
     imageView.Image.prototype.hasFooter = function() {
         return this.footerImage != null;
     }
     /**
      * @return the config
      */
     imageView.Image.prototype.getConfig = function() {
         return this.config;
     }
     /**
      * Loads the image footer from the configured footer url
      */
     imageView.Image.prototype.loadFooter = function() {
         if ( this.config.image.baseFooterUrl && this.config.global.bottomMargin() > 0 ) {                
             this.footerImage = new Image();
             this.footerImage.src = this.config.image.baseFooterUrl.replace( "{width}", Math.round( this.container.width() ) ).replace( "{height}", Math.round( this.config.global.bottomMargin() ) );                
             this.footerImage.src = this.config.image.baseFooterUrl.replace( "/full/max/", "/full/!" + Math.round( this.container.width() ) + "," +  Math.round( this.config.global.bottomMargin() ) + "/");                
             var image = this;
             this.footerImage.onload = function() {
                 if ( _debug ) {
                     console.log( "loading footer image ", image.footerImage );
                     console.log( "Calculating image Footer size" );
                 }
                 
                 _drawFooter(image);
             };
         }
     }

     
     /**
      * gets the overlay group with the given name from the config
      */
     imageView.Image.prototype.getOverlayGroup = function( name ) {
         var allGroups = this.config.global.overlayGroups;
         for ( var int = 0; int < allGroups.length; int++ ) {
             var group = allGroups[ int ];
             if ( group.name === name ) {
                 return group;
             }
         }
     }
     /**
      * gets the highlighting coordinates from the config
      */
     imageView.Image.prototype.getHighlightCoordinates = function( name ) {
         var coodinatesArray = this.config.image.highlightCoords;
         if ( coodinatesArray ) {
             for ( var int = 0; int < coodinatesArray.length; int++ ) {
                 var coords = coodinatesArray[ int ];
                 if ( coords.name === name ) {
                     return coords;
                 }
             }
         }
     }
     /**
      * return the sizes associated with this view
      */
     imageView.Image.prototype.getSizes = function() {
         return this.sizes;
     }
     /**
      * get the underlying tilesource of the viewer
      */
     imageView.Image.prototype.getImageInfo = function() {
         if(this.viewer) {
             return this.viewer.tileSources;
         }
         return null;
     }
     /**
      * close the OpenSeadragon viewer
      */
     imageView.Image.prototype.close = function() {
         if ( _debug ) {
             console.log( "Closing openSeadragon viewer" );
         }
         
         
         
         if ( this.viewer ) {
             this.viewer.destroy();
         }
     }
     /**
      * Calculates the sizes associates with this viewer
      */
     imageView.Image.prototype.redraw = function() {
//         if(this.controls) {                     
//             this.controls.setPanning( true );
//         }
         this.sizes = _calculateSizes(this);
     }
     /**
      * @return a promise resolved once the first tile is loaded
      */
     imageView.Image.prototype.onFirstTileLoaded = function() {
         var defer = Q.defer();
         
         if(this.observables) {
             this.observables.firstTileLoaded.subscribe(function(event) {
                 defer.resolve(event);
             }, function(error) {
                 defer.reject(error)
             });
         } else {
             defer.reject("No observables defined");
         }
         return defer.promise;
     }

     
     imageView.Image.prototype.getOriginalImageSize = function() {
         return new OpenSeadragon.Point(this.config.image.originalImageWidth, this.config.image.originalImageHeight);
     }
     
     imageView.Image.prototype.getRotation = function() {
    	 return this.viewer.viewport.getRotation();
     }
     
     /**
      * Scale the given point or rectangle in the original image to OpenSeadragon coordinates
      * This is the inverse of scaleToImage
      */
     imageView.Image.prototype.scaleToOpenSeadragon = function(coords) {
    	 return imageView.CoordinateConversion.scaleToOpenSeadragon(coords, this.viewer, this.getOriginalImageSize());
     }
     
     /**
      * Scale the given point or rectangle in OpenSeadragon coordinates to original image coordinates
      * This is the inverse of scaleToOpenseadragon
      */
     imageView.Image.prototype.scaleToImage = function(coords) {
    	 return imageView.CoordinateConversion.scaleToImage(coords, this.viewer, this.getOriginalImageSize());
     }
     

     function _createObservables(window, image) {
         var observables = {};
         observables.viewerOpen = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'open', function( event ) {
                 event.osState = "open";
                 
                 if(Number.isNaN(event.eventSource.viewport.getHomeBounds().x)) {
                     return observer.onError("Unknow error loading image from ", _defaults.image.tileSource);
                 } else {                    
                     var location = {};

                     location.panTo = false;

                         location.zoom = image.viewer.viewport.getHomeZoom();
                         if(image.config.image.location) {
                            location = image.config.image.location;
                            image.zoomedOut = false;
                         }
                     if(_debug) {        
                         console.log("Set location to ", location);
                     }    
                     event.targetLocation = location;
                     
                     return observer.onNext(event);
                 }
             } );
             image.viewer.addHandler( 'open-failed', function( event ) {
                 event.osState = "open-failed";
                 console.error("Failed to open openseadragon ");
                 
                 return observer.onError(event);
             } );
         });
         
         observables.firstTileLoaded = Rx.Observable.create(function(observer) {
             image.viewer.addOnceHandler( 'tile-loaded', function( event ) {
                 event.osState = "tile-loaded";
                 return observer.onNext(event);
             } );
             image.viewer.addOnceHandler( 'tile-load-failed', function( event ) {
                 event.osState = "tile-load-failed";
                 console.error("Failed to load tile");
                 return observer.onError(event);
             } );
         });
         
         observables.viewerZoom = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'zoom', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.animationComplete = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'animation-finish', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.viewportUpdate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'update-viewport', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.animation = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'animation', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.viewerRotate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'rotate', function( event ) {
                 event.osState = "rotate";
                 return observer.onNext(event);
             } );
         });
         observables.canvasResize = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'resize', function( event ) {
                 event.osState = "resize";
                 
                 return observer.onNext(event);
             } );
         });
         observables.windowResize = Rx.Observable.fromEvent(window, "resize").map(function(event) {
             event.osState = "window resize";
             
             return event;
         });
         observables.overlayRemove = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'remove-overlay', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.overlayUpdate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'update-overlay', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.levelUpdate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'update-level', function( event ) {
                 return observer.onNext(event);
             } );
         });
         observables.close = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'close', function( event ) {
                 return observer.onNext(event);
             } );
         });
         
         observables.redrawRequired = 
                  observables.viewerRotate
                 .merge(observables.canvasResize.skipUntil(observables.firstTileLoaded))
                 .debounce(10)
         .map(function(event) {
             var location = {};

             if(image.controls) {
                 location = image.controls.getLocation();
             }
             location.panTo = false;
             
             if(event.osState === "open") {
                 location.zoom = image.viewer.viewport.getHomeZoom();
                 if(image.config.image.location) {
                    location = image.config.image.location;
                 }
             }
             if(_debug) {                 
                 console.log("set location to ", location);
             }
             event.targetLocation = location;
             
             return event;
         })
         .publish();
         
         return observables;
     }
     
     function _drawFooter(image) {
         if ( image && image.viewer ) {
             _overlayFooter({userData:image});
             image.viewer.removeHandler( 'update-viewport', _overlayFooter);
             image.viewer.addHandler( 'update-viewport', _overlayFooter, image);
         }  
     }
     function _overlayFooter( event ) {
         var image = event.userData;
         if ( image.config.global.bottomMargin() > 0 ) {
             var footerHeight = image.config.global.bottomMargin();
             var footerPos = new OpenSeadragon.Point( 0, image.container.height() - footerHeight );
             var footerSize = new OpenSeadragon.Point( image.container.width(), footerHeight );
             
             if ( !image.canvasScale ) {
                 image.canvasScale = image.viewer.drawer.context.canvas.width / image.viewer.drawer.context.canvas.clientWidth;
             }
             
             if ( image.canvasScale != 1 ) {
                 footerPos = footerPos.times( image.canvasScale );
                 footerSize = footerSize.times( image.canvasScale );
             }
             image.viewer.drawer.context.drawImage( image.footerImage, footerPos.x, footerPos.y, footerSize.x, footerSize.y );
         }
     };
     
     function _setupZoomSlider(image) {
         if(ImageView.ZoomSlider) {
             var slider = new ImageView.ZoomSlider(image.config.zoom, image);
             return slider;
         }
     }

     
     function _setupRotation(image) {
                  
         //set initial rotation
         var degrees = image.config.image.initialRotation;
         var deskew = _getDeskewAngle(degrees);
         image.rotation = _getRotation(degrees);
         var config = image.config.global;
         var viewer = image.viewer;
         
         //setup deskew slider
         if(config.rotationSlider) {             
             $("#" + config.rotationSlider).slider({
                 orientation: "vertical",
                 min: _MIN_DESKEW_ANGLE,
                 max: _MAX_DESKEW_ANGLE,
                 step: 0.1,
                 slide: function(event, ui) {
                     var degrees = -ui.value;
                     var deskew = _getDeskewAngle(degrees);
                     viewer.viewport.setRotation(deskew + image.rotation);
                 }
             });
             $("#" + config.rotationSlider).slider("option", "value", -deskew);
         }
         
         //handle rotation input
         if(config.rotationInput) {             
             $("#" + config.rotationInput).on("blur", function(event) {
            	 image.rotate(event.target.value);
             });
         }
         //handle rotation changes
         viewer.addHandler( 'rotate', function( event ) {
             var degrees = _normalizeAngle(event.degrees);
             var deskew = _getDeskewAngle(degrees);
             image.rotation = _getRotation(viewer.viewport.getRotation());
             if(config.rotationInput) {                              
                 var rot = (image.rotation + deskew);
                 $("#" + config.rotationInput).val(rot.toFixed(1)).change();
             }
         });
     }
     
     function _normalizeAngle(degrees) {
         var norm = ((degrees%360)+360)%360;
         return norm;
     }

     /**
      * get the rotation as a value between 0 and 360 degrees and rounded to 90 degrees 
      * 
      * @param degrees
      * @return    the rotation in 90 degree multiples
      */
     function _getRotation(degrees) {
         degrees += _MAX_DESKEW_ANGLE;
         degrees /= 90;
         degrees = parseInt(degrees);
         degrees *= 90;
         return _normalizeAngle(degrees);
     }

     /**
      * get the rotation modulo 90 degrees as a value between 0 and 45 degrees or between 315 and 360 degrees
      * 
      * @param degrees
      * @return the deskew part of the rotation
      */
     function _getDeskewAngle(degrees) {
         degrees += _MAX_DESKEW_ANGLE;
         degrees = parseFloat(degrees%90);
         degrees -= _MAX_DESKEW_ANGLE;
         degrees = _normalizeAngle(degrees);
         degrees = degrees > _MAX_DESKEW_ANGLE ? degrees-360 : degrees;
        return degrees;
     }
     
     function _calculateSizes(image) {
         if ( _debug ) {
             console.log( "viewImage: calcualte sizes" );
             console.log("Home zoom = ", image.viewer.viewport.getHomeZoom());
         }

         
         var sizes = new ImageView.Measures( image );
         
         if ( image.config.global.adaptContainerHeight || image.config.global.adaptContainerWidth ) {
             sizes.resizeCanvas();
         }
         
         /*TODO: 
          * Set image margins not with openseadragon margins since they are buggy
          * try using viewport.setBounds(...) instead
          */
         if ( image.viewer != null && image.getSizes() ) {
             var margins = image.viewer.viewport.getMargins();
             var rotation = image.viewer.viewport.getRotation(); 
             var ratio = image.getSizes().ratio(image.getSizes().innerCanvasSize);
            if(rotation%180 == 0){                
                margins.right = image.config.global.rightMargin();
                margins.left = 0;
                margins.top = image.config.global.topMargin();
                margins.bottom = sizes.footerHeight + sizes.calculateExcessHeight();
            } else if(rotation%180 == 90){ 
                margins.right = image.config.global.rightMargin();
                margins.left = 0;
                margins.top = image.config.global.topMargin();
                margins.bottom = (sizes.footerHeight + sizes.calculateExcessHeight());
            }
//             console.log("sizes.calculateExcessHeight()", sizes.calculateExcessHeight());
//            	 console.log("set margins ", margins, image);
             image.viewer.viewport.setMargins(margins);
         }
         
         if ( _debug ) {
             console.log( "sizes: ", sizes );
         }
         return sizes;
     };
     
     function _timeout(promise, time) {
         var deferred = new jQuery.Deferred();

         $.when(promise).done(deferred.resolve).fail(deferred.reject).progress(deferred.notify);

         setTimeout(function() {
             deferred.reject("timeout");
         }, time);

         return deferred.promise();
     }



     /**
      * Creates a tilesource object usable by the OpenSeadragon viewer from a url or json-object
      * @param source   either a url pointing to a iiif info json-object or directly to an image 
      * or a iiif info json-object, optionally as a string, or a list of image resource objects - consisting
      * each of a url, a width and a height - which act as layers of a pyramid view
      * @return a promise resolved when any urls are loaded - if no urls need to be loaded, the promise resolves immediately
      */
     function _createTileSource(source, config) {

         var result = Q.defer();

         ImageView.TileSourceResolver.resolveAsJson(source)
         .then(
                 function(imageInfo) {                        
                     if(_debug) {                
                         console.log("IIIF image info ", imageInfo);                        
                     }               
                     _setImageSizes(imageInfo, config.global.imageSizes);       
                     _setTileSizes(imageInfo, config.global.tileSizes);      
                     if(_debug) {                
                         console.log("adapted IIIF image info ", imageInfo);                        
                     } 
                     var tileSource;
                     if(config.global.useTiles && imageInfo.tiles && imageInfo.tiles.length > 0) {
                         tileSource = new OpenSeadragon.IIIFTileSource(imageInfo);                    
                     } else {                
                         tileSource  = _createPyramid(imageInfo, config);                    
                     }
                     
                     return tileSource;                
                 },
                 function(error) {            
                     if(ImageView.TileSourceResolver.isURI(config.image.tileSource)) {
                         if(_debug) {                    
                             console.log("Image URL", config.image.tileSource);                        
                         }
                         
                         var tileSource = new OpenSeadragon.ImageTileSource( {                    
                             url: config.image.tileSource,                        
                             buildPyramid: true,                        
                             crossOriginPolicy: false                        
                         } );
     
                         return tileSource;                    
                     } else {                
                         var errorMsg = "Failed to load tilesource from " + tileSource;
                         
                         if(_debug) {                    
                             console.log(errorMsg);                        
     }
                         
                         return Q.reject(errorMsg);
                         
                     }              
                 })
         .then(function(tileSource) {              
             result.resolve(tileSource);          
         }).catch(function(errorMessage) {              
             result.reject(errorMessage);          
         });
         return result.promise;
     }
     
     /**
      * creates a OpenSeadragon.LegacyTileSource (pyramid image source) from the given imageInfo object, which may either
      * be a IIIF imageInfo json-object or a list of image resource objects - consisting
      * each of a url, a width and a height
      * @param imageInfo    the image information json object, either a iiif image resource or a list of simple image resources
      * @return the tilesource usable by OpenSeadragon
      */
     function _createPyramid( imageInfo, config ) {
         if(_debug) {
             console.log("Creating legacy tilesource from imageInfo ", imageInfo);
         }
         var fileExtension = config.image.mimeType;
         fileExtension = fileExtension.replace( "image/", "" );
         fileExtension = fileExtension.replace("jpeg", "jpg").replace("tiff", "tif");
         var imageLevels = [];
         var tileSource;
         if(Array.isArray(imageInfo)) {
             imageInfo.forEach(function(level) {
                 level.mimetype = config.image.mimeType;
             });
             tileSource = new OpenSeadragon.LegacyTileSource(imageInfo);
         } else if(imageInfo.sizes) {
             imageInfo.sizes.forEach(function(size) {
                 if(!size.height) {
                     var ratio = imageInfo.width/imageInfo.height;
                     size.height = Math.round(size.width / ratio);
                 } else if(!size.width) {
                     var ratio = imageInfo.width/imageInfo.height;
                     size.width = Math.round(size.width * ratio);
                 }
                 if(_debug) {                    
                     console.log("Image level width = ", size.width)
                     console.log("Image level height = ", size.height)
                 }
                 var sizeParam = size.width + "," + size.height;
                 if( ( !size.width || size.width >= imageInfo.width) && (!size.height || size.height >= imageInfo.height) ) {
                     sizeParam = "max";
                 }
                 
                 var level = {
                     mimetype: config.image.mimeType,
                     url: imageInfo["@id"].replace( "/info.json", "" ) + "/full/" + sizeParam + "/0/default." + fileExtension,
                     width: imageInfo.width,
                     height: imageInfo.height
                 };
                 
                 if(_debug) {
                     console.log("Created level ", level);
                 }
                 
                 imageLevels.push( level );
             });
             
             tileSource = new OpenSeadragon.LegacyTileSource(imageLevels);
         } else {
             tileSource = new OpenSeadragon.ImageTileSource({
                 url: imageInfo["@id"].replace( "/info.json", "" ) + "/full/full/0/default." + fileExtension,
                 crossOriginPolicy: "Anonymous",
                 buildPyramid: false
             });
         }
         
         return tileSource;
     }
     
     /**
      * Inserts the given image sizes into the imageInfo object
      * @param imageInfo    the imageInfo object in which the sizes are inserted
      * @param sizes        the sizes to be inserted
      */
     function _setImageSizes(imageInfo, sizes) {
         if(sizes) {             
             if(typeof sizes == 'string') {                 
             var string = sizes.replace(/[\{\}]/, "");
             var sizes = JSON.parse(sizes);
             }
             var iiifSizes = [];
             sizes.forEach(function(size) {
                 if(size.width || size.height) {
                     iiifSizes.push(size);
                 } else {                     
                     iiifSizes.push({"width": parseInt(size), "height": parseInt(size)});
                 }
             });
             if(iiifSizes.length > 0) {              
                 imageInfo.sizes = iiifSizes;
             }
         }
     }
     /**
      * Inserts the given tiles into the imageInfo object
      * @param imageInfo    the imageInfo object in which the tiles are inserted
      * @param tiles        the tiles to be inserted
      */
     function _setTileSizes(imageInfo, tiles) {
         if(tiles) {             
             if(typeof tiles === 'string') {                 
                 var tileString = tiles.replace(/(\d+)/, '"$1"').replace("=", ":");
                 tiles = JSON.parse(tileString);
             }
             var iiifTiles = [];
             if(Array.isArray(tiles)) {
                 iiifTiles = tiles;
             } else {                 
                 Object.keys(tiles).forEach(function(size) {
                     var scaleFactors = tiles[size];
                     iiifTiles.push({"width": parseInt(size), "height": parseInt(size), "scaleFactors": scaleFactors})
                 });
             }
             if(iiifTiles.length > 0) {                 
                 imageInfo.tiles = iiifTiles;
             }
         }
     }
     
     function _loadSources(sources, config) {
         if(typeof sources === 'string' && sources.startsWith("[")) {
             if(_debug)console.log("Sources = ", sources);
             sources = JSON.parse(sources);
         } else if(!$.isArray(sources)) {
             sources = [sources];
         }
         //create promises for loading of image sources
         var promises = [];
         for ( var i=0; i<sources.length; i++) {
             var source = sources[i];
             // returns the OpenSeadragon.TileSource if it can be created,
             // otherweise
             // rejects the promise
             var promise = _createTileSource(source, config);
             promises.push(promise); 
         }        
         return promises;
     }
     
     function _scaleTileSources(tileSources, image) {
         var minWidth = Number.MAX_VALUE;  
         var minHeight = Number.MAX_VALUE;
         var minAspectRatio = Number.MAX_VALUE;
         for ( var j=0; j<tileSources.length; j++) {
             var tileSource = tileSources[j];
             minWidth = Math.min(minWidth, tileSource.width);
             minHeight = Math.min(minHeight, tileSource.height);
             minAspectRatio = Math.min(minAspectRatio, tileSource.aspectRatio);
             //make sure we have some values for original image size in config
             if(!image.config.image.originalImageWidth) {
                 image.config.image.originalImageWidth = tileSource.width;
             }
             if(!image.config.image.originalImageHeight) {
                 image.config.image.originalImageHeight = tileSource.height;
             }
         }
         if(_debug) {      
             console.log("original image size: ",  image.config.image.originalImageWidth,  image.config.image.originalImageHeight )
             console.log("Min aspect ratio = " + minAspectRatio);                    
         }
         var x = 0;
         for ( var i=0; i<tileSources.length; i++) {
             var tileSource = tileSources[i];
             tileSources[i] = {
                     tileSource: tileSource,
                     width: tileSource.aspectRatio/minAspectRatio,
                     x : x,
                     y: 0,
                 }
             x += tileSources[i].width;
         }
         return tileSources;
     }
     
     return imageView;
})();

//browser backward compability
if(!String.prototype.startsWith) {
    String.prototype.startsWith = function(subString) {
        var start = this.substring(0,subString.length);
        return start.localeCompare(subString) === 0;
    }
}
if(!String.prototype.endsWith) {
    String.prototype.endsWith = function(subString) {
        var start = this.substring(this.length-subString.length,this.length);
        return start.localeCompare(subString) === 0;
    }
}
if(!Array.prototype.find) {
    Array.prototype.find = function(comparator) {
        for ( var int = 0; int < this.length; int++ ) {
            var element = this[int];
            if(comparator(element)) {
                return element;
            }
        }
    }
}
if(!Number.isNaN) {
    Number.isNaN = function(number) {
        return number !== number;
    }
}




var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView) {
        throw "Image view must exist";
    }    
    
    /**
     * rect must be in openSeadragon image coordinates (0 <= x <= 1 / 0 <= y <= height/width)
     */
    imageView.Overlay = function(rect, viewer, style, rotateWithImage) {
            
        // OpenSeadragon viewer
        this.viewer = viewer;
        // OpenSeadragon rect
        this.rect = rect;
        // object containing properties borderWidth and borderColor
        this.style = style;
        this.fixed = null;
        this.allowMove = false;
        this.rotateWithImage = rotateWithImage ? true : false;
            
    }
    
    imageView.Overlay.prototype.getRotation = function() {
        return this.viewer.viewport.getRotation();
    }
    
    imageView.Overlay.prototype.remove = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            this.viewer.forceRedraw();
        }
    }

    imageView.Overlay.prototype.draw = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
        }
        _drawRect({userData: this});
        this.eventHandler = function(event) {
            _drawRect(event)
        }
        this.viewer.addHandler( 'update-viewport', this.eventHandler, this );
    }
    
    imageView.Overlay.prototype.contains = function(point, extra, pointInCanvas) {
        var rect = pointInCanvas ? imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(this.rect, this.viewer) : this.rect;
        return _isInside(rect, point, extra);
    }
    
    imageView.Overlay.prototype.getHitArea = function(point, extra, pointInCanvas) {
        var rect = pointInCanvas ? imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(this.rect, this.viewer) : this.rect;
        if(_isInside(rect, point, extra)) {
            var area = _findCorner(rect, point, extra);
            if(!area) {
                area = _findEdge(rect, point, extra);
            }
            if(this.allowMove && !area && _isInside(rect, point, 0)){
                area = imageView.Overlay.HitAreas.CENTER;
            }
          //prohibit fixed areas
            if(_isFixed(area, this.fixed)) {
                return imageView.Overlay.HitAreas.FIXED;
            }
        }
        return area;
    }
    
    imageView.Overlay.prototype.hide = function( immediate) {
        this.hidden = true;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    imageView.Overlay.prototype.show = function(immediate) {
        this.hidden = false;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    imageView.Overlay.convertStringToRect = function(string) {
        var parts = string.split(",");
        if(parts && parts.length == 4) {            
            var rect = new OpenSeadragon.Rect(parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
            return rect;
        } else {
            throw "Cannot convert string '" + string + "' to Rectangle";
        }
    }
    
    imageView.Overlay.convertRectToString = function(rect, decimalPlaces) {
        if(!decimalPlaces) {
            decimalPlaces = 0;
        }
        return rect.x.toFixed(decimalPlaces) + "," +  rect.y.toFixed(decimalPlaces) + "," +  rect.width.toFixed(decimalPlaces) + "," +  rect.height.toFixed(decimalPlaces);
    }
    
    imageView.Overlay.drawPoint = function(point, viewer, color, radius) {
        _drawPoint({userData: [point, viewer, color, radius] });
    }
    
    imageView.Overlay.HitAreas = {
            TOP: "t",
            BOTTOM: "b",
            RIGHT: "r",
            LEFT: "l",
            TOPLEFT: "tl",
            TOPRIGHT: "tr",
            BOTTOMLEFT: "bl",
            BOTTOMRIGHT: "br",
            CENTER: "c",
            FIXED: "f",
            isCorner: function( area ) {
                return area === this.TOPRIGHT || area === this.TOPLEFT || area === this.BOTTOMLEFT || area === this.BOTTOMRIGHT;
            },
            isEdge: function( area ) {
                return area === this.TOP || area === this.BOTTOM || area === this.LEFT || area === this.RIGHT;
            },
            getCursor: function( area ) {
                var rotated = false;//draw.viewer.viewport.getRotation() % 180 === 90;
                if ( area === this.TOPLEFT || area === this.BOTTOMRIGHT ) {
                    return rotated ? "nesw-resize" : "nwse-resize";
                }
                else if ( area === this.TOPRIGHT || area === this.BOTTOMLEFT ) {
                    return rotated ? "nwse-resize" : "nesw-resize";
                }
                else if ( area === this.TOP || area === this.BOTTOM ) {
                    return rotated ? "ew-resize" : "ns-resize";
                }
                else if ( area === this.RIGHT || area === this.LEFT ) {
                    return rotated ? "ns-resize" : "ew-resize";
                }
                else if ( area === this.CENTER ) {
                    return "move";
                } else if( area === this.FIXED ) {
                    return "not-allowed";
                } else {
                    return undefined;
                }
            }
        }
    
    function _drawRect(event) {
        var overlay = event.userData;
        if(!overlay.hidden) {
            var context = overlay.viewer.drawer.context;
            var rect = ImageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(overlay.rect, overlay.viewer).times(window.devicePixelRatio);
            
            if(overlay.rotateWithImage) {                
                let rotatedRect = rect.rotate(overlay.viewer.viewport.getRotation());
                rect = rotatedRect;
            }
            
            
            context.beginPath();        
            context.lineWidth = overlay.style.borderWidth;
            context.strokeStyle = overlay.style.borderColor;
            context.rect(rect.x, rect.y, rect.width, rect.height);
            context.stroke();
        }
    }
    
    
    
    function _drawPoint(event) {
        var point = event.userData[0].times(window.devicePixelRatio);
        var viewer = event.userData[1];
        var color = event.userData[2];
        var radius = event.userData[3];
        var context = viewer.drawer.context;
//        console.log("draw on canvas ", viewer.drawer.context)
//        var point_canvas = ImageView.convertPointFromImageToCanvas(point, viewer);
        context.beginPath();
        if(color) {
            context.fillStyle = color;
        }
        context.arc(point.x, point.y, radius, 0, 2*Math.PI, true);
        context.fill();
    }
    
    function _isInside( rect, point, extra ) {
//        console.log("point = " + point.x.toFixed(3) + "/" + point.y.toFixed(3));
//        console.log("rect ul = " + rect.getTopLeft().x.toFixed(3) + "/" + rect.getTopLeft().y.toFixed(3));
        return point.x > (rect.getTopLeft().x - extra) && point.x < ( rect.getBottomRight().x + extra ) && 
        point.y > (rect.getTopLeft().y - extra)  && point.y < ( rect.getBottomRight().y + extra );
    }

    /*
     * Determine the side of the rectangle rect the point lies on or closest at <=maxDist
     * distance
     */
    function _findEdge( rect, point, maxDist ) {
        var distanceToLeft = _distToSegment( point, rect.getTopLeft(), rect.getBottomLeft() );
        var distanceToBottom = _distToSegment( point, rect.getBottomLeft(), rect.getBottomRight() );
        var distanceToRight = _distToSegment( point, rect.getTopRight(), rect.getBottomRight() );
        var distanceToTop = _distToSegment( point, rect.getTopLeft(), rect.getTopRight() );
        
        var minDistance = Math.min( distanceToLeft, Math.min( distanceToRight, Math.min( distanceToTop, distanceToBottom ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToLeft === minDistance ) {
                return imageView.Overlay.HitAreas.LEFT;
            }
            if ( distanceToRight === minDistance ) {
                return imageView.Overlay.HitAreas.RIGHT;
            }
            if ( distanceToTop === minDistance ) {
                return imageView.Overlay.HitAreas.TOP;
            }
            if ( distanceToBottom === minDistance ) {
                return imageView.Overlay.HitAreas.BOTTOM;
            }
        }
        return "";
    }
    
    function _isFixed(area, fixed) {
        if(area && fixed) {
            switch(area) {
                case imageView.Overlay.HitAreas.TOP: 
                    return fixed.y || fixed.height;
                case imageView.Overlay.HitAreas.BOTTOM: 
                    return fixed.height;
                case imageView.Overlay.HitAreas.LEFT: 
                    return fixed.x || fixed.width;
                case imageView.Overlay.HitAreas.RIGHT: 
                    return fixed.width;
                case imageView.Overlay.HitAreas.TOPLEFT: 
                    return fixed.x || fixed.y || fixed.width || fixed.height;
                case imageView.Overlay.HitAreas.TOPRIGHT: 
                    return fixed.y || fixed.width || fixed.height;
                case imageView.Overlay.HitAreas.BOTTOMLEFT: 
                    return fixed.height || fixed.x || fixed.width;
                case imageView.Overlay.HitAreas.BOTTOMRIGHT: 
                    return fixed.width || fixed.height;
                case imageView.Overlay.HitAreas.CENTER: 
                    return fixed.y || fixed.x;
                case imageView.Overlay.HitAreas.FIXED:
                    return true;
            }
        }
        return false;
    }

    /*
     * Determine the cornder of the rectangle rect the point lies on or closest at
     * <=maxDist distance
     */
    function _findCorner( rect, point, maxDist ) {
        var distanceToTopLeft = _dist( point, rect.getTopLeft() );
        var distanceToBottomLeft = _dist( point, rect.getBottomLeft() );
        var distanceToTopRight = _dist( point, rect.getTopRight() );
        var distanceToBottomRight = _dist( point, rect.getBottomRight() );
        
        var minDistance = Math.min( distanceToTopLeft, Math.min( distanceToTopRight, Math.min( distanceToBottomLeft, distanceToBottomRight ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToTopLeft === minDistance ) {
                return imageView.Overlay.HitAreas.TOPLEFT;
            }
            if ( distanceToTopRight === minDistance ) {
                return imageView.Overlay.HitAreas.TOPRIGHT;
            }
            if ( distanceToBottomLeft === minDistance ) {
                return imageView.Overlay.HitAreas.BOTTOMLEFT;
            }
            if ( distanceToBottomRight === minDistance ) {
                return imageView.Overlay.HitAreas.BOTTOMRIGHT;
            }
        }
        return "";
    }

    function _sqr( x ) {
        return x * x
    }
    function _dist2( v, w ) {
        return _sqr( v.x - w.x ) + _sqr( v.y - w.y )
    }
    function _dist( v, w ) {
        return Math.sqrt( _dist2( v, w ) )
    }
    function _distToSegmentSquared( p, v, w ) {
        var l2 = _dist2( v, w );
        if ( l2 == 0 )
            return _dist2( p, v );
        var t = ( ( p.x - v.x ) * ( w.x - v.x ) + ( p.y - v.y ) * ( w.y - v.y ) ) / l2;
        if ( t < 0 )
            return _dist2( p, v );
        if ( t > 1 )
            return _dist2( p, w );
        return _dist2( p, {
            x: v.x + t * ( w.x - v.x ),
            y: v.y + t * ( w.y - v.y )
        } );
    }
    function _distToSegment( point, lineP1, lineP2 ) {
        return Math.sqrt( _distToSegmentSquared( point, lineP1, lineP2 ) );
    }



    


    
return imageView;

})( ImageView );
 

var ImageView = ( function( imageView ) {
    imageView.ColorIterator = function(colors) {
        
        if(Array.isArray(colors)) {
            this.index = 0;
            this.colors = colors;
            this.next = function() {
                let color = this.colors[this.index];
                this.index = (this.index < this.colors.length-1) ? this.index+1 : 0;
                return color;
            }
        } else if(_isFunction(colors)){
            this.next = colors;
        } else {
            throw "No valid constructor parameter. Must be either an array or a function";
        }
        
    }
    
    imageView.ColorIterator.randomColor = function() {
        return '#'+Math.floor(Math.random()*16777215).toString(16);

    }
    
    function _isFunction(functionToCheck) {
        return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
       }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
//    var _currentZoom;
//    var _zoomedOut = true;
//    var _panning = false;
//    var _fadeout = null;
      
    imageView.Controls = function(config, image) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'imageView.controls.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            var controls = this;
            
            if(imageView.Controls.Persistence) {
                this.persistence = new imageView.Controls.Persistence(config, image)
//                imageView.controls.persistence.init(config);
            }
            if(_debug) {                
                console.log("Setting viewer location to", config.image.location);
            }
            if(this.config.global.controls) {
                $(this.config.global.controls.rotateLeft).on("click", function() {
                    controls.rotateLeft();
                })
                $(this.config.global.controls.rotateRight).on("click", function() {
                    controls.rotateRight();
                })
                $(this.config.global.controls.reset).on("click", function() {
                    controls.reset(true);
                })
            }
            if( image.observables ) {
                // set location after viewport update
                image.observables.redrawRequired
                .merge(image.observables.viewerOpen)
                .sample(image.observables.viewportUpdate)
                .subscribe(function(event) {
                    controls.setLocation(event)
                    controls.setPanning( false );
                });
                
                // zoom home if min zoom reached
                if(image.config.global.panHomeOnZoomOut) {                    
                    image.observables.viewerZoom.subscribe( function( event ) {
                        if ( _debug ) {
                            console.log( "zoom to " + image.viewer.viewport.getZoom( true ) );
                        }
                        if ( !controls.isPanning() ) {
                            var currentZoom = image.viewer.viewport.getZoom();
                            if ( currentZoom <= image.viewer.viewport.minZoomLevel ) {
//                                if ( _debug ) {
//                                    console.log( "Zoomed out: Panning home" );
//                                }
                                
                                controls.setPanning(true);
                                controls.goHome( true );
                                controls.setPanning(false);
                            }
                        }
                    } );
                    image.observables.viewerRotate.subscribe( function(event) {
                        if(_debug)console.log("rotate viewer; zoomed out: ", this.zoomedOut);
                        if(this.zoomedOut) {
//                            controls.setPanning(true);
//                            controls.goHome( true );
//                            controls.setPanning(false);
                        }
                    }.bind(this))
                }
            }
            
            image.observables.viewerZoom.subscribe( function(event) {
                var currentZoom = image.viewer.viewport.getZoom( true );
                var targetZoom = image.viewer.viewport.getZoom( false );
                var homeZoom = image.viewer.viewport.getHomeZoom();
                var minZoom = image.viewer.viewport.getMinZoom();
//                if(_debug)console.log("min zoom ", homeZoom, minZoom);
//                if(_debug)console.log("zoom to ", currentZoom, targetZoom);
                if(currentZoom < targetZoom) {
                    //zoom in
                    this.zoomedOut = false;
                } else if(targetZoom === homeZoom) {
                    this.zoomedOut = true;
                }
            }.bind(this))
            
            // fade out fullscreen controls
            if ( $( '#fullscreenTemplate' ).length > 0 ) {
                $( '#fullscreenTemplate' ).on( 'mousemove', function() {  
                    controls.fullscreenControlsFadeout();
                } )
                
                $('#fullscreenMap').on('touchmove', function() {
                	controls.fullscreenControlsFadeout();
                }).on('touchend', function() {
                	controls.fullscreenControlsFadeout();
                });
            }
        }
        imageView.Controls.prototype.getLocation = function() {
            return {
                x: this.getCenter().x,
                y: this.getCenter().y,
                zoom: this.getZoom()/this.getCurrentRotationZooming(),
                rotation: this.getRotation(),
            }
        },
        imageView.Controls.prototype.getCenter = function() {
            if ( _debug ) {
                console.log( "image center is " + this.image.viewer.viewport.getCenter( true ) );
            }
            return this.image.viewer.viewport.getCenter( true );
        }
        imageView.Controls.prototype.setCenter = function( center ) {
            
            if ( _debug ) {
                console.log( "Setting image center to " );
                console.log( center );
            }
            
            this.image.viewer.viewport.panTo( center, true );
            
        },
        imageView.Controls.prototype.getZoom = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.getZoom' );
            }
            return this.image.viewer.viewport.getZoom( true );
        }
        imageView.Controls.prototype.zoomTo = function( zoomTo ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.myZoomTo: zoomTo - ' + zoomTo );
            }
            
            var zoomBy = parseFloat( zoomTo ) / this.image.viewer.viewport.getZoom();
            
            if ( _debug ) {
                console.log( 'osViewer.controls.myZoomTo: zoomBy - ' + zoomBy );
            }
            
            this.image.viewer.viewport.zoomBy( zoomBy, this.image.viewer.viewport.getCenter( false ), true );
        }
        imageView.Controls.prototypesetFullScreen = function( enable ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.setFullScreen: enable - ' + enable );
            }
            
            this.image.viewer.setFullScreen( enable );
        }
        imageView.Controls.prototype.goHome = function( immediate ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.panHome - zoom : ' + this.image.viewer.viewport.getHomeZoom() );
            }
            this.image.viewer.viewport.goHome( immediate );
            this.zoomedOut = true;
        }
        imageView.Controls.prototype.reset = function( resetRotation ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.goHome: bool - ' + resetRotation );
            }
            
            // osViewer.viewer.viewport.goHome( true );
            this.goHome( true );
            this.image.viewer.viewport.zoomTo( this.image.viewer.viewport.getHomeZoom(), null, true );
            if ( resetRotation ) {
                this.rotateTo( 0 );
            }
        }
        imageView.Controls.prototype.zoomIn = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.zoomIn: zoomSpeed - ' + this.config.global.zoomSpeed );
            }
            
            this.image.viewer.viewport.zoomBy( this.config.global.zoomSpeed, this.image.viewer.viewport.getCenter( false ), false );
        }
        imageView.Controls.prototype.zoomOut = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.zoomOut: zoomSpeed - ' + this.config.global.zoomSpeed );
            }
            
            this.image.viewer.viewport.zoomBy( 1 / this.config.global.zoomSpeed, this.image.viewer.viewport.getCenter( false ), false );
        }
//        imageView.Controls.prototype.getHomeZoom: function( rotated ) {
//            if ( rotated && this.image.getCanvasSize().x / osViewer.getCanvasSize().y <= osViewer.getImageSize().x / osViewer.getImageSize().y ) {
//                osViewer.viewer.viewport.homeFillsViewer = true;
//            }
//            var zoom = osViewer.viewer.viewport.getHomeZoom();
//            osViewer.viewer.viewport.homeFillsViewer = false;
//            return zoom;
//        },
        imageView.Controls.prototype.rotateRight = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.rotateRight' );
            }
            
            var newRotation = this.image.viewer.viewport.getRotation() + 90;
            this.rotateTo( newRotation );
        }
        imageView.Controls.prototype.rotateLeft = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.rotateLeft' );
            }
            
            var newRotation = this.image.viewer.viewport.getRotation() - 90;
            this.rotateTo( newRotation );
        },
        imageView.Controls.prototype.getRotation = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.getRotation' );
            }
            
            return this.image.viewer.viewport.getRotation();
        }
        imageView.Controls.prototype.setRotation = function( rotation ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.setRotation: rotation - ' + rotation );
            }
            
            return this.rotateTo( rotation );
        }
        imageView.Controls.prototype.rotateTo = function( newRotation ) {
            if ( newRotation < 0 ) {
                newRotation = newRotation + 360;
            }
            newRotation = newRotation % 360;

            if ( _debug ) {
            	console.log( 'osViewer.controls.rotateTo: newRotation - ' + newRotation );
            }
                        
            this.panning = true;        
            this.currentZoom = null;
            this.image.viewer.viewport.setRotation( newRotation );
            this.panning = false;

        }
        imageView.Controls.prototype.getCurrentRotationZooming = function() {
            var sizes = this.image.getSizes();
            if(sizes && sizes.rotated()) {
                return 1/sizes.ratio(sizes.originalImageSize);
            } else {
                return 1;
            }
        }
        imageView.Controls.prototype.setPanning = function(panning) {
            this.panning = panning;
        }
        imageView.Controls.prototype.isPanning = function() {
            return this.panning;
        }
        imageView.Controls.prototype.fullscreenControlsFadeout = function() {
            if ( _debug ) {
                console.log( '---------- osViewer.controls.fullscreenControlsFadeout() ----------' );
            }
            
            if ( this.fadeout ) {
                clearTimeout( this.fadeout );
                this.showFullscreenControls();
            }
            
            this.fadeout = setTimeout( this.hideFullscreenControls, 3000 );
        },
        imageView.Controls.prototype.hideFullscreenControls = function() {
            if ( _debug ) {
                console.log( '---------- osViewer.controls.hideFullscreenControls() ----------' );
            }
            
            $( '#fullscreenRotateControlsWrapper, #fullscreenZoomSliderWrapper, #fullscreenExitWrapper, #fullscreenPrevWrapper, #fullscreenNextWrapper' ).stop().fadeOut( 'slow' );
        }
        imageView.Controls.prototype.showFullscreenControls = function() {
            if ( _debug ) {
                console.log( '---------- osViewer.controls.showFullscreenControls() ----------' );
            }
            
            $( '#fullscreenRotateControlsWrapper, #fullscreenZoomSliderWrapper, #fullscreenExitWrapper, #fullscreenPrevWrapper, #fullscreenNextWrapper' ).show();
        }
        // set correct location, zooming and rotation once viewport has been updated after
        // redraw
        imageView.Controls.prototype.setLocation = function(event) {
            if(_debug) {                    
                console.log("Viewer changed from " + event.osState + " event");
                console.log("target location: ", event.targetLocation);
                console.log("Home zoom = ", this.image.viewer.viewport.getHomeZoom());
            }
            this.image.viewer.viewport.minZoomLevel = this.image.viewer.viewport.getHomeZoom() * this.config.global.minZoomLevel;
//            if(true) {
//                return;
//            }
                var targetZoom = event.targetLocation.zoom;
                var targetLocation = undefined;
                if(event.targetLocation.x || event.targetLocation.y) {    
                    if(event.targetLocation.panTo !== false) {
                        this.zoomedOut = false;
                    }
                    targetLocation = new OpenSeadragon.Point(event.targetLocation.x, event.targetLocation.y);
                }
//                var zoomDiff = targetZoom * this.image.viewer.viewport.getHomeZoom() - (this.image.viewer.viewport.minZoomLevel);
//                this.zoomedOut = Math.abs(zoomDiff) < 0.001 || !targetZoom;
//                console.log("zoomDiff ", zoomDiff, "=", targetZoom, "*", this.image.viewer.viewport.getHomeZoom(), "-", this.image.viewer.viewport.minZoomLevel )
                if(this.zoomedOut && this.image.config.global.fitToContainer) {
                    if(_debug) {                         
                        console.log("Zooming home")
                    }
                    this.goHome( true );
                } else {
                    if(_debug) {                         
                        console.log( "Zooming to " + targetZoom + " * " + this.getCurrentRotationZooming() );
                    }
                    if(this.image.config.global.fitToContainer) {
                        this.image.viewer.viewport.zoomTo( targetZoom * this.getCurrentRotationZooming(), null, true);
                    }
                    if(targetLocation && targetLocation.x < 2 && targetLocation.y < 2) {   
                        if(_debug) {                            
                            console.log("panning to ", targetLocation);
                        }
                        this.setCenter( targetLocation);
                    }
                }
                if(event.osState === "open" && event.targetLocation.rotation && !isNaN(event.targetLocation.rotation) && event.targetLocation.rotation !== 0) {
                    this.rotateTo(event.targetLocation.rotation);
                }
        }

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false; 
    
    imageView.Controls.Persistence = function(config, image) {
        
            if ( typeof ( Storage ) !== 'undefined' ) {
                
                /**
                 * Set Location from local storage
                 */
                var location = null;
                var currentPersistenceId = config.global.persistenceId;
                if ( config.global.persistZoom || config.global.persistRotation ) {
                    try {
                        var location = JSON.parse( localStorage.imageLocation );
                    }
                    catch ( err ) {
                        if ( _debug ) {
                            console.debug( "No readable image location in local storage" );
                        }
                    }
                    if ( location && _isValid( location ) && location.persistenceId === currentPersistenceId ) {
                        if ( _debug ) {
                            console.log( "Reading location from local storage", location );
                        }
                        config.image.location = {};
                        if ( config.global.persistZoom ) {
                            if ( _debug ) {
                                console.log( "setting zoom from local storage" );
                            }
                            config.image.location.zoom = location.zoom;
                            config.image.location.x = location.x;
                            config.image.location.y = location.y;
                        }
                        if ( config.global.persistRotation ) {
                            if ( _debug ) {
                                console.log( "setting rotation from local storage" );
                            }
                            config.image.location.rotation = location.rotation;
                        }
                        else {
                            config.image.location.rotation = 0;
                        }
                        
                    }
                    
                    this.saveLocation = function(event) {
                    	var loc = image.controls.getLocation();
                    	loc.persistenceId = config.global.persistenceId;
                    	localStorage.imageLocation = JSON.stringify( loc );
                    	if ( _debug ) {
                    	    console.log( "storing zoom " + localStorage.imageLocation );
                    	}
                    }
                    
                    /**
                     * save current location to local storage before navigating away
                     */
//                    this.saveLocation();
                    image.observables.close.subscribe(() =>  this.saveLocation());
                    $(window).bind("beforeunload", this.saveLocation);
                }
                
            }

        }

    function _isValid( location ) {
        return _isNumber( location.x ) && _isNumber( location.y ) && _isNumber( location.zoom ) && _isNumber( location.rotation );
    }
    
    function _isNumber( x ) {
        return typeof x === "number" && !Number.isNaN( x );
    }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    var _debug = false;
    
    imageView.CoordinateConversion = {};
    var cc = imageView.CoordinateConversion;
    
    /**
     * Scale the given point or rectangle in the original image to OpenSeadragon coordinates
     * This is the inverse of scaleToImage
     */
    imageView.CoordinateConversion.scaleToOpenSeadragon = function(coords, viewer, originalImageSize) {
        originalImageSize = cc.getAsDimension(originalImageSize);
        coords = _convertToOpenSeadragonObject(coords);
    	var displayImageSize = viewer.world.getItemAt(0).source.dimensions;
        var scale = originalImageSize.x/displayImageSize.x;
        coords = coords.times(1/displayImageSize.x);
        coords = coords.times(1/scale);     
        return coords;
    }
    
    /**
     * Scale the given point or rectangle in OpenSeadragon coordinates to original image coordinates
     * This is the inverse of scaleToOpenseadragon
     */
    imageView.CoordinateConversion.scaleToImage = function(coords, viewer, originalImageSize) {
        originalImageSize = cc.getAsDimension(originalImageSize);
        coords = _convertToOpenSeadragonObject(coords);
        var displayImageSize = viewer.world.getItemAt(0).source.dimensions;
        var scale = originalImageSize.x/displayImageSize.x;
        coords = coords.times(displayImageSize.x);
        coords = coords.times(scale);
        return coords;
    }

    
    /**
     * Scale the given point or rectangle in OpenSeadragon coordinates of the rotated image to coordinates of the original rotated image.
     * This is the inverse of scaleToOpenSeadragonCoordinates
     */
    imageView.CoordinateConversion.scaleToRotatedImage = function(roi, viewer, originalImageSize) {
    	var displayImageSize = viewer.world.getItemAt(0).source.dimensions;

        var displayImageRect = new OpenSeadragon.Rect(0,0,displayImageSize.x, displayImageSize.y);
        var originalImageRect = _convertToOpenSeadragonObject(cc.getAsRect(originalImageSize));
        var rotation = viewer.viewport.getRotation();
        var displayImageRect_rotated = cc.getRotatedBounds(displayImageRect, rotation);
        var originalImageRect_rotated = cc.getRotatedBounds(originalImageRect, rotation);
        
        var scale = originalImageRect_rotated.width/displayImageRect_rotated.width;
        roi = roi.times(displayImageSize.x);
        roi = roi.times(scale);
        return roi;
    }
    
    /**
     * input: a rectangle or point in the original image rotated by the current viewport rotation
     * output: the same rectangle/point scaled to OpenSeadragon coordinates of the rotated image
     * This is the inverse of scaleToRotatedImage
     */
    imageView.CoordinateConversion.scaleToOpenSeadragonCoordinates = function(roi, viewer, originalImageSize) {
    	var displayImageSize = viewer.world.getItemAt(0).source.dimensions;

        var displayImageRect = new OpenSeadragon.Rect(0,0,displayImageSize.x, displayImageSize.y);
        var originalImageRect = _convertToOpenSeadragonObject(cc.getAsRect(originalImageSize));
        
        var rotation = viewer.viewport.getRotation();
        var displayImageRect_rotated = cc.getRotatedBounds(displayImageRect, rotation);
        var originalImageRect_rotated = cc.getRotatedBounds(originalImageRect, rotation);
        
        var scale = originalImageRect_rotated.width/displayImageRect_rotated.width;
        roi = _convertToOpenSeadragonObject(roi);
        roi = roi.times(1/displayImageSize.x);
        roi = roi.times(1/scale);
        return roi;
    }
    
    /**
     * Converts a rectangle from the OpenSeadragon image to the rotated original image
     * This is the inverse of convertRectFromImageToOpenSeadragon
     */
    imageView.CoordinateConversion.convertRectFromOpenSeadragonToImage = function(rect, viewer, originalImageSize) {
        var rectInCanvas = ImageView.CoordinateConversion.convertRectFromImageToRotatedImage(rect, viewer);
        var rectInImage = cc.scaleToRotatedImage(rectInCanvas, viewer, originalImageSize);
        return rectInImage;
    }
    
    /**
     * Converts a rectangle from the rotated original image to the OpenSeadragon image
     * This is the inverse of convertRectFromOpenSeadragonToImage
     */
    imageView.CoordinateConversion.convertRectFromImageToOpenSeadragon = function(rect, viewer, originalImageSize) {
        var rectInCanvas = cc.scaleToOpenSeadragonCoordinates(rect, viewer, originalImageSize);
        var rectInOS = cc.convertRectFromRotatedImageToImage(rectInCanvas, viewer.viewport.getRotation(), originalImageSize);

        return rectInOS;
    }
    
    /**
     * Converts a rectangle from the rotated original image to the OpenSeadragon image
     * This is the inverse of convertPointFromOpenSeadragonToImage
     */
    imageView.CoordinateConversion.convertPointFromImageToOpenSeadragon = function(point, viewer, originalImageSize) {
    	var rectInOS = cc.convertPointFromRotatedImageToImage(point, viewer.viewport.getRotation(), originalImageSize);
        var rectInCanvas = cc.scaleToOpenSeadragonCoordinates(rectInOS, viewer, originalImageSize);
        return rectInCanvas;
    }
    
    /**
     * Converts a rectangle from the OpenSeadragon image to the rotated original image
     * This is the inverse of convertPointFromImageToOpenSeadragon
     */
    imageView.CoordinateConversion.convertPointFromOpenSeadragonToImage = function(point, viewer, originalImageSize) {
    	var pos_image = cc.scaleToImage(point, viewer, originalImageSize);
		var pos_image_rot = cc.convertPointFromImageToRotatedImage(pos_image, viewer.viewport.getRotation(), originalImageSize);
        return pos_image_rot;
    }
    
    /**
     * Converts a rectangle from the OpenSeadragon image to the canvas
     */
    imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas = function(rect, viewer) {
        var scale = viewer.drawer.context.canvas.width/viewer.viewport.getBoundsNoRotate(true).width;
        scale /= window.devicePixelRatio;
        
        var topLeft = cc.convertPointFromImageToCanvas(rect.getTopLeft(), viewer);
        var bottomRight = cc.convertPointFromImageToCanvas(rect.getBottomRight(), viewer);
        var centerX = topLeft.x + 0.5*(bottomRight.x-topLeft.x);
        var centerY = topLeft.y + 0.5*(bottomRight.y-topLeft.y);

        var canvasRect = new OpenSeadragon.Rect(centerX-0.5*rect.width*scale, centerY-0.5*rect.height*scale, rect.width*scale, rect.height*scale);
        return canvasRect;
    }
    
    /**
     * Converts a rectangle fom canvas coordinates to the OpenSeadragon image
     */
    imageView.CoordinateConversion.convertCoordinatesFromCanvasToImage = function(rect, viewer) {
        
        var scale = viewer.drawer.context.canvas.width/viewer.viewport.getBoundsNoRotate(true).width;
        scale /= window.devicePixelRatio;
        
        var topLeft = cc.convertPointFromCanvasToImage(rect.getTopLeft(), viewer);
        var bottomRight = cc.convertPointFromCanvasToImage(rect.getBottomRight(), viewer);
        var centerX = topLeft.x + 0.5*(bottomRight.x-topLeft.x);
        var centerY = topLeft.y + 0.5*(bottomRight.y-topLeft.y);
        var canvasRect = new OpenSeadragon.Rect(centerX-0.5*rect.width/scale, centerY-0.5*rect.height/scale, rect.width/scale, rect.height/scale);
        return canvasRect;
    }

    /**
     * Converts a point in the OpenSeadragon coordinate system (of the unrotated image) to the coordinate system of the canvas
     * This is affected by window.devicePixelRatio
     * This is the inverse of {@link ImageView.CoordinateConversion.convertPointFromCanvasToImage}
     */
    imageView.CoordinateConversion.convertPointFromImageToCanvas = function(point, viewer) {
    	
        var canvasWidth = viewer.drawer.context.canvas.width;
        var viewportWidth = viewer.viewport.getBoundsNoRotate(true).width;

        var scale = canvasWidth/viewportWidth;
        scale /= window.devicePixelRatio;
        var aspectRatio = viewer.source.width/viewer.source.height;
        var rotation = viewer.viewport.getRotation();
        var imageTopLeft_fromImageCenter = new OpenSeadragon.Point(0.5, 0.5/aspectRatio).times(-1);
        var canvasCenter_fromImageTopLeft = viewer.viewport.getCenter(true);
        var canvasCenter_fromCanvasTopLeft = new OpenSeadragon.Point(viewer.viewport.getBoundsNoRotate(true).width/2.0, viewer.viewport.getBoundsNoRotate(true).height/2.0);
        
        var canvasCenter_fromImageCenter = imageTopLeft_fromImageCenter.plus(canvasCenter_fromImageTopLeft);
        var canvasCenter_fromImageCenter_rotated = cc.rotate(canvasCenter_fromImageCenter, rotation, true);
        
        var imageCenter_fromCanvasTopLeft = canvasCenter_fromCanvasTopLeft.minus(canvasCenter_fromImageCenter_rotated);

        var point_fromImageCenter = imageTopLeft_fromImageCenter.plus(point);
        var point_fromImageCenter_rotated = cc.rotate(point_fromImageCenter, rotation, true);
        
        var point_FromCanvasTopLeft = imageCenter_fromCanvasTopLeft.plus(point_fromImageCenter_rotated);

        var p = point_FromCanvasTopLeft.times(scale);
        
        return p;
    }
    
    /**
     * Converts a point in the canvas coordinate system to the OpenSeadragon coordinate system (of the unrotated image)
     * This is affected by window.devicePixelRatio
     * This is the inverse of {@link ImageView.CoordinateConversion.convertPointFromImageToCanvas}
     */
    imageView.CoordinateConversion.convertPointFromCanvasToImage = function(point, viewer) {
        var scale = viewer.drawer.context.canvas.width/viewer.viewport.getBoundsNoRotate(true).width;
        scale /= window.devicePixelRatio;
        
        var aspectRatio = viewer.source.width/viewer.source.height;
        var rotation = viewer.viewport.getRotation();
        var imageTopLeft_fromImageCenter = new OpenSeadragon.Point(0.5, 0.5/aspectRatio).times(-1);
        var canvasCenter_fromImageTopLeft = viewer.viewport.getCenter(true);
        var canvasCenter_fromCanvasTopLeft = new OpenSeadragon.Point(viewer.viewport.getBoundsNoRotate(true).width/2.0, viewer.viewport.getBoundsNoRotate(true).height/2.0);
        
        var canvasCenter_fromImageCenter = imageTopLeft_fromImageCenter.plus(canvasCenter_fromImageTopLeft);
        var canvasCenter_fromImageCenter_rotated = cc.rotate(canvasCenter_fromImageCenter, rotation, true);
        
        var imageCenter_fromCanvasTopLeft = canvasCenter_fromCanvasTopLeft.minus(canvasCenter_fromImageCenter_rotated);
        
        var point_fromCanvasTopLeft = point.times(1/scale);
        var point_fromImageCenter_rotated = point_fromCanvasTopLeft.minus(imageCenter_fromCanvasTopLeft);
        var point_fromImageTopLeft = cc.rotate(point_fromImageCenter_rotated, rotation, false).minus(imageTopLeft_fromImageCenter);

        return point_fromImageTopLeft;
    }
    
    /**
     * input parameter rect: A rectangle in the coordinate system of the plain unrotated image in OpenSeadragon coordinates
     * output: The same rectangle in rotated image in OpenSeadragon coordinates
     * 
     * Both rectangles are defined by their center and their width and height. Width and height remain constant,
     * while the center is converted into coordinates of the rotated image
     */
    imageView.CoordinateConversion.convertRectFromImageToRotatedImage = function(rect, viewer) {
        
        var rotation = viewer.viewport.getRotation();
        var sourceBounds = new OpenSeadragon.Rect(0,0,viewer.source.width, viewer.source.height);
        var sourceBounds_rotated = cc.getRotatedBounds(sourceBounds, rotation);
        var aspectRatio_unrotated = sourceBounds.width/sourceBounds.height;
        var aspectRatio_rotated = sourceBounds_rotated.width/sourceBounds_rotated.height;
        
        var imageBounds_unrotated = new OpenSeadragon.Rect(0,0, 1.0, 1/aspectRatio_unrotated); 
        var imageBounds_rotated = cc.getRotatedBounds(imageBounds_unrotated, rotation);

        
        var rect_fromTopLeft_unrotated = rect.getCenter();
        var topLeft_fromCenter_unrotated = imageBounds_unrotated.getCenter().times(-1);
        var rect_fromCenter_unrotated = topLeft_fromCenter_unrotated.plus(rect_fromTopLeft_unrotated);

        var rect_fromCenter_rotated = cc.rotate(rect_fromCenter_unrotated, rotation, true);

        
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
        var rect_fromTopLeft_rotated = rect_fromCenter_rotated.minus(topLeft_fromCenter_rotated);
        var rect_rotated = new OpenSeadragon.Rect(rect_fromTopLeft_rotated.x-rect.width/2.0, rect_fromTopLeft_rotated.y-rect.height/2.0, rect.width, rect.height);
        return rect_rotated;
    }
    
    /**
     * input parameter rect: A rectangle in OpenSeadragon coordinates as if the image was the actual image rotated by the
     * current viewport rotation
     * output: The same rectangle in the displayed (unrotated) image in OpenSeadragon coordinates
     * 
     * Both rectangles are defined by their center and their width and height. Width and height remain constant,
     * while the center is converted into coordinates of the rotated image
     */
    imageView.CoordinateConversion.convertRectFromRotatedImageToImage = function(rect, rotation, imageBounds) {

        var sourceBounds = _convertToOpenSeadragonObject(cc.getAsRect(imageBounds));
        var sourceBounds_rotated = cc.getRotatedBounds(sourceBounds, rotation);
        var aspectRatio_unrotated = sourceBounds.width/sourceBounds.height;
        var aspectRatio_rotated = sourceBounds_rotated.width/sourceBounds_rotated.height;
        
        var imageBounds_unrotated = new OpenSeadragon.Rect(0,0, 1.0, 1/aspectRatio_unrotated); 
        var imageBounds_rotated = cc.getRotatedBounds(imageBounds_unrotated, rotation);
        var topLeft_fromCenter_unrotated = imageBounds_unrotated.getCenter().times(-1);
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
        
        var rect_fromTopLeft_rotated = rect.getCenter();
        var rect_fromCenter_rotated = topLeft_fromCenter_rotated.plus(rect_fromTopLeft_rotated);

        var rect_fromCenter_unrotated = cc.rotate(rect_fromCenter_rotated, rotation, false);

        var rect_fromTopLeft_unrotated = rect_fromCenter_unrotated.minus(topLeft_fromCenter_unrotated);
        var rect_unrotated = new OpenSeadragon.Rect(rect_fromTopLeft_unrotated.x-rect.width/2.0, rect_fromTopLeft_unrotated.y-rect.height/2.0, rect.width, rect.height);
        return rect_unrotated;
    }
    
    /**
     * Converts a point in any image coordinates to the same point in the coordinate system of the bounding rectangle of the same image if it was rotated by the viewport rotation
     */
    imageView.CoordinateConversion.convertPointFromImageToRotatedImage = function(point, rotation, imageBounds) {
        
        var imageBounds_rotated = cc.getRotatedBounds(imageBounds, rotation);
        imageBounds = _convertToOpenSeadragonObject(cc.getAsRect(imageBounds));

        var topLeft_fromCenter_unrotated = imageBounds.getCenter().times(-1);
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
        
        var point_fromTopLeft_unrotated = _convertToOpenSeadragonObject(point);
        var point_fromCenter_unrotated = point_fromTopLeft_unrotated.plus(topLeft_fromCenter_unrotated);

        var point_fromCenter_rotated = point_fromCenter_unrotated.rotate(rotation);
        var point_fromTopLeft_rotated = point_fromCenter_rotated.minus(topLeft_fromCenter_rotated);
        
        return point_fromTopLeft_rotated;
    }
    
    /**
     * Converts a point in the coordinate system of the bounding rectangle of a rotated image to the coordinate system of the image itself.
     */
    imageView.CoordinateConversion.convertPointFromRotatedImageToImage = function(point, rotation, imageBounds) {

        var imageBounds_rotated = cc.getRotatedBounds(imageBounds, rotation);
        imageBounds = _convertToOpenSeadragonObject(cc.getAsRect(imageBounds));

        var topLeft_fromCenter_unrotated = imageBounds.getCenter().times(-1);
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
       
        var point_fromTopLeft_rotated = _convertToOpenSeadragonObject(point);
        var point_fromCenter_rotated = point_fromTopLeft_rotated.plus(topLeft_fromCenter_rotated);
        var point_fromCenter_unrotated = point_fromCenter_rotated.rotate(-rotation);
        var point_fromTopLeft_unrotated = point_fromCenter_unrotated.minus(topLeft_fromCenter_unrotated);

        return point_fromTopLeft_unrotated;
    }



/**
 * Rotates around the coordinate system origin in clockwise direction. If the 'anticockwise' parameter is set and is true then the rotation direction is reversed.
 * 
 */
    imageView.CoordinateConversion.rotate = function(point, degrees, antiClockwise) {

	    var rad = degrees*Math.PI/180.0;
	    
	    var x,y;
	    if(antiClockwise === true) {
	        x = point.x*Math.cos(rad) - point.y*Math.sin(rad);
	        y = point.x*Math.sin(rad) + point.y*Math.cos(rad);
	    } else {
	        x =  point.x*Math.cos(rad) + point.y*Math.sin(rad);
	        y = -point.x*Math.sin(rad) + point.y*Math.cos(rad);
	    }
	    
	    return new OpenSeadragon.Point(x,y);
    }
    
    /**
     * Calculates the bounding rectangle that just encompasses the given rectangle rotated by the given angle in degrees.
     * The given rectangle is assumed to start at coordinates 0,0; and the returned rectangle will be given in the same coordinate frame,
     * i.e. with x and y values holding the offset from the original origin point (x and y are thus always negative, width and height always
     * larger than those of the original rectangle)
     * 
     * @param rect  the rectangle to rotate. must be an object with properties height and width
     * @param degrees   the rotation angle in degrees
     * @return     An OpenSeadragon.Rect containing the rotated rectangle in the original coordinate system
     */
    imageView.CoordinateConversion.getRotatedBounds = function(rect, degrees) {
            var width = rect.width === undefined ? rect.x : rect.width;
            var height = rect.height === undefined ? rect.y : rect.height;

            var rad = degrees * Math.PI/180.0;
        
            var sint = Math.abs(Math.sin(rad));
            var cost = Math.abs(Math.cos(rad));

            var hh = (width * sint + height * cost);
            var ww = (width * cost + height * sint);
            
            var w = Math.abs(ww);
            var h = Math.abs(hh);
            
            var dw = w - width;
            var dh = h - height;
            return new OpenSeadragon.Rect(-dw/2.0, -dh/2.0, w, h);
    }
    
    /**
     * If the argument has width and height, return an object which contains width and height as x and y
     */
    imageView.CoordinateConversion.getAsDimension = function(rect) {
    		var size =  {
    			x: rect.width === undefined ? rect.x : rect.width,
    	    	y: rect.height === undefined ? rect.y : rect.height,
    		};
    		return _convertToOpenSeadragonObject(size);
    }
    
    imageView.CoordinateConversion.getAsRect = function(coords) {
		var rect =  {
			x: coords.width === undefined ? 0 : coords.x,
	    	y: coords.height === undefined ? 0 : coords.y,			
	    	width: coords.width === undefined ? coords.x : coords.width,
	    	height: coords.height === undefined ? coords.y : coords.height,
		}
		return _convertToOpenSeadragonObject(rect);
}
    
    function _convertToOpenSeadragonObject(object) {
    	if(object instanceof OpenSeadragon.Point || object instanceof OpenSeadragon.Rect) {
    		return object;
    	} else if(object.width !== undefined) {
    		return new OpenSeadragon.Rect(object.x, object.y, object.width, object.height);
    	} else {
    		return new OpenSeadragon.Point(object.x, object.y);
    	}
    }
    
    
    return imageView;
    
})(ImageView)
    
var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView) {
        throw "Image view must exist";
    }    
    
    /**
     * points must be in openSeadragon image coordinates (0 <= x <= 1 / 0 <= y <= height/width)
     */
    imageView.DataPoint = function(point, viewer, style) {
            
        // OpenSeadragon viewer
        this.viewer = viewer;
        // OpenSeadragon Points
        this.point = new OpenSeadragon.Point(point.x, point.y);
        // object containing properties borderWidth and borderColor
        this.style = style;
        this.hidden = false;
            
    };
    
    /**
     * Creates a styleobject for displaying a {@link ImageView.DataPoint}.
     * @param	pointStyle:	The style of the point itself. May be constructed by {@link ImageView.DataPoint.getPointStyle(radius, color)}. If undefined, the point will not be rendered.
     * @param	lineStyleX:	The style of the the line through the point, parallel to the x-axis. May be constructed by {@link ImageView.DataPoint.getLineStyle(width, color)}. If undefined, the line will not be rendered.
     * @param	lineStyleY:	The style of the line through the point, parallel to the y-axis. May be constructed by {@link ImageView.DataPoint.getPLineStyle(width, color)}. If undefined, the line will not be rendered.
     */
    imageView.DataPoint.getStyle = function(pointStyle, lineStyleX, lineStyleY) {
    	return {
    		point: pointStyle,
    		lineX: lineStyleX,
    		lineY: lineStyleY
    	}
    }
    
    /**
     * Creates a styleobject for displaying the point of a {@link ImageView.DataPoint).
     * @param	radius	The radius of the point in canvas coordinates
     * @param	color	The color of the point
     */
    imageView.DataPoint.getPointStyle = function(radius, color) {
    	return {
    		pointRadius: radius,
    		pointColor: color
    	}
    }
    
    /**
     * Creates a styleobject for displaying a line of a {@link ImageView.DataPoint).
     * @param	width	The width of the line in canvas coordinates
     * @param	color	The color of the line
     */
    imageView.DataPoint.getLineStyle = function(width, color) {
    	return {
    		lineWidth: width,
    		lineColor: color
    	}
    }
    
    /**
     * The rotation of the undelying OpenSeadragon Viewport
     */
    imageView.DataPoint.prototype.getRotation = function() {
        return this.viewer.viewport.getRotation();
    }
    
    /**
     * Set the position of the marker to the given x/y coordinates in OpenSeadragon coordinates.
     * If one of x and y is undefined, this position will not be set
     */
    imageView.DataPoint.prototype.setPosition = function(x, y) {
    	if(x !== undefined) {
    		this.point.x = x;
    	}
    	if(y !== undefined) {
    		this.point.y = y;
    	}
    }
    
    /**
     * Return the current position as OpenSeadragon.Point - in OpenSeadragon coordinates.
     * Note that the returned point is a clone of the actual position, so changing it will not affect the DataPoint
     */
    imageView.DataPoint.prototype.getPosition = function() {
    	return this.point.clone();
    }
    
    /**
     * Removes the point from the canvas. It will no longer be drawn until {@link this.draw()} is called on it
     */
    imageView.DataPoint.prototype.remove = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            this.viewer.forceRedraw();
        }
    }

    /**
     * Adds the point to the canvas, setting it up to be drawn every time the canvas changes
     */
    imageView.DataPoint.prototype.draw = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
        }
        _drawPoint({userData: this});
        this.eventHandler = function(event) {
        	_drawPoint(event)
        }
        this.viewer.addHandler( 'update-viewport', this.eventHandler, this );
    }
    
    /**
     * Checks if the given point is either on the datapoint itself or on one of its lines if they are drawn (i.e. associated with a style)
     * @param	point	The point to check
     * @param 	extra	The maximal distance the point may have from the data to count as a hit (in canvas coordinates)
     * @param	pointInCanvas	if true, the given point is assumed to be in canvas coordinates, otherwise in OpenSeadragon coordinates
     */
    imageView.DataPoint.prototype.contains = function(point, extra, pointInCanvas) {
    	
    	var pCanvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.point, this.viewer) : this.point;

        var dx = Math.abs(point.x-pCanvas.x);
        var dy = Math.abs(point.y-pCanvas.y);
        
        if( this.style.point && dx <= this.style.point.pointRadius + extra && dy <= this.style.point.pointRadius + extra ){
        	return true;
        } else if(dx <= extra && this.style.lineY) {
        	return true;
        } else if(dy <= extra && this.style.lineX) {
        	return true;
        } else {
        	return false;
        }
    }
    
    /**
     * Gets the {@link ImageView.DataPoint.HitArea} of the point, either the point itself ({@link ImageView.DataPoint.HitArea.POINT}),
     * the line parallel to the x-axis ({@link ImageView.DataPoint.HitArea.LINE_X}) or the line parallel to the y-axis ({@link ImageView.DataPoint.HitArea.LINE_Y}) 
     * If the point is not on any area of the DataPoint, undefined is returned
     * @param	point	The point to check
     * @param 	extra	The maximal distance the point may have from the area to be considered touching it (in canvas coordinates). The point takes precedence over the lines
     * @param	pointInCanvas	if true, the given point is assumed to be in canvas coordinates, otherwise in OpenSeadragon coordinates
     */
    imageView.DataPoint.prototype.getHitArea = function(point, extra, pointInCanvas) {
    	
    	var pCanvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.point, this.viewer) : this.point;
    	    	
    	var dx = Math.abs(point.x-pCanvas.x);
        var dy = Math.abs(point.y-pCanvas.y);
        
        if( this.style.point && dx <= this.style.point.pointRadius + extra && dy <= this.style.point.pointRadius + extra ){
        	return imageView.DataPoint.HitAreas.POINT;
        } else if(this.style.lineY && dx <= extra) {
        	return imageView.DataPoint.HitAreas.LINE_Y;
        } else if(this.style.lineX && dy <= extra) {
        	return imageView.DataPoint.HitAreas.LINE_X;
        } else {
        	return undefined;
        }
    }
    
    /**
     * temporarily hide the point, i.e. exlude it from being drawn
     */
    imageView.DataPoint.prototype.hide = function( immediate) {
        this.hidden = true;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    /**
     * show a formerly hidden point
     */
    imageView.DataPoint.prototype.show = function(immediate) {
        this.hidden = false;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    /**
     * reads a string in the form "x,y" and interprets it as the coordinates of the point (x,y).
     * Returns an object containing the points as properties x and y; 
     */
    imageView.DataPoint.convertStringToPoint = function(string) {
        var parts = string.split(",");
        if(parts && parts.length == 2) {       
        	return {
        		x : parseFloat(parts[0]),
        		y : parseFloat(parts[1])
        	}
        } else {
            throw "Cannot convert string '" + string + "' to Point";
        }
    }
    
    /**
     * Takes an an object containing the numeric properties x and y and returns it as String in the form "x,y"
     */
    imageView.DataPoint.convertPointsToString = function(point, decimalPlaces) {
        if(!decimalPlaces) {
            decimalPlaces = 0;
        }
        return point.x.toFixed(decimalPlaces) + "," +  point.y.toFixed(decimalPlaces);
    }

    imageView.DataPoint.HitAreas = {
            POINT : "point",
            LINE_Y : "lineY",
            LINE_X : 'lineX',
            isCorner: function( area ) {
                return area === this.POINT;
            },
            isEdge: function( area ) {
                return area === this.LINE_Y || area === this.LINE_X;
            },
            getCursor: function( area, style) {
            	if(area === this.POINT && style.point) {
            			return "move";
            	} else if(area === this.LINE_X && style.lineX) {
            		return "ns-resize";
            	} else if(area === this.LINE_Y && style.lineY) {
            			return "ew-resize";
            	} else {
            		return undefined;
            	}
            }
        }
    
    function _drawPoint(event) {
        var dp = event.userData;
        if(!dp.hidden) {     
            var context = dp.viewer.drawer.context;
        	var p = ImageView.CoordinateConversion.convertPointFromImageToCanvas(dp.point, dp.viewer);
        	if(dp.style.lineX) {
        		//draw line parallel to x
        		context.beginPath();
        		context.lineWidth = dp.style.lineX.lineWidth;
                context.strokeStyle = dp.style.lineX.lineColor;
                context.moveTo(0, p.y);
                context.lineTo(context.canvas.width, p.y);
            	context.stroke();
        	}
        	if(dp.style.lineY) {
        		//draw line parallel to y
        		context.beginPath();
        		context.lineWidth = dp.style.lineY.lineWidth;
                context.strokeStyle = dp.style.lineY.lineColor;
                context.moveTo(p.x, 0);
                context.lineTo(p.x, context.canvas.height);
            	context.stroke();
        	}
        	if(dp.style.point) {
        		//draw point
        		context.beginPath();
        		context.fillStyle = dp.style.point.pointColor;
        		context.lineWidth = 0;
        		context.arc(p.x, p.y, dp.style.point.pointRadius, 0, 2*Math.PI);
        		context.fill();
        	}
        }

    }

return imageView;

})( ImageView );


var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.DataPoint) {
        throw "imageView and imageView.DataPoint must be initialized first";
    }
    
    var DEFAULT_CURSOR = "default";

    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.DataPoint.Transform = function(viewer, startCondition) {
        this.viewer = viewer;
        this.startCondition = startCondition;
        this.active = true;
        this.transforming = false;
        this.currentDataPoint = null;
        this.drawArea = null;
        this.dataPoints = [];
        this.finishedObservable = new Rx.Subject();
        this.cursor = undefined;
        _addInputHook(this);
    }
    imageView.DataPoint.Transform.prototype.addDataPoint = function(dataPoint) {
        if(!this.dataPoints.includes(dataPoint)) {
            this.dataPoints.push(dataPoint);
            return true;
        }
        return false;
    }
    imageView.DataPoint.Transform.prototype.removeDataPoint = function(dataPoint) {
        if(this.dataPoints.includes(dataPoint)) {
            var index = this.dataPoints.indexOf(dataPoint);
            this.dataPoints.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.DataPoint.Transform.prototype.finishedTransforming = function() {
        return this.finishedObservable;
    }
    imageView.DataPoint.Transform.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.DataPoint.Transform.prototype.isActive = function() {
        return this.active;
    }
    imageView.DataPoint.Transform.prototype.isTransforming = function() {
        return this.transforming;
    }
    imageView.DataPoint.Transform.prototype.getContainingDataPoint = function(point) {
        for(var index in this.dataPoints) {
            var dataPoint = this.dataPoints[index];
            if(dataPoint.contains(point, _sideClickPrecision, true)) {
                return dataPoint;
            } 
        }
        return null;
    }

    
    function _addInputHook(transform) {
        var hook = transform.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, transform) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, transform) }
            }, {
                tracker: "viewer",
                handler: "releaseHandler",
                hookHandler: function(event) { _onViewerRelease(event, transform) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, transform) }
            } ]
        } );
        return hook;
    }


    function _onViewerMove( event, transform ) {
        if ( !transform.isTransforming() && transform.isActive() && transform.startCondition(event.originalEvent) ) {
            var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
            var dataPoint = transform.getContainingDataPoint(coords);
            var viewerElement = transform.viewer.element;
            if(dataPoint) {
                transform.currentDataPoint = dataPoint;
                transform.drawArea = dataPoint.getHitArea(coords, _sideClickPrecision, true);
            } else {
                transform.currentDataPoint = null;
                transform.drawArea = null;
            }
            if ( transform.drawArea ) {
            	var cursor = imageView.DataPoint.HitAreas.getCursor( transform.drawArea, dataPoint.style );
            	if(transform.cursor != cursor) {
            		transform.cursor = cursor;
            		$( viewerElement ).css( {cursor: cursor} );
            	}
            } else if(transform.cursor) {
            	transform.cursor = undefined;
            	$( viewerElement ).css( {cursor: DEFAULT_CURSOR} );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, transform ) {
        if ( transform.isActive()  && transform.startCondition(event.originalEvent)) {
            if ( transform.currentDataPoint && transform.drawArea ) {
                var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
                transform.startPoint = coords;
                transform.transforming = true;
                event.preventDefaultAction = true;
                return true;
            } else {
                transform.transforming = false;
                return false;
            }
        }
    }
    
    function _onViewerDrag( event, transform ) {
        if ( transform.isTransforming() ) {
            var newPoint = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var oldPoint = imageView.CoordinateConversion.convertPointFromImageToCanvas(transform.currentDataPoint.point, transform.viewer)
            var pNew = null;//rect.getTopLeft();
            if ( transform.drawArea === imageView.DataPoint.HitAreas.POINT ) {
            	pNew = newPoint;
            } else if ( transform.drawArea === imageView.DataPoint.HitAreas.LINE_X ) {
            	pNew = new OpenSeadragon.Point(oldPoint.x,newPoint.y);
            } else if ( transform.drawArea === imageView.DataPoint.HitAreas.LINE_Y ) {
            	pNew = new OpenSeadragon.Point(newPoint.x,oldPoint.y);
            } else {
            	pNew = oldPoint;
            }
            var pImage = imageView.CoordinateConversion.convertPointFromCanvasToImage(pNew, transform.viewer);
            transform.currentDataPoint.point = pImage;
            transform.viewer.forceRedraw();
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerRelease( event, transform ) {
        if ( transform.isActive() ) {
            if ( transform.transforming ) {
                transform.finishedObservable.onNext(transform.currentDataPoint);
            }
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, transform ) {
        if ( transform.isTransforming() ) {
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, transform ) {
        if ( transform.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    
    var drawingStyleClass = "drawing";
    var _hbAdd = 5;
    var _minDistanceToExistingRect = 0.01;
    
    var _active = false;
    var _drawing = false;
    var _overlayGroup = null;
    var _finishHook = null;
    var _viewerInputHook = null;
    var _deleteOldDrawElement = true;
    var _drawElement = null;
    var _drawPoint = null;
    
    imageView.DrawRect = function(config, image) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'osViewer.drawRect.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            var draw = this;
            this.viewerInputHook = image.viewer.addViewerInputHook( {
                hooks: [ {
                    tracker: "viewer",
                    handler: "clickHandler",
                    hookHandler: function(event) { _disableViewerEvent(event, draw) }
                // }, {
                // tracker: "viewer",
                // handler: "scrollHandler",
                // hookHandler: _disableViewerEvent
                }, {
                    tracker: "viewer",
                    handler: "dragHandler",
                    hookHandler: function(event) { _onViewerDrag(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "pressHandler",
                    hookHandler: function(event) { _onViewerPress(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "dragEndHandler",
                    hookHandler: function(event) { _onViewerDragEnd(event, draw) }
                } ]
            } );
        }
       imageView.DrawRect.prototype.startDrawing = function( overlayGroup, finishHook ) {
            this.active = true;
            this.overlayGroup = overlayGroup;
            this.finishHook = finishHook;
        }
        imageView.DrawRect.prototype.endDrawing = function( removeLastElement ) {
            this.active = false;
            this.overlayGroup = null;
            this.finishHook = null;
            if ( this.drawElement && removeLastElement ) {
                this.image.viewer.removeOverlay( this.drawElement );
            }
            else {
                $( this.drawElement ).removeClass( drawingStyleClass );
            }
        }
        imageView.DrawRect.prototype.isActive = function() {
            return this.active;
        }
        imageView.DrawRect.prototype.isDrawing = function() {
            return this.drawing;
        }
        imageView.DrawRect.prototype.removeLastDrawnElement = function() {
            if ( this.drawElement ) {
                this.image.viewer.removeOverlay( this.drawElement );
            }
        }

    function _onViewerPress( event, draw) {
        if ( draw.active ) {
            draw.drawPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            
            event.preventDefaultAction = false;
            return true;
        }
    }
    
    function _onViewerDrag( event, draw ) {
        // if(_debug) {
        // console.log("Dragging: ");
        // console.log("_active = " + _active);
        // console.log("_drawing = " + _drawing);
        // console.log("_drawPoint = " + _drawPoint);
        // }
        if ( draw.drawing ) {
            var newPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var rect = new OpenSeadragon.Rect( draw.drawPoint.x, draw.drawPoint.y, newPoint.x - draw.drawPoint.x, newPoint.y - draw.drawPoint.y );
            if ( newPoint.x < draw.drawPoint.x ) {
                rect.x = newPoint.x;
                rect.width = draw.drawPoint.x - newPoint.x;
            }
            if ( newPoint.y < draw.drawPoint.y ) {
                rect.y = newPoint.y;
                rect.height = draw.drawPoint.y - newPoint.y;
            }
            draw.image.viewer.updateOverlay( draw.drawElement, rect, 0 );
            event.preventDefaultAction = true;
            return true;
            
        }
        else if ( draw.active && draw.drawPoint ) {
            var activeOverlay = draw.image.overlays.getDrawingOverlay();
            if ( activeOverlay && draw.image.transformRect && draw.image.transformRect.isActive()
                    && draw.image.overlays.contains( activeOverlay.rect, draw.drawPoint, _minDistanceToExistingRect ) ) {
                draw.drawPoint = null;
                if ( _debug )
                    console.log( "Action overlaps active overlay" );
            }
            else {
                draw.drawing = true;
                if ( activeOverlay && _deleteOldDrawElement ) {
                    draw.image.overlays.removeOverlay( activeOverlay );
                }
                
                draw.drawElement = document.createElement( "div" );
                if ( draw.overlayGroup ) {
                    $( draw.drawElement ).addClass( draw.overlayGroup.styleClass );
                }
                $( draw.drawElement ).addClass( drawingStyleClass );
                var rect = new OpenSeadragon.Rect( draw.drawPoint.x, draw.drawPoint.y, 0, 0 );
                draw.image.viewer.addOverlay( draw.drawElement, rect, 1 );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, draw ) {
        if ( draw.drawing ) {
            draw.drawing = false;
            var newPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var rect = new OpenSeadragon.Rect( draw.drawPoint.x, draw.drawPoint.y, newPoint.x - draw.drawPoint.x, newPoint.y - draw.drawPoint.y );
            if ( newPoint.x < draw.drawPoint.x ) {
                rect.x = newPoint.x;
                rect.width = draw.drawPoint.x - newPoint.x;
            }
            if ( newPoint.y < draw.drawPoint.y ) {
                rect.y = newPoint.y;
                rect.height = draw.drawPoint.y - newPoint.y;
            }
            rect.hitBox = {
                l: rect.x - _hbAdd,
                t: rect.y - _hbAdd,
                r: rect.x + rect.width + _hbAdd,
                b: rect.y + rect.height + _hbAdd
            };
            
            var overlay = {
                type: imageView.Overlays.OverlayTypes.RECTANGLE,
                element: draw.drawElement,
                rect: rect,
                group: draw.overlayGroup.name,
            };
            draw.image.overlays.setDrawingOverlay( overlay );
            if ( draw.finishHook ) {
                draw.finishHook( overlay );
            }
            
            event.preventDefaultAction = true;
            return true;
        }
        
    }
    
    function _disableViewerEvent( event ) {
        if ( _active ) {
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function checkForRectHit( point ) {
        var i;
        for ( i = 0; i < _rects.length; i++ ) {
            var x = _rects[ i ];
            if ( point.x > x.hitBox.l && point.x < x.hitBox.r && point.y > x.hitBox.t && point.y < x.hitBox.b ) {
                var topLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + _hbAdd
                };
                var topRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + _hbAdd
                };
                var bottomRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var bottomLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var topHb = {
                    l: x.x + _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + _hbAdd
                };
                var rightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
                var bottomHb = {
                    l: x.x + _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var leftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
            }
        }
    }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView) {
        throw "Image view must exist";
    }    
    
    /**
     * points must be in openSeadragon image coordinates (0 <= x <= 1 / 0 <= y <= height/width)
     */
    imageView.Line = function(point1, point2, viewer, style) {
            
        // OpenSeadragon viewer
        this.viewer = viewer;
        // OpenSeadragon Points
        this.p1 = new OpenSeadragon.Point(point1.x, point1.y);
        this.p2 = new OpenSeadragon.Point(point2.x, point2.y);
        // object containing properties borderWidth and borderColor
        this.style = style;
        this.fixed = imageView.Line.getFixed(false);
        this.hidden = false;
            
    }
    
    /**
     * Return an object for the fixed property of ImageView.Line. 
     * The fixed property controls which of the six coordinates (two end point with two x/y coordinates each as well as the line as a whole) are allowed to change.
     * Depending on the passed argument all coordinates are set as fixed or not.
     */
    imageView.Line.getFixed = function(fixed) {
    	var object = {
    			p1: {
    				x:	fixed,
    				y: fixed
    			},
    			p2: {
    				x: fixed,
    				y: fixed
    			},
    			line : {
    				x: fixed,
    				y: fixed
    			}
    	}
    	return object;
    }
    
    imageView.Line.prototype.getRotation = function() {
        return this.viewer.viewport.getRotation();
    }
    
    imageView.Line.prototype.remove = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            this.viewer.forceRedraw();
        }
    }

    imageView.Line.prototype.draw = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
        }
        _drawLine({userData: this});
        this.eventHandler = function(event) {
        	_drawLine(event)
        }
        this.viewer.addHandler( 'update-viewport', this.eventHandler, this );
    }
    
    imageView.Line.prototype.contains = function(point, extra, pointInCanvas) {
    	
    	var p1Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p1, this.viewer) : this.p1;
    	var p2Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p2, this.viewer) : this.p2;

        return _isBetween(p1Canvas, p2Canvas, point, extra);
    }
    
    imageView.Line.prototype.getHitArea = function(point, extra, pointInCanvas) {
    	
    	var p1Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p1, this.viewer) : this.p1;
    	var p2Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p2, this.viewer) : this.p2;

    	    	
    	if(_dist(point, p1Canvas) <= extra) {
    		return imageView.Line.HitAreas.POINT_1;
    	} else if(_dist(point, p2Canvas) <= extra) {
    		return imageView.Line.HitAreas.POINT_2;
    	} else if(_isBetween(p1Canvas, p2Canvas, point, extra)) {
            return imageView.Line.HitAreas.LINE;
        } else {        	
        	return undefined;
        }
    }
    
    imageView.Line.prototype.hide = function( immediate) {
        this.hidden = true;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    imageView.Line.prototype.show = function(immediate) {
        this.hidden = false;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    /**
     * reads a string in the form "m,n,k,l" and interprets it as the coordinates of two points (m,n) and (k,l).
     * Returns an object containing the points as properties p1 and p2; 
     */
    imageView.Line.convertStringToPoints = function(string) {
        var parts = string.split(",");
        if(parts && parts.length == 4) {       
        	var p1 = new OpenSeadragon.Point(parseFloat(parts[0]), parseFloat(parts[1]));
        	var p2 = new OpenSeadragon.Point(parseFloat(parts[2]), parseFloat(parts[3]));
        	return {p1: p1, p2: p2};
        } else {
            throw "Cannot convert string '" + string + "' to Points";
        }
    }
    
    /**
     * Takes an object containing to points as properties p1 and p2 and returns it as String in the form "p1.x,p1.y,p2.x,p2.y"
     */
    imageView.Line.convertPointsToString = function(points, decimalPlaces) {
        if(!decimalPlaces) {
            decimalPlaces = 0;
        }
        return points.p1.x.toFixed(decimalPlaces) + "," +  points.p1.y.toFixed(decimalPlaces) + "," +  points.p2.x.toFixed(decimalPlaces) + "," +  points.p2.y.toFixed(decimalPlaces);
    }

    imageView.Line.HitAreas = {
            POINT_1 : "point1",
            POINT_2 : "point2",
            LINE : 'line',
            isCorner: function( area ) {
                return area === this.POINT_1 || area === this.POINT_2;
            },
            isEdge: function( area ) {
                return area === this.LINE;
            },
            getCursor: function( area, fixed) {
            	if(area === this.POINT_1) {
            		if(!fixed.p1.x && !fixed.p1.y) {
            			return "move";
            		} else if(fixed.p1.x) {
            			return "ns-resize";
            		} else if(fixed.p1.y) {
            			return "ew-resize";
            		} else {
            			return "not-allowed";
            		}
            	} else if(area === this.POINT_2) {
            		if(!fixed.p2.x && !fixed.p2.y) {
            			return "move";
            		} else if(fixed.p2.x) {
            			return "ns-resize";
            		} else if(fixed.p2.y) {
            			return "ew-resize";
            		} else {
            			return "not-allowed";
            		}
            	} else if(area === this.LINE) {
            		if(!fixed.line.x && !fixed.line.y) {
            			return "move";
            		} else if(fixed.line.x) {
            			return "ns-resize";
            		} else if(fixed.line.y) {
            			return "ew-resize";
            		} else {
            			return "not-allowed";
            		}
            	} else {
            		return undefined;
            	}
            }
        }
    
    function _drawLine(event) {
        var line = event.userData;
        if(!line.hidden) {        
            var context = line.viewer.drawer.context;
//            var center = new OpenSeadragon.Point(line.p1.x+(line.p2.x-line.p1.x)/2.0, line.p1.y+(line.p2.y-line.p1.y)/2.0);
//            var centerCanvas = ImageView.CoordinateConversion.convertPointFromImageToCanvas(center, line.viewer);
//            var p1 = {
//            		x: centerCanvas.x,
//            		y: 0
//            }
//            var p2 = {
//            		x: centerCanvas.x,
//            		y: context.canvas.height
//            }
            var p1 = ImageView.CoordinateConversion.convertPointFromImageToCanvas(line.p1, line.viewer);
            var p2 = ImageView.CoordinateConversion.convertPointFromImageToCanvas(line.p2, line.viewer);
            context.beginPath();        
            context.lineWidth = line.style.lineWidth;
            context.strokeStyle = line.style.lineColor;
            context.moveTo(p1.x, p1.y);
            context.lineTo(p2.x, p2.y);
            context.stroke();
        }
    }
    
    
    
    function _drawPoint(event) {
        var point = event.userData[0].times(window.devicePixelRatio);
        var viewer = event.userData[1];
        var color = event.userData[2];
        var radius = event.userData[3];
        var context = viewer.drawer.context;
//        console.log("draw on canvas ", viewer.drawer.context)
//        var point_canvas = ImageView.convertPointFromImageToCanvas(point, viewer);
        context.beginPath();
        if(color) {
            context.fillStyle = color;
        }
        context.arc(point.x, point.y, radius, 0, 2*Math.PI, true);
        context.fill();
    }

    
    function _isBetween( p1, p2, point, extra ) {
    	var dist = _distToSegment(point, p1, p2);
    	return dist <= extra;
    }


    function _sqr( x ) {
        return x * x
    }
    function _dist2( v, w ) {
        return _sqr( v.x - w.x ) + _sqr( v.y - w.y )
    }
    function _dist( v, w ) {
        return Math.sqrt( _dist2( v, w ) )
    }
    function _distToSegmentSquared( p, v, w ) {
        var l2 = _dist2( v, w );
        if ( l2 == 0 )
            return _dist2( p, v );
        var t = ( ( p.x - v.x ) * ( w.x - v.x ) + ( p.y - v.y ) * ( w.y - v.y ) ) / l2;
        if ( t < 0 )
            return _dist2( p, v );
        if ( t > 1 )
            return _dist2( p, w );
        return _dist2( p, {
            x: v.x + t * ( w.x - v.x ),
            y: v.y + t * ( w.y - v.y )
        } );
    }
    function _distToSegment( point, lineP1, lineP2 ) {
        return Math.sqrt( _distToSegmentSquared( point, lineP1, lineP2 ) );
    }

return imageView;

})( ImageView );


var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Line) {
        throw "imageView and imageView.Overlay must be initialized first";
    }
    
    var DEFAULT_CURSOR = "default";

    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.Line.Transform = function(viewer, style, startCondition) {

        this.viewer = viewer;
        this.style = style;
        this.startCondition = startCondition;
        this.active = true;
        this.transforming = false;
        this.currentLine = null;
        this.drawArea = null;
        this.startPoint = null;
        this.lines = [];
        this.finishedObservable = new Rx.Subject();
        this.cursor = undefined;
        this.fixed = imageView.Line.getFixed(false);
        _addInputHook(this);
    }
    imageView.Line.Transform.prototype.addLine = function(line) {
        if(!this.lines.includes(line)) {
            this.lines.push(line);
            return true;
        }
        return false;
    }
    imageView.Line.Transform.prototype.removeLine = function(line) {
        if(this.lines.includes(line)) {
            var index = this.lines.indexOf(line);
            this.lines.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.Line.Transform.prototype.finishedTransforming = function() {
        return this.finishedObservable;
    }
    imageView.Line.Transform.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Line.Transform.prototype.isActive = function() {
        return this.active;
    }
    imageView.Line.Transform.prototype.isTransforming = function() {
        return this.transforming;
    }
    imageView.Line.Transform.prototype.getContainingLine = function(point) {
        for(var index in this.lines) {
            var line = this.lines[index];
            if(line.contains(point, _sideClickPrecision, true)) {
                return line;
            } 
        }
        return null;
    }

    
    function _addInputHook(transform) {
        var hook = transform.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, transform) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, transform) }
            }, {
                tracker: "viewer",
                handler: "releaseHandler",
                hookHandler: function(event) { _onViewerRelease(event, transform) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, transform) }
            } ]
        } );
        return hook;
    }


    function _onViewerMove( event, transform ) {
        if ( !transform.isTransforming() && transform.isActive() && transform.startCondition(event.originalEvent) ) {
            
            var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
            var line = transform.getContainingLine(coords);
            var viewerElement = transform.viewer.element;
            if(line) {
                transform.currentLine = line;
                transform.drawArea = line.getHitArea(coords, _sideClickPrecision, true);
            } else {
                transform.currentLine = null;
                transform.drawArea = null;
            }
            if ( transform.drawArea ) {
            	var cursor = imageView.Line.HitAreas.getCursor( transform.drawArea, line.fixed );
            	if(transform.cursor != cursor) {
            		transform.cursor = cursor;
            		$( viewerElement ).css( {cursor: cursor} );
            	}
            } else if(transform.cursor) {
            	transform.cursor = undefined;
            	$( viewerElement ).css( {cursor: DEFAULT_CURSOR} );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, transform ) {
        if ( transform.isActive()  && transform.startCondition(event.originalEvent)) {
            if ( transform.currentLine && transform.drawArea ) {
            	console.log("transform draw area ", transform.drawArea);
                var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
                transform.startPoint = coords;
                transform.transforming = true;
                event.preventDefaultAction = true;
                return true;
            } else {
                transform.transforming = false;
                return false;
            }
        }
    }
    
    function _onViewerDrag( event, transform ) {
        if ( transform.isTransforming() ) {
            var newPoint = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var p1 = imageView.CoordinateConversion.convertPointFromImageToCanvas(transform.currentLine.p1, transform.viewer)
        	var p2 = imageView.CoordinateConversion.convertPointFromImageToCanvas(transform.currentLine.p2, transform.viewer);
            var p1New = null;//rect.getTopLeft();
            var p2New = null;//rect.getBottomRight();
            if ( transform.drawArea === imageView.Line.HitAreas.POINT_1 ) {
            	var x = transform.currentLine.fixed.p1.x ? p1.x : newPoint.x;
            	var y = transform.currentLine.fixed.p1.y ? p1.y : newPoint.y;
            	p1New = new OpenSeadragon.Point(x,y);
            	p2New = p2;
            } else if ( transform.drawArea === imageView.Line.HitAreas.POINT_2 ) {
            	var x = transform.currentLine.fixed.p2.x ? p2.x : newPoint.x;
            	var y = transform.currentLine.fixed.p2.y ? p2.y : newPoint.y;
            	p1New = p1;
            	p2New = new OpenSeadragon.Point(x,y);
            } else if ( transform.drawArea === imageView.Line.HitAreas.LINE && transform.startPoint ) {
                var dx = transform.currentLine.fixed.line.x ? 0 : transform.startPoint.x - newPoint.x;
                var dy = transform.currentLine.fixed.line.y ? 0 : transform.startPoint.y - newPoint.y;
                var dist = new OpenSeadragon.Point(dx, dy);
                p1New = p1.minus(dist);
                p2New = p2.minus(dist);
                transform.startPoint = newPoint;
            } else {
            	p1New = p1;
            	p2New = p2;
            }
            var p1Image = imageView.CoordinateConversion.convertPointFromCanvasToImage(p1New, transform.viewer);
            var p2Image = imageView.CoordinateConversion.convertPointFromCanvasToImage(p2New, transform.viewer);
            transform.currentLine.p1 = p1Image;
            transform.currentLine.p2 = p2Image;
            transform.viewer.forceRedraw();
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerRelease( event, transform ) {
        if ( transform.isActive() ) {
            if ( transform.transforming ) {
                transform.finishedObservable.onNext(transform.currentLine);
            }
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, transform ) {
        if ( transform.isTransforming() ) {
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, transform ) {
        if ( transform.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    
    imageView.Measures = function( imageView ) {
        this.config = imageView.getConfig();
        this.$container = $( "#" + this.config.global.divId );
//        console.log("init measures");
        this.originalImageSize = new OpenSeadragon.Point( this.getTotalImageWidth( imageView.getImageInfo() ), this.getMaxImageHeight( imageView.getImageInfo() ) );

        this.outerCanvasSize = new OpenSeadragon.Point( this.$container.outerWidth(), this.$container.outerHeight() );
        this.innerCanvasSize = new OpenSeadragon.Point( this.$container.width(), this.$container.height() );
        // console.log("Original image size = ", this.originalImageSize);
        this.footerHeight = this.config.global.bottomMargin();
        this.rotation = imageView.viewer != null ? imageView.viewer.viewport.getRotation() : 0;
//        this.xPadding = this.outerCanvasSize.x - this.innerCanvasSize.x;
//        this.yPadding = this.outerCanvasSize.y - this.innerCanvasSize.y;
        this.innerCanvasSize.y -= this.footerHeight;
        // calculate image size as it should be displayed in relation to canvas size
        var originalSizeRotated = this.getRotatedSize(this.originalImageSize);
        if(this.config.global.adaptContainerHeight || this.fitToWidth()) {
        	//image display width is container width, height is calculated
        	var scale = this.innerCanvasSize.x/originalSizeRotated.x;
        	this.imageDisplaySize = originalSizeRotated.times(scale);
        } else if(this.config.global.adaptContainerWidth || this.fitToHeight()) {
        	var scale = this.innerCanvasSize.y/originalSizeRotated.y;
        	this.imageDisplaySize = originalSizeRotated.times(scale);
        } else {
        	console.error("No display size")
        }
//        console.log("outer canvas size", this.outerCanvasSize)
//        console.log("inner canvas size", this.innerCanvasSize)
//        console.log("imageDisplaySize", this.imageDisplaySize)

    };
    imageView.Measures.prototype.getMaxImageWidth = function( imageInfo ) {
        var width = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                width = Math.max( width, tileSource.width * correction );
            }
        }
        return width;
    };
    imageView.Measures.prototype.getMaxImageHeight = function( imageInfo ) {
        var height = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                var correction = 1;
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                height = Math.max( height, tileSource.height * correction );
            }
        }
        return height;
    };
    imageView.Measures.prototype.getTotalImageWidth = function( imageInfo ) {
        var width = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                var correction = 1;
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                width += ( tileSource.width * correction );
            }
        }
        return width;
    };
    imageView.Measures.prototype.getTotalImageHeight = function( imageInfo ) {
        var height = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                var aspectRatio
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                height += tileSource.height * correction;
            }
        }
        return height;
    };
    imageView.Measures.prototype.getImageHomeSize = function() {
    	return this.imageDisplaySize;
//        var ratio = this.rotated() ? 1 / this.ratio( this.originalImageSize ) : this.ratio( this.originalImageSize );
//        if ( this.fitToHeight() ) {
//            var height = this.innerCanvasSize.y;
//            var width = height / ratio;
//        }
//        else {
//            var width = this.innerCanvasSize.x;
//            var height = width * ratio;
//        }
//        return this.getRotatedSize( new OpenSeadragon.Point( width, height ) );
    };
    imageView.Measures.prototype.rotated = function() {
        return this.rotation % 180 !== 0;
    };
    imageView.Measures.prototype.landscape = function() {
        return this.ratio( this.originalImageSize ) < 1;
    };
    imageView.Measures.prototype.ratio = function( size ) {
        return size.y / size.x;
    };
    imageView.Measures.prototype.getRotatedSize = function( size ) {
    	var bounds = ImageView.CoordinateConversion.getRotatedBounds(size, this.rotation);
    	return ImageView.CoordinateConversion.getAsDimension(bounds);
//        return new OpenSeadragon.Point( this.rotated() ? size.y : size.x, this.rotated() ? size.x : size.y );
    };
    imageView.Measures.prototype.fitToHeight = function() {
        return !this.config.global.adaptContainerHeight && !this.config.global.adaptContainerWidth && this.ratio( this.getRotatedSize( this.originalImageSize ) ) > this.ratio( this.innerCanvasSize );
    };
    imageView.Measures.prototype.fitToWidth = function() {
        return !this.config.global.adaptContainerHeight && !this.config.global.adaptContainerWidth && this.ratio( this.getRotatedSize( this.originalImageSize ) ) < this.ratio( this.innerCanvasSize );
    };
    imageView.Measures.prototype.resizeCanvas = function() {
        // Set height of container if required
        if ( this.config.global.adaptContainerHeight ) {
            if ( _debug ) {
                console.log( "adapt container height" );
            }
            this.$container.height(this.imageDisplaySize.y + this.footerHeight );
        }
        if ( this.config.global.adaptContainerWidth ) {
            if ( _debug ) {
                console.log( "adapt container width" );
            }
            this.$container.width(this.imageDisplaySize.x);
        }
        this.outerCanvasSize = new OpenSeadragon.Point( this.$container.outerWidth(), this.$container.outerHeight() );
        this.innerCanvasSize = new OpenSeadragon.Point( this.$container.width(), this.$container.height() - this.footerHeight );
    };
    imageView.Measures.prototype.calculateExcessHeight = function() {
        var imageSize = this.getRotatedSize( this.getImageHomeSize() );
        var excessHeight = this.config.global.adaptContainerHeight || this.config.global.adaptContainerWidth || this.fitToHeight() ? 0 : 0.5 * ( this.innerCanvasSize.y - imageSize.y );
        return excessHeight;
    };
    imageView.Measures.prototype.getAspectRatio = function() {
    	return this.originalImageSize.y/this.originalImageSize.x;
    };
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Overlay) {
        throw "imageView and imageView.Overlay must be initialized first";
    }

    var _hbAdd = 5;
    var _minDistanceToExistingRect = 0.01;

    
    imageView.Draw = function(viewer, style, startCondition) {
        this.viewer = viewer;
        this.style = style;
        this.startCondition = startCondition;
        this.active = true;
        this.drawing = false;
        this.currentRect = null;
        this.startPoint = null;
        this.finishedObservable = new Rx.Subject();
        
        _addInputHook(this);
    }
    imageView.Draw.prototype.finishedDrawing = function() {
        return this.finishedObservable;
    }
    imageView.Draw.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Draw.prototype.isActive = function() {
        return this.active;
    }
    imageView.Draw.prototype.isDrawing = function() {
        return this.drawing;
    }
    /*
     * Position is in viewer element coordinates
     */
    imageView.Draw.prototype.createEmptyRectAt = function(position) {
        
        this.currentRect = new OpenSeadragon.Rect(position.x, position.y, 0,0);
        this.startPoint = position;
        _drawRect(this.currentRect, this.style, this.viewer.drawer.context);
        
    }
    imageView.Draw.prototype.updateOverlay = function(position) {
            this.viewer.forceRedraw();
            var draw = this;
            this.viewer.addOnceHandler( 'update-viewport', function( event ) {
                if(draw.isDrawing()) {
                    draw.currentRect.x = Math.min(draw.startPoint.x, position.x);
                    draw.currentRect.y = Math.min(draw.startPoint.y, position.y);
                    draw.currentRect.width = Math.abs(draw.startPoint.x-position.x);
                    draw.currentRect.height = Math.abs(draw.startPoint.y-position.y);
                    _drawRect(draw.currentRect, draw.style, draw.viewer.drawer.context);
                }
            });
    }
    
    function _drawRect(rect, style, context) {
        rect = rect.times(window.devicePixelRatio);
        context.beginPath();
        context.lineWidth = style.borderWidth;
        context.strokeStyle = style.borderColor;
        context.rect(rect.x, rect.y, rect.width, rect.height);
        context.stroke();
    }
    
    function _addInputHook(draw) {
        var hook = draw.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, draw) }
            // }, {
            // tracker: "viewer",
            // handler: "scrollHandler",
            // hookHandler: _disableViewerEvent
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, draw) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, draw) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, draw) }
            } ]
        } );
        return hook;
    }


    function _onViewerPress( event, draw) {
        if ( draw.isActive() && draw.startCondition(event.originalEvent)) {
            var position = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(window.devicePixelRatio);
            draw.createEmptyRectAt(position);
            event.preventDefaultAction = false;
            draw.drawing = true;
            return true;
        }
    }
    
    function _onViewerDrag( event, draw) {
        if ( draw.isDrawing() ) {
            var position = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(window.devicePixelRatio);
            draw.updateOverlay(position);
            event.preventDefaultAction = true;
            return true; 
        }
    }
    
    function _onViewerDragEnd( event, draw) {
        if ( draw.isDrawing() ) {
            draw.drawing = false;
            var rect = ImageView.CoordinateConversion.convertCoordinatesFromCanvasToImage(draw.currentRect, draw.viewer);
            var overlay = new ImageView.Overlay(rect, draw.viewer, draw.style);
            draw.finishedObservable.onNext(overlay);
            event.preventDefaultAction = true;
            return true;
        }
        
    }
    
    function _disableViewerEvent( event, draw) {
        if ( draw.isActive() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _rotatePoint(point, angle, center) {
        if(angle !== 0 && !angle) {
            angle = drawRect.viewer.viewport.getRotation();
        }
        if(!center) {
            center = drawRect.viewer.viewport.getCenter();
        }
        angle = angle*Math.PI/180.0;
        var rotated = {
                x : Math.cos(angle) * (point.x-center.x) - Math.sin(angle) * (point.y-center.y) + center.x,
                y : Math.sin(angle) * (point.x-center.x) + Math.cos(angle) * (point.y-center.y) + center.y
        }
        return rotated;
    }
    
    function _checkForRectHit( point ) {
        var i;
        for ( i = 0; i < _rects.length; i++ ) {
            var x = _rects[ i ];
            if ( point.x > x.hitBox.l && point.x < x.hitBox.r && point.y > x.hitBox.t && point.y < x.hitBox.b ) {
                var topLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + _hbAdd
                };
                var topRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + _hbAdd
                };
                var bottomRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var bottomLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var topHb = {
                    l: x.x + _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + _hbAdd
                };
                var rightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
                var bottomHb = {
                    l: x.x + _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var leftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
            }
        }
    }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Overlay) {
        throw "imageView and imageView.Overlay must be initialized first";
    }
    
    var DEFAULT_CURSOR = "default";
    var REMOVE_CURSOR = "not-allowed";

    var _hbAdd = 5;
    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.Remove = function(viewer, startCondition) {
        this.viewer = viewer;
        this.startCondition = startCondition;
        this.active = true;
        this.currentOverlay = null;
        this.overlays = [];
        this.finishedObservable = new Rx.Subject();
        _addInputHook(this);
    }
    imageView.Remove.prototype.addOverlay = function(overlay) {
        if(!this.overlays.includes(overlay)) {
            this.overlays.push(overlay);
            return true;
        }
        return false;
    }
    imageView.Remove.prototype.removeOverlay = function(overlay) {
        if(this.overlays.includes(overlay)) {
            var index = this.overlays.indexOf(overlay);
            this.overlays.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.Remove.prototype.finishedRemoving = function() {
        return this.finishedObservable;
    }
    imageView.Remove.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Remove.prototype.isActive = function() {
        return this.active;
    }
    imageView.Remove.prototype.getContainingOverlay = function(point) {
        for(var index in this.overlays) {
            var overlay = this.overlays[index];
            if(overlay.contains(point, _sideClickPrecision, true)) {
                return overlay;
            } 
        }
        return null;
    }

    
    function _addInputHook(remove) {
        var hook = remove.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _onViewerPress(event, remove) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, remove) }
            } ]
        } );
        return hook;
    }

    
    
    function _isInside( rect, point, extra ) {

        return point.x > rect.getTopLeft().x - extra && point.x < ( rect.x + rect.width + extra ) && point.y > rect.y - extra
                && point.y < ( rect.y + rect.height + extra );
    }

    function _onViewerMove( event, remove ) {
        if (remove.isActive() && remove.startCondition(event.originalEvent) ) {
            
            var coords = event.position;
            var overlay = remove.getContainingOverlay(coords);
            var viewerElement = remove.viewer.element;
            if(overlay) {
                remove.currentOverlay = overlay;
            } else {
                remove.currentOverlay = null;
            }
            
            if ( remove.currentOverlay ) {
                $( viewerElement ).css( {
                    cursor: REMOVE_CURSOR
                } );
            } else {
                $( viewerElement ).css( {
                    cursor: DEFAULT_CURSOR
                } );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, remove ) {
        if ( remove.isActive()  && remove.startCondition(event.originalEvent)) {
            if ( remove.currentOverlay) {
                remove.currentOverlay.remove();
                remove.finishedObservable.onNext(remove.currentOverlay);
                remove.currentOverlay = null;
                return true;
            } else {
                return false;
            }
        }
    }
    function _disableViewerEvent( event, remove ) {
        if ( remove.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Overlay) {
        throw "imageView and imageView.Overlay must be initialized first";
    }
    
    var _hbAdd = 5;
    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.Transform = function(viewer, style, startCondition) {

        this.viewer = viewer;
        this.style = style;
        this.startCondition = startCondition;
        this.active = true;
        this.transforming = false;
        this.currentOverlay = null;
        this.drawArea = null;
        this.startPoint = null;
        this.overlays = [];
        this.finishedObservable = new Rx.Subject();
        this.cursor = undefined;	//current cursor css
        _addInputHook(this);
    }
    imageView.Transform.prototype.addOverlay = function(overlay) {
        if(!this.overlays.includes(overlay)) {
            this.overlays.push(overlay);
            return true;
        }
        return false;
    }
    imageView.Transform.prototype.removeOverlay = function(overlay) {
        if(this.overlays.includes(overlay)) {
            var index = this.overlays.indexOf(overlay);
            this.overlays.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.Transform.prototype.finishedTransforming = function() {
        return this.finishedObservable;
    }
    imageView.Transform.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Transform.prototype.isActive = function() {
        return this.active;
    }
    imageView.Transform.prototype.isTransforming = function() {
        return this.transforming;
    }
    imageView.Transform.prototype.getContainingOverlay = function(point) {
        for(var index in this.overlays) {
            var overlay = this.overlays[index];
            if(overlay.contains(point, _sideClickPrecision, true)) {
                return overlay;
            } 
        }
        return null;
    }

    
    function _addInputHook(transform) {
        var hook = transform.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, transform) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, transform) }
            }, {
                tracker: "viewer",
                handler: "releaseHandler",
                hookHandler: function(event) { _onViewerRelease(event, transform) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, transform) }
            } ]
        } );
        return hook;
    }


    function _onViewerMove( event, transform ) {
        if ( !transform.isTransforming() && transform.isActive() && transform.startCondition(event.originalEvent) ) {
            
            var coords = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var overlay = transform.getContainingOverlay(coords);
            var viewerElement = transform.viewer.element;
            if(overlay) {
                transform.currentOverlay = overlay;
                transform.drawArea = overlay.getHitArea(coords, _sideClickPrecision, true);
            } else {
                transform.currentOverlay = null;
                transform.drawArea = null;
            }
            
            if ( transform.drawArea ) {
            	var cursor = imageView.Overlay.HitAreas.getCursor( transform.drawArea );
            	if(transform.cursor != cursor) {
            		transform.cursor = cursor;
            		$( viewerElement ).css( {cursor: cursor} );
            	}
            } else if(transform.cursor) {
            	transform.cursor = undefined;
            	$( viewerElement ).css( {cursor: DEFAULT_CURSOR} );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, transform ) {
        if ( transform.isActive()  && transform.startCondition(event.originalEvent)) {
            if ( transform.currentOverlay && transform.drawArea ) {
                var coords = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
                transform.startPoint = coords;
                transform.transforming = true;
                event.preventDefaultAction = true;
                return true;
            } else {
                transform.transforming = false;
                return false;
            }
        }
    }
    
    function _onViewerDrag( event, transform ) {
        if ( transform.isTransforming() ) {
            var newPoint = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var rect = imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(transform.currentOverlay.rect, transform.viewer);
            var topLeft = null;//rect.getTopLeft();
            var bottomRight = null;//rect.getBottomRight();
            // if(_debug)console.log("Draw location = " + newPoint);
            if ( transform.drawArea === imageView.Overlay.HitAreas.TOPLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.TOPRIGHT ) {
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.BOTTOMLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.BOTTOMRIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.LEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = rect.getBottomRight();
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.RIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.TOP ) {
//                var rectOrig = new OpenSeadragon.Rect(rect.x, newPoint.y, rect.width, rect.height+(rect.y-newPoint.y));
//                var rectRotated = _createOverlay(rectOrig); 
//                rect = _normalize(rectRotated);
//                rect = rectOrig;
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.BOTTOM ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.CENTER && transform.startPoint ) {
                var dx = transform.startPoint.x - newPoint.x;
                var dy = transform.startPoint.y - newPoint.y;
                rect.x -= dx;
                rect.y -= dy;
                transform.startPoint = newPoint;
            }
            
            if(topLeft && bottomRight) {
                rect = new OpenSeadragon.Rect(topLeft.x, topLeft.y, bottomRight.x-topLeft.x, bottomRight.y-topLeft.y);
            }

            transform.currentOverlay.rect = imageView.CoordinateConversion.convertCoordinatesFromCanvasToImage(rect, transform.viewer);
            transform.viewer.forceRedraw();
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _createOverlay(rect) {
        var topLeft = rect.getTopLeft();
        var bottomRight = rect.getBottomRight();
//        var topLeft = {x: Math.min(p1.x, p2.x), y : Math.min(p1.y, p2.y)};
//        var bottomRight = {x: Math.max(p1.x, p2.x),y: Math.max(p1.y, p2.y)}
//        console.log("top left ", topLeft);
//        console.log("bottom right ", bottomRight);
        var topLeftRotated = _rotatePoint(topLeft);
        var bottomRightRotated = _rotatePoint(bottomRight);
        
        var x = topLeft.x;
        var y = topLeft.y;
        var width = bottomRightRotated.x-topLeftRotated.x;
        var height = bottomRightRotated.y-topLeftRotated.y;
        
        var rectRotated = new OpenSeadragon.Rect(x,y, width, height);
        return rectRotated;
    }
    
    function _normalize(rect) {
        var p1 = rect.getTopLeft();
        var p2 = rect.getBottomRight();
        var topLeft = {x: Math.min(p1.x, p2.x), y : Math.min(p1.y, p2.y)};
        var bottomRight = {x: Math.max(p1.x, p2.x),y: Math.max(p1.y, p2.y)}
        console.log("top left ", topLeft);
        console.log("bottom right ", bottomRight);
        var norm = new OpenSeadragon.Rect(topLeft.x, topLeft.y, bottomRight.x-topLeft.x, bottomRight.y-topLeft.y);
        return norm;
    }
    
    function _onViewerRelease( event, transform ) {
        if ( transform.isActive() ) {
            if ( transform.transforming ) {
                transform.finishedObservable.onNext(transform.currentOverlay);
            }
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, transform ) {
        if ( transform.isTransforming() ) {
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, transform ) {
        if ( transform.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    var _focusStyleClass = 'focus';
    var _highlightStyleClass = 'highlight';
//    var _overlayFocusHook = null;
//    var _overlayClickHook = null;
//    var _drawingOverlay = null;
//    var _overlays = [];
    
//    var _initializedCallback = null;

    imageView.Overlays = function(config, image){
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'osViewer.overlays.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            this.overlays = [];
            var overlays = this;
            
            this.image.observables.overlayRemove.subscribe(function( event ) {
                if ( event.element ) {
                    $( event.element ).remove();
                }
            });
            if(this.config.image.highlightCoords) {
               	this.image.observables.viewerOpen.subscribe( function( data ) {
            		for ( var index=0; index<overlays.config.image.highlightCoords.length; index++) {
            			var highlightCoords = overlays.config.image.highlightCoords[ index ];
            			var imageIndex = highlightCoords.pageIndex;
            			overlays.draw( highlightCoords.name, highlightCoords.displayTooltip, imageIndex);
            		}
            		if ( overlays.initializedCallback ) {
            			overlays.initializedCallback();
            		}
            	} );
            }
        }
        imageView.Overlays.prototype.onInitialized = function( callback ) {
            var oldCallback = this.initializedCallback;
            this.initializedCallback = function() {
                if ( oldCallback ) {
                    oldCallback();
                }
                callback();
            }
        }
        imageView.Overlays.prototype.onFocus = function( hook ) {
            var tempHook = this.overlayFocusHook;
            this.overlayFocusHook = function( overlay, focus ) {
                if ( tempHook )
                    tempHook( overlay, focus );
                hook( overlay, focus );
            }
        }
        imageView.Overlays.prototype.onClick = function( hook ) {
            var tempHook = this.overlayClickHook;
            this.overlayClickHook = function( overlay ) {
                if ( tempHook )
                    tempHook( overlay );
                hook( overlay );
            }
        },
        imageView.Overlays.prototype.getOverlays = function() {
            return this.overlays.slice();
        }
        imageView.Overlays.prototype.getRects = function() {
            return this.overlays.filter( function( overlay ) {
                return overlay.type === imageView.Overlays.OverlayTypes.RECTANGLE
            } ).slice();
        }
        imageView.Overlays.prototype.getLines = function() {
            return this.overlays.filter( function( overlay ) {
                return overlay.type === imageView.Overlays.OverlayTypes.LINE
            } ).slice();
        },
        imageView.Overlays.prototype.draw = function( group, displayTitle, imageIndex ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.draw: group - ' + group );
                console.log( 'osViewer.overlays.draw: displayTitle - ' + displayTitle );
                console.log( 'osViewer.overlays.draw: imageIndex - ' + imageIndex );
            }
            
            var coordList = this.image.getHighlightCoordinates( group );
            if ( coordList ) {
                if(typeof coordList.coordinates == 'string') {
                    if(_debug) console.log("convert " + coordList + " to coordinate list");
                    coordList.coordinates = _getCoordinatesFromUrlFragment(coordList.coordinates, this.image.getOriginalImageSize());
                }
                for ( var index=0; index<coordList.coordinates.length; index++ ) {
                    var coords = coordList.coordinates[ index ];
                    var title = displayTitle && coords.length > 4 ? coords[ 4 ] : '';
                    var id = coords.length > 5 ? coords[ 5 ] : index;
                    this.createRectangle( coords[ 0 ], coords[ 1 ], coords[ 2 ] - coords[ 0 ], coords[ 3 ] - coords[ 1 ], title, id, group, imageIndex );
                }
            }
        }
        imageView.Overlays.prototype.unDraw = function( group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.unDraw: group - ' + group );
            }
            
            var newRects = [];
            this.overlays = this.overlays.filter( function( overlay ) {
                if ( overlay.group === group ) {
                    this.image.viewer.removeOverlay( overlay.element );
                    return false;
                }
                else {
                    return true;
                }
            }.bind(this) );
        }
        imageView.Overlays.prototype.highlight = function( group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.highlight: group - ' + group );
            }
            
            this.overlays.filter( function( overlay ) {
                return overlay.group === group;
            } ).forEach( function( overlay ) {
                if ( overlay.element ) {
                    overlay.element.highlight( true );
                }
            } );
            
        }
        imageView.Overlays.prototype.unHighlight = function( group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.unHighlight: group - ' + group );
            }
            
            this.overlays.filter( function( overlay ) {
                return overlay.group === group;
            } ).forEach( function( overlay ) {
                if ( overlay.element ) {
                    overlay.element.highlight( false );
                }
            } );
            
        }
        imageView.Overlays.prototype.focusBox = function( group, id ) {
            if ( _debug ) {
            	console.log( 'osViewer.overlays.highlightBox: group - ' + group );
            	console.log( 'osViewer.overlays.highlightBox: id - ' + id );
            }
            this.overlays.filter( function( overlay ) {
                return overlay.group === group;
            } ).forEach( function( overlay ) {
                if ( overlay.element ) {
                    overlay.element.focus( overlay.id === id );
                }
            } );
            
        }
        imageView.Overlays.prototype.addOverlay = function( overlay ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.addOverlay: overlay - ' + overlay );
            }
            
            this.overlays.push( overlay );
            if ( overlay.element ) {
                this.image.viewer.updateOverlay( overlay.element, overlay.rect, 0 );
            }
        }
        imageView.Overlays.prototype.removeOverlay = function( overlay ) {
            if ( overlay ) {
                if ( _debug )
                    console.log( "Removing overlay " + overlay.id );
                var index = this.overlays.indexOf( overlay );
                this.overlays.splice( index, 1 );
                if ( overlay.element ) {
                    this.image.viewer.removeOverlay( overlay.element );
                }
            }
        }
        imageView.Overlays.prototype.drawRect = function( rectangle, group, title, id ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.drawRect: rectangle - ' + rectangle );
                console.log( 'osViewer.overlays.drawRect: group - ' + group );
            }
            
            this.createRectangle( rectangle.x, rectangle.y, rectangle.width, rectangle.height, title ? title : "", id ? id : "", group );
        }
        imageView.Overlays.prototype.drawLine = function( point1, point2, group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.drawLine: point1 - ' + point1 );
                console.log( 'osViewer.overlays.drawLine: point2 - ' + point2 );
                console.log( 'osViewer.overlays.drawLine: group - ' + group );
            }
            
            this.createLine( point1.x, point1.y, point2.x, point2.y, "", "", group );
        }
        imageView.Overlays.prototype.showOverlay = function( overlay ) {
            if ( overlay && !overlay.element ) {
                _drawOverlay( overlay, this );
                if ( this.overlayFocusHook ) {
                    this.overlayFocusHook( overlay, true );
                }
            }
            
        }
        imageView.Overlays.prototype.hideOverlay = function( overlay ) {
            if ( overlay && overlay.element && this.drawingOverlay != overlay ) {
                _undrawOverlay( overlay, this );
                if ( this.overlayFocusHook ) {
                    this.overlayFocusHook( overlay, false );
                }
            }
        }
        imageView.Overlays.prototype.getOverlay = function( id, group ) {
            var overlay =  this.overlays.find( function( overlay ) {
                if ( group ) {
                    return overlay.id === id && overlay.group === group;
                }
                else {
                    return overlay.id === id
                }
            } );
// console.log("search for overlay with id = " + id);
// console.log("Found overlay ", overlay);
            return overlay;
        }
        imageView.Overlays.prototype.getCoordinates = function( overlay ) {
            if(_debug){
                console.log("getCoordinates - overlay", overlay);
            }
            if ( overlay.type === imageView.Overlays.OverlayTypes.RECTANGLE ) {
                var transformedRect = this.image.viewer.viewport.viewportToImageRectangle( overlay.rect );
                return transformedRect;
            }
            else if ( overlay.type === imageView.Overlays.OverlayTypes.LINE ) {
                var p1 = this.image.viewer.viewport.viewportToImageCoordinates( overlay.poin1 );
                var p2 = this.image.viewer.viewport.viewportToImageCoordinates( overlay.poin2 );
                return {
                    point1: p1,
                    point2: p2
                };
            }
        }
        imageView.Overlays.prototype.getDrawingOverlay = function() {
            return this.drawingOverlay;
        }
        imageView.Overlays.prototype.setDrawingOverlay = function( overlay ) {
            this.drawingOverlay = overlay;
        }
        imageView.Overlays.prototype.showHiddenOverlays = function() {
            var overlays = this;
            this.image.viewer.addViewerInputHook( {
                hooks: [ {
                    tracker: "viewer",
                    handler: "moveHandler",
                    hookHandler: function(event) { _onViewerMove(event, overlays) }
                } ]
            } );
        }
        imageView.Overlays.prototype.contains = function( rect, point, precision ) {
            if ( precision == null ) {
                precision = 0;
            }
            return _isInside( rect, point, precision );
        }
        imageView.Overlays.OverlayTypes = {
            RECTANGLE: "rectangle",
            LINE: "line"
        }
        
        imageView.Overlays.prototype.createLine = function( x1, y1, x2, y2, title, id, group ) {
            if ( _debug ) {
                console.log( '------------------------------' );
                console.log( 'Overlays _createLine: x1 - ' + x1 );
                console.log( 'Overlays _createLine: y1 - ' + y1 );
                console.log( 'Overlays _createLine: x2 - ' + x2 );
                console.log( 'Overlays _createLine: y2 - ' + y2 );
                console.log( 'Overlays _createLine: title - ' + title );
                console.log( 'Overlays _createLine: id - ' + id );
                console.log( 'Overlays _createLine: group - ' + group );
                console.log( '------------------------------' );
            }
            
            var p1 = new OpenSeadragon.Point( x1, y1 );
            var p2 = new OpenSeadragon.Point( x2, y2 );
            var length = p1.distanceTo( p2 );
            
            var angle = _calculateAngle( p1, p2 );
            var beta = ( 180 - angle ) / 2;
    // console.log( "drawing line with length = " + length + " and angle = " + angle );
            
            y1 += length / 2 * Math.sin( angle * Math.PI / 180 );
            x1 -= length / 2 * Math.sin( angle * Math.PI / 180 ) / Math.tan( beta * Math.PI / 180 );
     
            var rectangle = this.image.viewer.viewport.imageToViewportRectangle( x1, y1, length, 1 );
            var p1Viewer = this.image.viewer.viewport.imageToViewportCoordinates( p1 );
            var p2Viewer = this.image.viewer.viewport.imageToViewportCoordinates( p2 );
            var overlay = {
                type: imageView.Overlays.OerlayTypes.LINE,
                rect: rectangle,
                angle: angle,
                point1: p1Viewer,
                point2: p2Viewer,
                group: group,
                id: id,
                title: title
            };
            var overlayStyle = this.getOverlayGroup( overlay.group );
            if ( !overlayStyle.hidden ) {
                _drawOverlay( overlay, this );
            }
            this.overlays.push( overlay );
            
        }
        
        /**
         * coordinates are in original image space
         */
        imageView.Overlays.prototype.createRectangle = function( x, y, width, height, title, id, group, imageIndex ) {
            if ( _debug ) {
                console.log( '------------------------------' );
                console.log( 'Overlays _createRectangle: x - ' + x );
                console.log( 'Overlays _createRectangle: y - ' + y );
                console.log( 'Overlays _createRectangle: width - ' + width );
                console.log( 'Overlays _createRectangle: height - ' + height );
                console.log( 'Overlays _createRectangle: title - ' + title );
                console.log( 'Overlays _createRectangle: id - ' + id );
                console.log( 'Overlays _createRectangle: group - ' + group );
                console.log( 'Overlays _createRectangle: imageIndex - ' + imageIndex );
                console.log( '------------------------------' );
            }
            
            if(!imageIndex) {
                imageIndex = 0;
            }
                var tiledImage = this.image.viewer.world.getItemAt(imageIndex);
                var rectangle = tiledImage.imageToViewportRectangle( x, y, width, height );
    // console.log("Found rect ", rectangle);
    // var rectangle = osViewer.viewer.viewport.imageToViewportRectangle( x, y, width, height
    // );
                var overlay = {
                        type: imageView.Overlays.OverlayTypes.RECTANGLE,
                        rect: rectangle,
                        group: group,
                        id: id,
                        title: title
                };
                var overlayStyle = this.image.getOverlayGroup( overlay.group );
                if (overlayStyle && !overlayStyle.hidden ) {
                    _drawOverlay( overlay, this);
                }
                this.overlays.push( overlay );

            
            
        }

    
    function _undrawOverlay( overlay, overlays ) {
        overlays.image.viewer.removeOverlay( overlay.element );
        overlay.element = null;
    }
    
    function _drawOverlay( overlay, overlays ) {
        if(_debug) {
            console.log("viewImage.overlays._drawOverlay");
            console.log("overlay: ", overlay);
        }
        var element = document.createElement( "div" );
        $(element).attr("id", "overlay_" + overlay.id)
        var overlayStyle = overlays.image.getOverlayGroup( overlay.group );
        if ( overlayStyle ) {
            if(_debug)console.log("overlay style", overlayStyle);
// element.title = overlay.title;
// $( element ).attr( "data-toggle", "tooltip" );
// $( element ).attr( "data-placement", "auto top" );
            $( element ).addClass( overlayStyle.styleClass );
            
            if ( overlay.type === imageView.Overlays.OverlayTypes.LINE ) {
                _rotate( overlay.angle, element );
            }
            
            if ( overlayStyle.interactive ) {
                element.focus = function( focus ) {
                    if ( focus ) {
                        $( element ).addClass( _focusStyleClass );
                        _createTooltip(element, overlay, overlays.image);
                        
// tooltip.height(100);
// $( element ).tooltip( "show" );
                    }
                    else {
                        $( element ).removeClass( _focusStyleClass );
                        $(".tooltipp#tooltip_" + overlay.id).remove();
                    }
                    if ( overlays.overlayFocusHook ) {
                        overlays.overlayFocusHook( overlay, focus );
                    }
                };
                
                element.highlight = function( focus ) {
                    if ( focus ) {
                        $( element ).addClass( _highlightStyleClass );
                    }
                    else {
                        $( element ).removeClass( _highlightStyleClass );
                    }
                };
                
                $( element ).on( "mouseover", function() {
                    if ( _debug ) {
                        console.log( 'Overlays _drawOverlay: mouse over - ' + overlayStyle.name );
                    }
                    overlays.focusBox( overlay.group, overlay.id );
                } );
                $( element ).on( "mouseout", function() {
                    if ( _debug ) {
                        console.log( 'Overlays _drawOverlay: mouse out - ' + overlayStyle.name );
                    }
                    element.focus( false );
                } );
                $( element ).on( "click", function() {
                    if ( overlays.overlayClickHook ) {
                        overlays.overlayClickHook( overlay );
                    }
                } );
            }
            overlay.element = element;
            overlays.image.viewer.addOverlay( element, overlay.rect, 0 );
        }
    }
    
    function _createTooltip(element, overlay, image) {
    	if(overlay.title) {    		
    		var canvasTopLeft = image.sizes.$container.offset();
    		var canvasBottomRight = {
    		        left: canvasTopLeft.left + image.sizes.$container.width(),
    		        top: canvasTopLeft.top + image.sizes.$container.height()
    		}
    		
    		var top = $( element ).offset().top;
    		var left = $( element ).offset().left;
    		var bottom = top + $( element ).outerHeight();
    		var right = left + $( element ).outerWidth();

    		
    		var $tooltip = $("<div class='tooltipp'>" + overlay.title + "</div>");
    		$("body").append($tooltip);
    		var tooltipPadding = parseFloat($tooltip.css("padding-top"));
    		$tooltip.css("top", Math.max(canvasTopLeft.top + tooltipPadding, top-$tooltip.outerHeight()-tooltipPadding));
    		$tooltip.css("left", Math.max(canvasTopLeft.left + tooltipPadding, left));
    		$tooltip.attr("id", "tooltip_" + overlay.id);
    		
    		// listener for zoom
    		
    		image.observables.animation
    		.do(function() {
    			var top = Math.max($( element ).offset().top, canvasTopLeft.top);
        		var left = Math.max($( element ).offset().left, canvasTopLeft.left);
    			$tooltip.css("top", Math.max(canvasTopLeft.top + tooltipPadding, top-$tooltip.outerHeight()-tooltipPadding));
    			$tooltip.css("left", Math.max(canvasTopLeft.left + tooltipPadding, left));
    		})
    		.takeWhile(function() {
    			return $(".tooltipp").length > 0;
    		})
    		.subscribe();
    	}
    }
    
    function _rotate( angle, mapElement ) {
        if ( _debug ) {
            console.log( 'Overlays _rotate: angle - ' + angle );
            console.log( 'Overlays _rotate: mapElement - ' + mapElement );
        }
        
        if ( angle !== 0 ) {
            $( mapElement ).css( "-moz-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "-webkit-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "-ms-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "-o-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "transform", "rotate(" + angle + "deg)" );
            var sin = Math.sin( angle );
            var cos = Math.cos( angle );
            $( mapElement ).css(
                    "filter",
                    "progid:DXImageTransform.Microsoft.Matrix(M11=" + cos + ", M12=" + sin + ", M21=-" + sin + ", M22=" + cos
                            + ", sizingMethod='auto expand'" );
        }
    }
    
    function _calculateAngle( p1, p2 ) {
        if ( _debug ) {
            console.log( 'Overlays _calculateAngle: p1 - ' + p1 );
            console.log( 'Overlays _calculateAngle: p2 - ' + p2 );
        }
        
        var dx = p2.x - p1.x;
        var dy = p2.y - p1.y;
        var radians = null;
        
        if ( dx > 0 ) {
            radians = Math.atan( dy / dx );
            return radians * 180 / Math.PI;
        }
        else if ( dx < 0 ) {
            radians = Math.atan( dy / dx );
            return radians * 180 / Math.PI + 180;
        }
        else if ( dy < 0 ) {
            return 270;
        }
        else {
            return 90;
        }
    }
    
    
    function _getCoordinatesFromUrlFragment(fragment, imageSize) {
        var coordsRegex = /xywh=(percent:)?([\d\.\-\+]+,[\d\.\-\+]+,[\d\.\-\+]+,[\d\.\-\+]+)/;
        if(fragment) {
            var match;// = fragment.match(coordsRegex);
            while (match = coordsRegex.exec(fragment)) {    
                console.log("match ", match)
                var percent = match[1] != undefined;
                var coords = match[2];
                coords = coords.split(",");
                var x,y,w,h;
                if(percent) {
                    x = parseInt(coords[0])*imageSize.x/100.0;
                    y = parseInt(coords[1])*imageSize.y/100.0;
                    w = parseInt(coords[2])*imageSize.x/100.0;
                    h = parseInt(coords[3])*imageSize.y/100.0;
                } else {                
                    x = parseInt(coords[0]);
                    y = parseInt(coords[1]);
                    w = parseInt(coords[2]);
                    h = parseInt(coords[3]);
                }
                //don't exceed image bounds
                x = Math.max(Math.min(imageSize.x, x), 0);
                y = Math.max(Math.min(imageSize.y, y), 0);
                w = Math.max(Math.min(imageSize.x-x, w), 0);
                h = Math.max(Math.min(imageSize.y-y, h), 0);
                return [[x,y,x+w,y+h, "", ""]];
            }
        }
        return [];
    }
    
// function _getScaleToOriginalSize() {
// var displaySize = osViewer.viewer.world.getItemAt(0).source.dimensions.x;//
// osViewer.viewer.viewport.contentSize.x;
// return osViewer.getImageInfo().width / displaySize;
// }
//    
// function _scaleToOriginalSize( value ) {
// if ( _debug ) {
// console.log( 'Overlays _scaleToOriginalSize: value - ' + value );
// }
//        
// var displaySize = osViewer.viewer.world.getItemAt(0).source.dimensions.x;//
// osViewer.viewer.viewport.contentSize.x;
// return value / displaySize * osViewer.getImageInfo().width;
// }
//    
// function _scaleToImageSize( value ) {
// if ( _debug ) {
// console.log( 'Overlays _scaleToImageSize: value - ' + value );
// }
//        
// var displaySize = osViewer.viewer.world.getItemAt(0).source.dimensions.x;//
// osViewer.viewer.viewport.contentSize.x;
// return value * displaySize / osViewer.getImageInfo().width;
// }
    
    function _isInside( rect, point, extra ) {
        return point.x > rect.x - extra && point.x < ( rect.x + rect.width + extra ) && point.y > rect.y - extra
                && point.y < ( rect.y + rect.height + extra );
    }
    
    function _onViewerMove( event, overlays ) { 
        var position = event.position;
        var ieVersion = viewerJS.helper.detectIEVersion();
        if(ieVersion && ieVersion === 10) {
// console.log("Correct position for ie ", ieVersion);
            position.x += $(window).scrollLeft();
            position.y += $(window).scrollTop();
        }
// console.log( "viewer move ", position);
        var point = overlays.image.viewer.viewport.viewerElementToViewportCoordinates( position );
        overlays.overlays.forEach( function( o ) {
            if ( _isInside( o.rect, point, 0 ) ) {
                overlays.showOverlay( o );
            }
            else {
                overlays.hideOverlay( o );
            }
        } );
    }
    
    return imageView;
    
} )( ImageView );

ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    
    imageView.TileSourceResolver = {
        
        resolveAsJsonOrURI: function( imageInfo ) {
            var deferred = Q.defer();
            if ( this.isJson( imageInfo ) ) {
                deferred.resolve( imageInfo );
            }
            else if ( this.isStringifiedJson( imageInfo ) ) {
                deferred.resolve( JSON.parse( imageInfo ) );
            }
            else {
                deferred.resolve( imageInfo );
            }
            return deferred.promise;
            
        },
        
        resolveAsJson: function( imageInfo ) {
            var deferred = Q.defer();
            if ( this.isURI( imageInfo ) ) {
                if ( this.isJsonURI( imageInfo ) ) {
                    return this.loadJsonFromURL( imageInfo );
                }
                else {
                    deferred.reject( "Url does not lead to a json object" );
                }
            }
            else if ( typeof imageInfo === "string" ) {
                try {
                    var json = JSON.parse( imageInfo );
                    deferred.resolve( json );
                }
                catch ( error ) {
                    deferred.reject( "String does not contain valid json: " + error );
                }
            }
            else if ( typeof imageInfo === "object" ) {
                deferred.resolve( imageInfo );
            } 
            else {
                deferred.reject( "Neither a url nor a json object" );
            }
            return deferred.promise;
        },
        
        loadJsonFromURL: function( imageInfo ) {
            var deferred = Q.defer();
            if ( this.isJsonURI( imageInfo ) ) {
                OpenSeadragon.makeAjaxRequest( imageInfo,
                // success
                function( request ) {
                    try {
                        deferred.resolve( JSON.parse( request.responseText ) );
                    }
                    catch ( error ) {
                        deferred.reject( error )
                    }
                },
                // error
                function( error ) {
                    deferred.reject( error );
                } )
            }
            else {
                deferred.reject( "Not a json uri: " + imageInfo );
            }
            return deferred.promise;
        },
        
        loadIfJsonURL: function( imageInfo ) {
            return Q.promise( function( resolve, reject ) {
                if ( imageView.TileSourceResolver.isURI( imageInfo ) ) {
                    var ajaxParams = {
                        url: decodeURI( imageInfo ),
                        type: "GET",
                        dataType: "JSON",
                        async: true,
                        crossDomain: true,
                        accepts: {
                            application_json: "application/json",
                            application_jsonLd: "application/ld+json",
                            text_json: "text/json",
                            text_jsonLd: "text/ld+json",
                        }
                    }
                    Q( $.ajax( ajaxParams ) ).then( function( data ) {
                        resolve( data );
                    } ).fail( function( error ) {
                        reject( "Failed to retrieve json from " + imageInfo );
                    } );
                    setTimeout( function() {
                        reject( "Timeout after 10s" );
                    }, 10000 )
                }
                else {
                    reject( "Not a uri: " + imageInfo );
                }
            } );
        },
        
        isJsonURI: function( imageInfo ) {
            if ( this.isURI( imageInfo ) ) {
                var shortened = imageInfo.replace( /\?.*/, "" );
                if ( shortened.endsWith( "/" ) ) {
                    shortened = shortened.substring( 0, shortened.length - 1 );
                }
                return shortened.toLowerCase().endsWith( ".json" );
            }
            return false;
        },
        isURI: function( imageInfo ) {
            if ( imageInfo && typeof imageInfo === "string" ) {
                if ( imageInfo.startsWith( "http://" ) || imageInfo.startsWith( "https://" ) || imageInfo.startsWith( "file:/" ) ) {
                    return true;
                }
            }
            return false;
        },
        isStringifiedJson: function( imageInfo ) {
            if ( imageInfo && typeof imageInfo === "string" ) {
                try {
                    var json = JSON.parse( imageInfo );
                    return this.isJson( json );
                }
                catch ( error ) {
                    // no json
                    return false;
                }
            }
            return false;
            
        },
        isJson: function( imageInfo ) {
            return imageInfo && typeof imageInfo === "object";
        },
    
    }

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var DEFAULT_CURSOR = "default";
    
    var _debug = false;
    
    var _drawingStyleClass = "transforming";
    
    var _active = false;
    var _drawing = false;
    var _group = null;
    var _finishHook = null;
    var _viewerInputHook = null;
    var _hbAdd = 5;
    var _sideClickPrecision = 0.004;
    var _drawArea = "";
    var _enterPoint = null;
    
    imageView.TransformRect = function(config, image){
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'osViewer.transformRect.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            var draw = this;
            this.viewerInputHook = image.viewer.addViewerInputHook( {
                hooks: [ {
                    tracker: "viewer",
                    handler: "clickHandler",
                    hookHandler: function(event) { _disableViewerEvent(event, draw) }
                // }, {
                // tracker : "viewer",
                // handler : "scrollHandler",
                // hookHandler : _disableViewerEvent
                }, {
                    tracker: "viewer",
                    handler: "dragHandler",
                    hookHandler: function(event) { _onViewerDrag(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "pressHandler",
                    hookHandler: function(event) { _onViewerPress(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "dragEndHandler",
                    hookHandler: function(event) { _onViewerDragEnd(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "releaseHandler",
                    hookHandler: function(event) { _onViewerRelease(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "moveHandler",
                    hookHandler: function(event) { _onViewerMove(event, draw) }
                } ]
            } );
        }
    imageView.TransformRect.prototype.startDrawing = function( overlay, finishHook ) {
            if ( _debug )
                console.log( "Start drawing" );
            this.image.overlays.setDrawingOverlay( overlay );
            this.active = true;
            this.group = overlay.group;
            this.finishHook = finishHook;
            $( overlay.element ).addClass( _drawingStyleClass );
        }
    imageView.TransformRect.prototype.endDrawing = function() {
            this.drawing = false;
            this.group = null;
            this.finishHook = null;
            this.active = false;
            var drawOverlay = this.image.overlays.getDrawingOverlay();
            if ( drawOverlay != null ) {
                $( drawOverlay.element ).removeClass( _drawingStyleClass );
                $( drawOverlay.element ).css( {
                    cursor: DEFAULT_CURSOR
                } );
            }
        }
        imageView.TransformRect.prototype.isActive = function() {
            return this.active;
        }
        imageView.TransformRect.HitAreas = {
            TOP: "t",
            BOTTOM: "b",
            RIGHT: "r",
            LEFT: "l",
            TOPLEFT: "tl",
            TOPRIGHT: "tr",
            BOTTOMLEFT: "bl",
            BOTTOMRIGHT: "br",
            CENTER: "c",
            isCorner: function( area ) {
                return area === this.TOPRIGHT || area === this.TOPLEFT || area === this.BOTTOMLEFT || area === this.BOTTOMRIGHT;
            },
            isEdge: function( area ) {
                return area === this.TOP || area === this.BOTTOM || area === this.LEFT || area === this.RIGHT;
            },
            getCursor: function( area, image ) {
                var rotated = image.viewer.viewport.getRotation() % 180 === 90;
                if ( area === this.TOPLEFT || area === this.BOTTOMRIGHT ) {
                    return rotated ? "nesw-resize" : "nwse-resize";
                }
                else if ( area === this.TOPRIGHT || area === this.BOTTOMLEFT ) {
                    return rotated ? "nwse-resize" : "nesw-resize";
                }
                else if ( area === this.TOP || area === this.BOTTOM ) {
                    return rotated ? "ew-resize" : "ns-resize";
                }
                else if ( area === this.RIGHT || area === this.LEFT ) {
                    return rotated ? "ns-resize" : "ew-resize";
                }
                else if ( area === this.CENTER ) {
                    return "move";
                }
                else {
                    return DEFAULT_CURSOR;
                }
            }
        }

    function _onViewerMove( event, draw ) {
        if ( !draw.drawing && draw.active ) {
            var drawPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var overlayRect = draw.image.overlays.getDrawingOverlay().rect;
            var overlayElement = draw.image.overlays.getDrawingOverlay().element;
            var viewerElement = draw.image.viewer.element;
            var area = _findCorner( overlayRect, drawPoint, _sideClickPrecision );
            if ( !area ) {
                area = _findEdge( overlayRect, drawPoint, _sideClickPrecision );
            }
            if ( !area && draw.image.overlays.contains( overlayRect, drawPoint, 0 ) ) {
                area = imageView.TransformRect.HitAreas.CENTER;
            }
            if ( area ) {
                $( viewerElement ).css( {
                    cursor: imageView.TransformRect.HitAreas.getCursor( area, draw.image )
                } );
            }
            else {
                $( viewerElement ).css( {
                    cursor: DEFAULT_CURSOR
                } );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, draw ) {
        if ( draw.active ) {
            if ( !draw.image.overlays.getDrawingOverlay() ) {
                return false;
            }
            var overlayRect = draw.image.overlays.getDrawingOverlay().rect;
            var overlayElement = draw.image.overlays.getDrawingOverlay().element;
            var drawPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var drawArea = _findCorner( overlayRect, drawPoint, _sideClickPrecision );
            if ( !drawArea ) {
                drawArea = _findEdge( overlayRect, drawPoint, _sideClickPrecision );
            }
            if ( !drawArea && draw.image.overlays.contains( overlayRect, drawPoint, 0 ) ) {
                drawArea = imageView.TransformRect.HitAreas.CENTER;
            }
            if ( _debug )
                console.log( "draw area = " + drawArea );
            if ( drawArea ) {
                $( overlayElement ).tooltip( 'destroy' );
                draw.enterPoint = drawPoint;
            }
            draw.drawArea = drawArea;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDrag( event, draw ) {
        if ( draw.drawing ) {
            var newPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var rect = draw.image.overlays.getDrawingOverlay().rect;
            var topLeft;
            var bottomRight;
            // if(_debug)console.log("Draw location = " + newPoint);
            if ( draw.drawArea === imageView.TransformRect.HitAreas.TOPLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.TOPRIGHT ) {
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.BOTTOMLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.BOTTOMRIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.LEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = rect.getBottomRight();
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.RIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.TOP ) {
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.BOTTOM ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.CENTER && draw.enterPoint ) {
                var dx = draw.enterPoint.x - newPoint.x;
                var dy = draw.enterPoint.y - newPoint.y;
                rect.x -= dx;
                rect.y -= dy;
                draw.enterPoint = newPoint;
            }
            
            if ( topLeft && bottomRight ) {
                // if(_debug)console.log("Upper left point is " + rect.getTopLeft());
                // if(_debug)console.log("Lower right point is " + rect.getBottomRight());
                // if(_debug)console.log("Setting upper left point to " + topLeft);
                // if(_debug)console.log("Setting lower right point to " + bottomRight);
                rect.x = topLeft.x;
                rect.y = topLeft.y;
                rect.width = bottomRight.x - topLeft.x;
                rect.height = bottomRight.y - topLeft.y;
            }
            
            draw.image.viewer.updateOverlay( draw.image.overlays.getDrawingOverlay().element, rect, 0 );
            event.preventDefaultAction = true;
            return true;
        }
        else if ( draw.drawArea ) {
            draw.drawing = true;
            event.preventDefaultAction = true;
            return true;
            
        }
    }
    
    function _onViewerRelease( event, draw ) {
        if ( draw.active ) {
            if ( draw.drawing && draw.finishHook ) {
                draw.finishHook( draw.image.overlays.getDrawingOverlay() );
            }
            draw.drawing = false;
            if ( draw.image.overlays.getDrawingOverlay() ) {
                $( draw.image.overlays.getDrawingOverlay().element ).tooltip();
            }
            draw.drawArea = "";
            draw.enterPoint = null;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, draw ) {
        if ( draw.drawing ) {
            draw.drawing = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, draw ) {
        if ( draw.drawing ) {
            event.preventDefaultAction = true;
            return true;
        }
    }
    function checkForRectHit( point ) {
        var i;
        for ( i = 0; i < _rects.length; i++ ) {
            var x = _rects[ i ];
            if ( point.x > x.hitBox.l && point.x < x.hitBox.r && point.y > x.hitBox.t && point.y < x.hitBox.b ) {
                var topLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + _hbAdd
                };
                var topRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + _hbAdd
                };
                var bottomRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var bottomLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var topHb = {
                    l: x.x + _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + _hbAdd
                };
                var rightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
                var bottomHb = {
                    l: x.x + _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var leftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
            }
        }
    }
    
    /*
     * Determine the side of the rectangle rect the point lies on or closest at <=maxDist
     * distance
     */
    function _findEdge( rect, point, maxDist ) {
        var distanceToLeft = _distToSegment( point, rect.getTopLeft(), rect.getBottomLeft() );
        var distanceToBottom = _distToSegment( point, rect.getBottomLeft(), rect.getBottomRight() );
        var distanceToRight = _distToSegment( point, rect.getTopRight(), rect.getBottomRight() );
        var distanceToTop = _distToSegment( point, rect.getTopLeft(), rect.getTopRight() );
        
        var minDistance = Math.min( distanceToLeft, Math.min( distanceToRight, Math.min( distanceToTop, distanceToBottom ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToLeft === minDistance ) {
                return imageView.TransformRect.HitAreas.LEFT;
            }
            if ( distanceToRight === minDistance ) {
                return imageView.TransformRect.HitAreas.RIGHT;
            }
            if ( distanceToTop === minDistance ) {
                return imageView.TransformRect.HitAreas.TOP;
            }
            if ( distanceToBottom === minDistance ) {
                return imageView.TransformRect.HitAreas.BOTTOM;
            }
        }
        return "";
    }
    
    /*
     * Determine the cornder of the rectangle rect the point lies on or closest at
     * <=maxDist distance
     */
    function _findCorner( rect, point, maxDist ) {
        var distanceToTopLeft = _dist( point, rect.getTopLeft() );
        var distanceToBottomLeft = _dist( point, rect.getBottomLeft() );
        var distanceToTopRight = _dist( point, rect.getTopRight() );
        var distanceToBottomRight = _dist( point, rect.getBottomRight() );
        
        var minDistance = Math.min( distanceToTopLeft, Math.min( distanceToTopRight, Math.min( distanceToBottomLeft, distanceToBottomRight ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToTopLeft === minDistance ) {
                return imageView.TransformRect.HitAreas.TOPLEFT;
            }
            if ( distanceToTopRight === minDistance ) {
                return imageView.TransformRect.HitAreas.TOPRIGHT;
            }
            if ( distanceToBottomLeft === minDistance ) {
                return imageView.TransformRect.HitAreas.BOTTOMLEFT;
            }
            if ( distanceToBottomRight === minDistance ) {
                return imageView.TransformRect.HitAreas.BOTTOMRIGHT;
            }
        }
        return "";
    }
    
    function _sqr( x ) {
        return x * x
    }
    function _dist2( v, w ) {
        return _sqr( v.x - w.x ) + _sqr( v.y - w.y )
    }
    function _dist( v, w ) {
        return Math.sqrt( _dist2( v, w ) )
    }
    function _distToSegmentSquared( p, v, w ) {
        var l2 = _dist2( v, w );
        if ( l2 == 0 )
            return _dist2( p, v );
        var t = ( ( p.x - v.x ) * ( w.x - v.x ) + ( p.y - v.y ) * ( w.y - v.y ) ) / l2;
        if ( t < 0 )
            return _dist2( p, v );
        if ( t > 1 )
            return _dist2( p, w );
        return _dist2( p, {
            x: v.x + t * ( w.x - v.x ),
            y: v.y + t * ( w.y - v.y )
        } );
    }
    function _distToSegment( point, lineP1, lineP2 ) {
        return Math.sqrt( _distToSegmentSquared( point, lineP1, lineP2 ) );
    }
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    var _zoomSlider = {};
    var _defaults = {
            /**
             * The position of the zoom-slider is "dilated" by a function d(zoom) =
             * 1/sliderDilation*tan[atan(sliderDilation)*zoom] This makes the slider
             * position change slower for small zoom and faster for larger zoom The
             * function is chosen so that d(0) = 0 and d(1) = 1
             */
            sliderDilation: 12
    };
    
    imageView.ZoomSlider = function(config, image)  {    
        this.config = $.extend( true, {}, _defaults );
        $.extend( true, this.config, config.global );
        this.image = image;
    }
    
    imageView.ZoomSlider.prototype.init = function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'imageView.zoomSlider.init' );
                console.log( '##############################' );
            }
                this.addZoomSlider(this.config.zoomSlider );
                this.buttonToZoom(this.image.viewer.viewport.getHomeZoom());
                var zoom = this;
                    this.image.observables.viewerZoom.subscribe( function( event ) {
                        var scale = zoom.image.viewer.viewport.getZoom();
                        zoom.buttonToZoom( scale );
                    });
        };
        imageView.ZoomSlider.prototype.exists = function() {
            return this.$element.length && this.$button.length;
        };
        imageView.ZoomSlider.prototype.buttonToMouse = function( mousePos ) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.buttonToMouse: mousePos - ' + mousePos );
            }
            
            var offset = this.$button.width() / 2;
            var newPos = mousePos - offset;
            if ( newPos < 0 ) {
                newPos = 0;
            }
            if ( newPos + 2 * offset > this.absoluteWidth ) {
                newPos = this.absoluteWidth - 2 * offset;
            }

            this.$button.css( {
                left: newPos
            } );
            this.buttonPosition = newPos;
            var factor = ( newPos / ( this.absoluteWidth - offset * 2 ) );
            factor = 1 / this.config.sliderDilation * Math.tan( Math.atan( this.config.sliderDilation ) * factor );
            var newScale = this.image.viewer.viewport.getMinZoom() + ( this.image.viewer.viewport.getMaxZoom() - this.image.viewer.viewport.getMinZoom() ) * factor;
            
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.buttonToMouse: newScale - ' + newScale );
            }
            
            this.zoomTo( newScale );
        };
        imageView.ZoomSlider.prototype.zoomTo = function( zoomTo ) {
            if ( _debug ) {
                console.log( 'imageView.controls.myZoomTo: zoomTo - ' + zoomTo );
            }
            
            var zoomBy = parseFloat( zoomTo ) / this.image.viewer.viewport.getZoom();
            
            if ( _debug ) {
                console.log( 'imageView.controls.myZoomTo: zoomBy - ' + zoomBy );
            }
            
            this.image.viewer.viewport.zoomBy( zoomBy, this.image.viewer.viewport.getCenter( false ), true );
            this.setLabel(zoomTo);
        };
        imageView.ZoomSlider.prototype.buttonToZoom = function( scale ) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.buttonToZoom: scale - ' + scale );
                console.log( 'imageView.zoomSlider.buttonToZoom: _zoomSlider - ', _zoomSlider );
            }
            
            if ( !this.image.viewer.viewport ) {
                return;
            }

            if(this.$button) { 
                var factor = ( scale - this.image.viewer.viewport.getMinZoom() ) / ( this.image.viewer.viewport.getMaxZoom() - this.image.viewer.viewport.getMinZoom() );
                
                factor = 1 / Math.atan( this.config.sliderDilation ) * Math.atan( this.config.sliderDilation * factor );
                var newPos = factor * ( this.absoluteWidth - this.$button.width() );
                
                
                if ( Math.abs( this.image.viewer.viewport.getMaxZoom() - scale ) < 0.0000000001 ) {
                    newPos = this.absoluteWidth - this.$button.width();
                }
                
                if ( newPos < 0 ) {
                    newPos = 0;
                }
                
                this.$button.css( {
                    left: newPos
                } );
                this.buttonPosition = newPos;
            }
            this.setLabel(scale);
        },
        imageView.ZoomSlider.prototype.setLabel = function(scale) {
            if(this.$label.length && this.image.sizes) {
                var imageWidth = this.image.config.image.originalImageWidth;
                var imageViewWidth = this.image.container.width();
                scale = parseFloat(scale)/imageWidth*imageViewWidth;
                scale *= window.devicePixelRatio;
                this.$label.val((scale*100).toFixed(1));
            }
        };
        imageView.ZoomSlider.prototype.inputToZoom = function(input) {
            var imageScale = parseFloat(input);
            if(imageScale && this.image.sizes) {
                if(_debug) {
                    console.log("scale to ", input);
                }
                var imageWidth = this.image.config.image.originalImageWidth;
                var imageViewWidth = this.image.container.width();
                var scale = imageScale*imageWidth/imageViewWidth/100.0;
                scale /= window.devicePixelRatio;
                if(scale < this.image.viewer.viewport.getMinZoom()) {
                    scale = this.image.viewer.viewport.getMinZoom();
                } else if(scale > this.image.viewer.viewport.getMaxZoom()) {
                    scale = this.image.viewer.viewport.getMaxZoom();
                }
                this.zoomTo( scale );
            }
        };
        imageView.ZoomSlider.prototype.addZoomSlider = function( element ) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.addZoomSlider: element - ' + element );
            }
            
            this.buttonPosition = 0;
            this.$element = $( element );
            this.absoluteWidth = this.$element.innerWidth();
            this.mousedown = false;
            var slider = this;
            if(this.$element.length) {
                this.$button = this.$element.children( this.config.zoomSliderHandle );
                this.$element.on('mousedown', function(event) {
                    _zoomSliderMouseDown(event, slider);
                });
                this.$element.on('mousemove', function(event) {
                    _zoomSliderMouseMove(event, slider);
                });
                if(this.$button.length) {
                    this.$button.on( 'mousedown', function(event) {
                        _buttonMouseDown(event, slider);                    
                    });
                }
            }
            this.$label = $(this.config.zoomSliderLabel);
            if(this.$label.length) {
                this.$label.on("change", function(event) {
                    slider.inputToZoom(event.target.value)
                    return false;
                });
                this.$label.on("keypress", function(e) {
                    if (e.which == 13) {
                        slider.inputToZoom(e.target.value)
                        return false;
                    }
                });
            }
            $( document ).on( 'mouseup', function(event) {
                _zoomSliderMouseUp(event, slider);
            });
        };
        
        function _zoomSliderMouseUp(event, slider) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.zoomSliderMouseUp' );
            }
            
            slider.mousedown = false;
        };
        function _zoomSliderMouseMove(event, slider) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.zoomSliderMouseMove: evt - ' + event );
            }
            
            if ( !slider.mousedown ) {
                return;
            }
            var offset = slider.$element.offset();
            var hitX = event.pageX - offset.left;
            slider.buttonToMouse( hitX );
            
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.zoomSliderMouseMove: moving - ' + hitX );
            }
        };
        function _zoomSliderMouseDown(event, slider) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.zoomSliderMouseDown: evt - ' + event );
            }
            
            slider.mousedown = true;
            var offset = slider.$element.offset();
            var hitX = event.pageX - offset.left;
            slider.buttonToMouse( hitX );
        };
        function _buttonMouseDown(event, slider) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.buttonMouseDown' );
            }
            
            slider.mousedown = true;
            
            return false;
        };
    
    return imageView;
    
} )( ImageView );
