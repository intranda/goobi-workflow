/*!
 * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.
 *
 * Visit these websites for more information.
 * - http://www.intranda.com
 * - http://digiverso.com
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
//Shorter definitions for RxJs modules
if(typeof Rx === 'undefined') {  
    var Rx = rxjs;
    var RxOp = rxjs.operators;
} 

var _MIN_DESKEW_ANGLE = -44.9  //must be <45
var _MAX_DESKEW_ANGLE = 45  //must be <=45

var DEFAULT_CURSOR = "default";

var ImageView = ( function() {
    'use strict';
    var _debug = false;
    var _defaults = { 
            global: { 
                divId: "map",
                zoomSlider: ".zoom-slider",
                zoomSliderHandle: '.zoom-slider-handle',
                zoomSliderLabel: ".zoom-slider-label",
                overlayGroups: [],
                zoomSpeed: 1.25, 
                maxZoomLevel: 2,
                minZoomLevel: 1,
                allowPanning: true,
                enableMouseNavigation: true,	//false means that no mouse events are handled
                imageControlsActive: true,
                visibilityRatio: 0.1, 
                loadImageTimeout: 10 * 60 * 1000,
                maxParallelImageLoads: 2,
                adaptContainerHeight: false,
                adaptContainerWidth: false,
                fitToContainer: true,
                bottomMargin: () => 0,
                topMargin: () => 0,
                rightMargin: () => 0,
                rememberZoom: false,
                rememberRotation: false,
                panHomeOnZoomOut: true,
                showControls: false,
                useTiles: true,
                blendTime: 0.2,
                navigator: {
					show: false,
					position: "BOTTOM_LEFT"
				}
            },
            image: {
                initialRotation: 0,
                mimeType: "image/jpeg"
                }
        };
    
     var imageView =  {};
     
     /**
      * Basic constructor. Merges the given config into a copy of the default config
      */
     imageView.Image = function(config)  {     
         this.config = jQuery.extend(true, {}, _defaults);
         
         this.observables = {};
         this.observables.viewerOpen = new Rx.Subject();
         this.observables.viewportUpdate = new Rx.Subject();
         
         jQuery.extend(true, this.config, config);
         this.container = $( "#" + this.config.global.divId );
         if(_debug) {             
             console.log("initializing image view with config ", this.config);
         }

//         this.originalImageSize = {x:this.config.imageWidth, y:this.config.imageHeight};
//         this.imageViewWidth = parseFloat($('#'+this.config.div).css("width"));
//         this.imageViewHeight = parseFloat($('#'+this.config.div).css("height"));
     }
     
     /**
      * Loads the image from the config given in the constructor
      * @return a promise to be resolved once the viewer has been opened
      */
     imageView.Image.prototype.load = function() {
             if ( _debug ) {
                 console.log( '##############################' );
                 console.log( 'osViewer.init' );
                 console.log( '##############################' );
             }
             
             this.config.image.mimeType = this.config.image.mimeType.replace("jpeg","jpg");
             //create image source array
             var sources = this.config.image.tileSource;
             var promises = _loadSources(sources, this.config);
             return Promise.all(promises).then(function(tileSources) {
                 tileSources = _scaleTileSources(tileSources, this);
                 
                 var pr = this.loadFooter()
                 .then( () => true)
                 .catch( () => false)
                 .then((footerLoaded) => {
                     if(_debug) {                         
                         console.log("loaded footer ", footerLoaded);
                     }
                     if(!footerLoaded) {
                         this.config.global.bottomMargin = () => 0;
                     }
                     return this.loadImage(tileSources);
                 })
                 return pr;
             }.bind(this));
         };
         
         imageView.Image.prototype.setTileSource = function(sources) {
             var promises = _loadSources(sources, this.config);
             return Promise.all(promises).then(function(tileSources) {
                 tileSources = _scaleTileSources(tileSources, this);
                 var pr = this.viewer.open(tileSources);
                 return pr;
             }.bind(this));
         };

         
         imageView.Image.prototype.loadImage = function(tileSources) {
             
             return new Promise( (resolve, reject) => {
             
	             if ( _debug ) {
	                 console.log( 'Loading image with tilesource: ', tileSources );
	             }
	 
	             var $div = $("#" + this.config.global.divId);
	       
	             var maxZoomLevel = this.config.global.maxZoomLevel
	             if(this.config.image.originalImageWidth && $div.width() > 0) {
	                 maxZoomLevel = this.config.global.maxZoomLevel*this.config.image.originalImageWidth/$div.width();
	             }
	
	//             this.loadFooter();      
	               
	             var osConfig = {
	                     tileSources: tileSources,
	                     id: this.config.global.divId,
	                     prefixUrl: this.config.resourcePath + "/javascript/openseadragon/images/",
	                     immediateRender: false,
	                     visibilityRatio: this.config.global.visibilityRatio,
	                     sequenceMode: false,
	                     degrees: this.config.image.initialRotation ? this.config.image.initialRotation : 0,
	                     zoomPerClick: 1.0,
	                     showRotationControl: true,
	                     showNavigationControl: this.config.global.showControls,
	                     minZoomLevel: this.config.global.minZoomLevel,//Math.min(this.config.global.minZoomLevel, this.config.global.minZoomLevel*this.config.image.originalImageWidth/$div.width()),
	                     maxZoomLevel: maxZoomLevel,
	                     zoomPerScroll: this.config.global.zoomSpeed,
	                     panHorizontal: this.config.global.allowPanning,
	                     panVertical: this.config.global.allowPanning,
	                     mouseNavEnabled: this.config.global.enableMouseNavigation,
	                     homeButton: this.config.global.zoomHome,
	                     rotateLeftButton: this.config.global.rotateLeft,
	                     rotateRightButton: this.config.global.rotateRight,
	                     timeout: this.config.global.loadImageTimeout,
	                     blendTime: this.config.global.blendTime,
	                     alwaysBlend: false,
	                     imageLoaderLimit: this.config.global.maxParallelImageLoads,
	                     loadTilesWithAjax: true,
	                     showNavigator: this.config.global.navigator.show,
	                     navigatorPosition: this.config.global.navigator.position,
	                     ajaxHeaders: {
	                         "token" : this.config.global.webApiToken
	                     },
	                     viewportMargins: {
	                         top: this.config.global.topMargin(),
	                         left: 0,
	                         right: this.config.global.rightMargin(),
	                         bottom: this.config.global.bottomMargin()
	                     } 
	                 }
	             if(_debug) { 
	                 console.log("osconfig ", osConfig); 
	                 console.log("margins = ", osConfig.viewportMargins);
	             }
	             
	             this.viewer = new OpenSeadragon( osConfig );
	             let observables = _createObservables(window, this);  
	             observables.viewerOpen.subscribe(this.observables.viewerOpen);
	             observables.viewportUpdate.subscribe(this.observables.viewportUpdate);
	             this.observables = observables;
	             if(this.config.global.rotationSlider || this.config.global.rotationInput) {                 
	                 _setupRotation(this);
	             }
	             
	             var image = this;
	             this.observables.viewerOpen.subscribe(function(openevent, loadevent) {
	            	 
	            	 for ( var j=0; j< image.viewer.tileSources.length; j++) {
	                     var tileSource = tileSources[j].tileSource;
	                     //make sure again we have some values for original image size in config
	                     if(!image.config.image.originalImageWidth) {
	                         image.config.image.originalImageWidth = tileSource.width;
	                     }
	                     if(!image.config.image.originalImageHeight) {
	                         image.config.image.originalImageHeight = tileSource.height;
	                     }
	                 }
	                 resolve(image);                
	             }, function(error) {   
	                 reject(error);                
	             });                
	                 
	             // Calculate sizes if redraw is required
	             this.observables.viewerOpen.pipe(RxOp.merge(this.observables.redrawRequired))
	             .subscribe(function(event) {            
	                 if(_debug) {
	                     console.log("viewer " + event.osState + "ed with target location ", event.targetLocation);                    
	                 }
	                 image.redraw();
	             });
	
	             if(this.config.global.imageControlsActive) {
	                 if ( imageView.Controls ) {
	                     this.controls = new imageView.Controls(this.config, this);
	//                 osViewer.controls.init( _defaults );
	                 }
	                 
	                 if ( imageView.ZoomSlider ) {
	                     this.zoomSlider = new imageView.ZoomSlider(this.config, this);
	                     this.onFirstTileLoaded()
	                     .then(function() {
	                         if(image.zoomSlider) {
	                             image.zoomSlider.init();
	                         }
	                     })
	                 }
	             }
	
	             
	             if ( imageView.Overlays ) {
	                 this.overlays = new imageView.Overlays(this.config, this);
	//                 osViewer.overlays.init( _defaults );                
	             }                
	             
	             if ( imageView.DrawRect ) {
	                 this.drawRect = new imageView.DrawRect(this.config, this);
	//                 osViewer.drawRect.init();                
	             }   
	             
	             if ( imageView.TransformRect ) {        
	                 this.transformRect = new imageView.TransformRect(this.config, this);
	//                 osViewer.transformRect.init();                
	             }                
	
	             this.observables.redrawRequired.connect();    
	         });
         }

     /**
      * @return the list of observables associated with this viewer
      */
     imageView.Image.prototype.getObservables = function() {
         return this.observables;
     }
     /**
      * @return true if a footerImage exists
      */
     imageView.Image.prototype.hasFooter = function() {
         return this.footerImage != null;
     }
     /**
      * @return the config
      */
     imageView.Image.prototype.getConfig = function() {
         return this.config;
     }
     /**
      * Loads the image footer from the configured footer url
      */
     imageView.Image.prototype.loadFooter = function() {
         
		return new Promise( (resolve, reject) => {

	         if ( this.config.image.baseFooterUrl && this.config.global.bottomMargin() > 0 ) {                
	             this.footerImage = new Image();
	             this.footerImage.crossOrigin = "anonymous";
	             this.footerImage.src = this.config.image.baseFooterUrl.replace( "{width}", Math.ceil( this.container.width() ) ).replace( "{height}", Math.ceil( this.config.global.bottomMargin() ) );                
	             this.footerImage.src = this.config.image.baseFooterUrl.replace( "/full/max/", "/full/!" + Math.ceil( this.container.width() ) + "," +  Math.ceil( this.config.global.bottomMargin() ) + "/");                
	             var image = this;
	             this.footerImage.onload = function() {
	                 if ( _debug ) {
	                     console.log( "loading footer image ", image.footerImage );
	                     console.log( "Calculating image Footer size" );
	                 }
	                 _drawFooter(image);
	                 resolve(image.footerImage);
	             };
	             this.footerImage.onerror = function(error) {
	                 if(_debug) {                     
	                     console.log("Failed to load image footer ", error)
	                 }
	                 image.footerImage = undefined;
	                 reject(error);
	             }
	         } else {
	             reject("no footer to load");
	         }
         });
     }

     
     /**
      * gets the overlay group with the given name from the config
      */
     imageView.Image.prototype.getOverlayGroup = function( name ) {
         var allGroups = this.config.global.overlayGroups;
         for ( var int = 0; int < allGroups.length; int++ ) {
             var group = allGroups[ int ];
             if ( group.name === name ) {
                 return group;
             }
         }
     }
     /**
      * gets the highlighting coordinates from the config
      */
     imageView.Image.prototype.getHighlightCoordinates = function( name ) {
         var coodinatesArray = this.config.image.highlightCoords;
         if ( coodinatesArray ) {
             for ( var int = 0; int < coodinatesArray.length; int++ ) {
                 var coords = coodinatesArray[ int ];
                 if ( coords.name === name ) {
                     return coords;
                 }
             }
         }
     }
     
     imageView.Image.prototype.isOriginClean = function() {
         let context = this.getCanvasContext();
         if(context) {
             try {                 
                 context.getImageData(0,0,1,1);
                 return true;
             } catch(e) {
                 return false;
             }
         } else {
             return undefined;
         }
     }
     
     
     /**
      * return the sizes associated with this view
      */
     imageView.Image.prototype.getSizes = function() {
         return this.sizes;
     }
     /**
      * get the underlying tilesource of the viewer
      */
     imageView.Image.prototype.getImageInfo = function() {
         if(this.viewer) {
             return this.viewer.tileSources;
         }
         return null;
     }
     /**
      * close the OpenSeadragon viewer
      */
     imageView.Image.prototype.close = function() {
         if ( _debug ) {
             console.log( "Closing openSeadragon viewer" );
         }
         
         
         
         if ( this.viewer ) {
             this.viewer.destroy();
         }
     }
     /**
      * Calculates the sizes associates with this viewer
      */
     imageView.Image.prototype.redraw = function() {
//         if(this.controls) {                     
//             this.controls.setPanning( true );
//         }
         this.sizes = _calculateSizes(this);
     }
     /**
      * @return a promise resolved once the first tile is loaded
      */
     imageView.Image.prototype.onFirstTileLoaded = function() {
         
         return new Promise( (resolve,reject) => {

	         if(this.observables) {
	             this.observables.firstTileLoaded.subscribe(function(event) {
	                 resolve(event);
	             }, function(error) {
	                 reject(error)
	             });
	         } else {
	             reject("No observables defined");
	         }
         });
     }

     
     imageView.Image.prototype.getOriginalImageSize = function() {
         return new OpenSeadragon.Point(this.config.image.originalImageWidth, this.config.image.originalImageHeight);
     }
     
     imageView.Image.prototype.getRotation = function() {
    	 return this.viewer.viewport.getRotation();
     }
     
     /**
      * Scale the given point or rectangle in the original image to OpenSeadragon coordinates
      * This is the inverse of scaleToImage
      */
     imageView.Image.prototype.scaleToOpenSeadragon = function(coords) {
    	 return imageView.CoordinateConversion.scaleToOpenSeadragon(coords, this.viewer, this.getOriginalImageSize());
     }
     
     /**
      * Scale the given point or rectangle in OpenSeadragon coordinates to original image coordinates
      * This is the inverse of scaleToOpenseadragon
      */
     imageView.Image.prototype.scaleToImage = function(coords) {
    	 return imageView.CoordinateConversion.scaleToImage(coords, this.viewer, this.getOriginalImageSize());
     }
     
     imageView.Image.prototype.getTileSource = function(index) {
         if(!index) {
             index = 0;
         }
         if(this.viewer && this.viewer.tileSources && this.viewer.tileSources.length > index) {
             return this.viewer.tileSources[index].tileSource;
         } 
         if(this.viewer && this.viewer.world.getItemCount() > index) {
             return this.viewer.world.getItemAt(index).source;
         } 
     }
     
     imageView.Image.prototype.getAreaString = function(area) {
         if(area && area.x != undefined && area.y != undefined && area.width != undefined && area.height != undefined) {             
             var areaString = area.x.toFixed(0) + "," + area.y.toFixed(0) + "," + area.width.toFixed(0) + "," + area.height.toFixed(0);
             return areaString;
         } else {
             return "full";
         }
     }
     
     imageView.Image.prototype.getRegionUrl = function(rect) {
         let areaString, tileSource;
         
         if (typeof rect === 'string' || rect instanceof String) {  
             tileSource = this.getTileSource(0);
             areaString = rect;
         } else {
             let tileSourceIndex = 0;
             if(rect.x > this.getTileSource(0).width) {
                 rect.x -= this.getTileSource(0).width;
                 tileSourceIndex = 1; 
             }
             tileSource = this.getTileSource(tileSourceIndex);
             areaString = this.getAreaString(rect);
         }
         
         let imageUrl = tileSource["@id"];
         imageUrl = imageUrl + "/" + areaString + "/max/" + viewImage.getRotation() + "/default.jpg";
         return imageUrl;
     }
     
     imageView.Image.prototype.getCanvasContext = function() {
         if(this.viewer) {             
             return this.viewer.drawer.context;
         } else {
             return null;
         }
     }
     
     /**
      * @param area A OpenSeadragon.Rect of a viewport area which triggers the event
      * @param eventType one of "move", "click", "doubleClick", "drag", "press" and "release"
      * @param action the function called when the event is triggered; the event is passed as a parameter
      */
     imageView.Image.prototype.register = function(area, eventType, action) {
         if(!this.mouseTracker) {
             this.mouseTracker = new OpenSeadragon.MouseTracker({
                 moveHandler: function(event){
                     console.log("mouse move ", event);
                 },
                 pressHandler: function(event){
                     
                 },
                 releaseHandler: function(event){
                     
                 },
             });
             this.mouseTracker.eventMap = new Map();
         }
         
     }

     

     function _createObservables(window, image) {
         var observables = {};
         observables.viewerOpen = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'open', function( event ) {
                 event.osState = "open";
                 
                 if(Number.isNaN(event.eventSource.viewport.getHomeBounds().x)) {
                     return observer.error("Unknow error loading image from ", _defaults.image.tileSource);
                 } else {                    
                     var location = {};

                     location.panTo = false;

                         location.zoom = image.viewer.viewport.getHomeZoom();
                         if(image.config.image.location) {
                            location = image.config.image.location;
                            image.zoomedOut = false;
                         }
                     if(_debug) {        
                         console.log("Set location to ", location);
                     }    
                     event.targetLocation = location;
                     
                     return observer.next(event);
                 }
             } );
             image.viewer.addHandler( 'open-failed', function( event ) {
                 event.osState = "open-failed";
                 console.error("Failed to open openseadragon ");
                 return observer.error(event);
             } );
         }); 
                    
         observables.firstTileLoaded = Rx.Observable.create(function(observer) {
             image.viewer.addOnceHandler( 'tile-loaded', function( event ) {
                 event.osState = "tile-loaded";
                 return observer.next(event);
             } );
             image.viewer.addOnceHandler( 'tile-load-failed', function( event ) {
                 event.osState = "tile-load-failed";
                 console.error("Failed to load tile");
                 return observer.error(event);
             } ); 
         });
         
         observables.viewerZoom = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'zoom', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.animationComplete = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'animation-finish', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.viewportUpdate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'update-viewport', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.animation = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'animation', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.viewerRotate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'rotate', function( event ) {
                 event.osState = "rotate";
                 return observer.next(event);
             } );
         });
         observables.canvasResize = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'resize', function( event ) {
                 event.osState = "resize";
                 
                 return observer.next(event);
             } );
         });

         observables.windowResize = Rx.fromEvent(window, "resize").pipe(RxOp.map(function(event) {
             event.osState = "window resize";
             
             return event;
         }));

         observables.overlayRemove = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'remove-overlay', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.overlayUpdate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'update-overlay', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.levelUpdate = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'update-level', function( event ) {
                 return observer.next(event);
             } );
         });
         observables.close = Rx.Observable.create(function(observer) {
             image.viewer.addHandler( 'close', function( event ) {
                 return observer.next(event);
             } );
         });

         observables.redrawRequired = 
                  observables.viewerRotate.pipe(
                     RxOp.merge(observables.canvasResize.pipe(RxOp.skipUntil(observables.firstTileLoaded), RxOp.catchError(error => Rx.of(error)))),
                     RxOp.debounceTime(10),
                     RxOp.map(function(event) {
                         var location = {};
                         if(image.controls) {
                             location = image.controls.getLocation();
                             if(location.zoom === 0) {
                                 location.zoom = image.viewer.viewport.getHomeZoom();
                             }
                         }
                         location.panTo = false;
                         
                         if(event.osState === "open") {
                             location.zoom = image.viewer.viewport.getHomeZoom();
                             if(image.config.image.location) {
                                location = image.config.image.location;
                             }
                         }
                         if(_debug) {                 
                             console.log("set location to ", location);
                         }
                         event.targetLocation = location;
                         
                         return event;
                     }),
                     RxOp.publish()
                 );
         
         return observables;
     }
     
     function _drawFooter(image) {
         if ( image ) {
             _overlayFooter(image);
             image.observables.viewportUpdate.subscribe( () => {
                 _overlayFooter(image);
             });
//             image.viewer.removeHandler( 'update-viewport', _overlayFooter);
//             image.viewer.addHandler( 'update-viewport', _overlayFooter, image);
         }  
     }
     function _overlayFooter( image ) {
         if (image.viewer && image.config.global.bottomMargin() > 0 ) {
             var footerHeight = image.config.global.bottomMargin();
             var footerPos = new OpenSeadragon.Point( 0, image.container.height() - footerHeight );
             var footerSize = new OpenSeadragon.Point( image.container.width(), footerHeight );
             
             if ( !image.canvasScale ) {
                 image.canvasScale = image.viewer.drawer.context.canvas.width / image.viewer.drawer.context.canvas.clientWidth;
             }
              
             if ( image.canvasScale != 1 ) {
                 footerPos = footerPos.times( image.canvasScale );
                 footerSize = footerSize.times( image.canvasScale );
             }
             image.viewer.drawer.context.drawImage( image.footerImage, Math.floor(footerPos.x), Math.floor(footerPos.y), Math.ceil(footerSize.x), Math.ceil(footerSize.y) );
         }
     };
     
     function _setupZoomSlider(image) {
         if(ImageView.ZoomSlider) {
             var slider = new ImageView.ZoomSlider(image.config.zoom, image);
             return slider;
         }
     }
     
     

     
     function _setupRotation(image) {
                  
         //set initial rotation
         var degrees = image.config.image.initialRotation;
         var deskew = _getDeskewAngle(degrees);
         image.rotation = _getRotation(degrees);
         var config = image.config.global;
         var viewer = image.viewer;
         
         //setup deskew slider
         if(config.rotationSlider) {      
             $("#" + config.rotationSlider).on("input", (event) => {
                 var degrees = -event.target.value;
                 var deskew = _getDeskewAngle(degrees);
                 viewer.viewport.setRotation(deskew + image.rotation);
             })
             $("#" + config.rotationSlider).val(-deskew);
         }
         
         //handle rotation input
         if(config.rotationInput) {             
             $("#" + config.rotationInput).on("blur", function(event) {
            	 image.controls.rotateTo(parseFloat(event.target.value));
             });
         }
         
         image.observables.viewerRotate.subscribe( (event) => {
             var degrees = _normalizeAngle(event.degrees);
             var deskew = _getDeskewAngle(degrees);
             image.rotation = _getRotation(viewer.viewport.getRotation());
             if(config.rotationSlider) {                 
                 $("#" + config.rotationSlider).val(-deskew);
             }
             if(config.rotationInput) {                              
                 var rot = (image.rotation + deskew);
                 $("#" + config.rotationInput).val(rot.toFixed(1)).change();
             }
             
         })
     }
     
     function _normalizeAngle(degrees) {
         var norm = ((degrees%360)+360)%360;
         return norm;
     }

     /**
      * get the rotation as a value between 0 and 360 degrees and rounded to 90 degrees 
      * 
      * @param degrees
      * @return    the rotation in 90 degree multiples
      */
     function _getRotation(degrees) {
         degrees += _MAX_DESKEW_ANGLE;
         degrees /= 90;
         degrees = parseInt(degrees);
         degrees *= 90;
         return _normalizeAngle(degrees);
     }

     /**
      * get the rotation modulo 90 degrees as a value between 0 and 45 degrees or between 315 and 360 degrees
      * 
      * @param degrees
      * @return the deskew part of the rotation
      */
     function _getDeskewAngle(degrees) {
         degrees += _MAX_DESKEW_ANGLE;
         degrees = parseFloat(degrees%90);
         degrees -= _MAX_DESKEW_ANGLE;
         degrees = _normalizeAngle(degrees);
         degrees = degrees > _MAX_DESKEW_ANGLE ? degrees-360 : degrees;
        return degrees;
     }
     
     function _calculateSizes(image) {
         if ( _debug ) {
             console.log( "viewImage: calcualte sizes" );
             console.log("Home zoom = ", image.viewer.viewport.getHomeZoom());
         }

         
         var sizes = new ImageView.Measures( image );
         
         if ( image.config.global.adaptContainerHeight || image.config.global.adaptContainerWidth ) {
             sizes.resizeCanvas();
         }
         
         /*TODO: 
          * Set image margins not with openseadragon margins since they are buggy
          * try using viewport.fitBounds(...) instead
          */
//         let bounds = image.viewer.viewport.getBounds(true);
//         bounds.x = 0;
//         bounds.y = 0;
//         bounds.width = 1;
//         bounds.height = bounds.width / image.viewer.viewport.getAspectRatio();
//         if(image.getRotation() == 180) {
//             bounds.y = -0.1; //0.1 = ca. footer height in viewport coordinates
//         } else if(image.getRotation() == 90) {
//             let w = bounds.width;
//             bounds.width = bounds.height * 1.571; // 1.571 = image aspect ratio (without footer)
//             bounds.height = w * 1.571;
//         }else if(image.getRotation() == 270) {
//             let w = bounds.width;
//             bounds.x = -0.1 * 1.571
//             bounds.width = bounds.height * 1.571; // 1.571 = image aspect ratio (without footer)
//             bounds.height = w * 1.571;
//         }
//         console.log("bounds ", bounds);
//         console.log("image.viewer.viewport.getAspectRatio()", image.viewer.viewport.getAspectRatio())
//         image.viewer.viewport.fitBounds(bounds, true)
         if ( image.viewer != null && image.getSizes() ) {
             var margins = image.viewer.viewport.getMargins();
             var rotation = image.viewer.viewport.getRotation(); 
             var ratio = image.getSizes().ratio(image.getSizes().innerCanvasSize);
            if(rotation%180 == 0){                
                margins.right = image.config.global.rightMargin();
                margins.left = 0;
                margins.top = image.config.global.topMargin();
                margins.bottom = sizes.footerHeight + sizes.calculateExcessHeight();
            } else if(rotation%180 == 90){ 
                margins.right = image.config.global.rightMargin();
                margins.left = 0;
                margins.top = image.config.global.topMargin();
                margins.bottom = (sizes.footerHeight + sizes.calculateExcessHeight());
            }
             image.viewer.viewport.setMargins(margins);
         }
         
         if ( _debug ) {
             console.log( "sizes: ", sizes );
         }
         return sizes;
     };
     
     function _timeout(promise, time) {
         var deferred = new jQuery.Deferred();

         $.when(promise).done(deferred.resolve).fail(deferred.reject).progress(deferred.notify);

         setTimeout(function() {
             deferred.reject("timeout");
         }, time);

         return deferred.promise();
     }



     /**
      * Creates a tilesource object usable by the OpenSeadragon viewer from a url or json-object
      * @param source   either a url pointing to a iiif info json-object or directly to an image 
      * or a iiif info json-object, optionally as a string, or a list of image resource objects - consisting
      * each of a url, a width and a height - which act as layers of a pyramid view
      * @return a promise resolved when any urls are loaded - if no urls need to be loaded, the promise resolves immediately
      */
     function _createTileSource(source, config) {
         return new Promise( (resolve, reject) => {
	         ImageView.TileSourceResolver.resolveAsJson(source)
	         .then((imageInfo) => {                        
                 _setImageSizes(imageInfo, config.global.imageSizes);       
                 _setTileSizes(imageInfo, config.global.tileSizes);      
                 if(_debug) {                
                     console.log("adapted IIIF image info ", imageInfo);                        
                 } 
                 var tileSource;
                 if(config.global.useTiles && imageInfo.tiles && imageInfo.tiles.length > 0) {
                     imageInfo.crossOriginPolicy = "Anonymous";
                     tileSource = new OpenSeadragon.IIIFTileSource(imageInfo);
                 } else {              
                     imageInfo.crossOriginPolicy = "Anonymous";
                     tileSource  = _createPyramid(imageInfo, config);                    
                 }
                 return tileSource;                
             })
             .catch( (error) => {            
	                     if(ImageView.TileSourceResolver.isURI(source)) {
	                         if(_debug) {                    
	                         }
	                         
	                         var tileSource = new OpenSeadragon.ImageTileSource( {                    
	                             url: source,                        
	                             buildPyramid: true,                        
	                             crossOriginPolicy: false                        
	                         } );
	                         return Promise.resolve(tileSource);                    
	                     } else {                
	                         var errorMsg = "Failed to load tilesource from " + source;
	                         
	                         if(_debug) {                    
	                             console.log(errorMsg);                        
	     					 }
	                         
	                         return Promise.reject(errorMsg);
	                         
	                     }              
	         })
	         .then(function(tileSource) {       
	             resolve(tileSource);          
	         }).catch(function(errorMessage) {              
	             reject(errorMessage);          
	         });
         });
     }
     
     /**
      * creates a OpenSeadragon.LegacyTileSource (pyramid image source) from the given imageInfo object, which may either
      * be a IIIF imageInfo json-object or a list of image resource objects - consisting
      * each of a url, a width and a height
      * @param imageInfo    the image information json object, either a iiif image resource or a list of simple image resources
      * @return the tilesource usable by OpenSeadragon
      */
     function _createPyramid( imageInfo, config ) {
         if(_debug) {
             console.log("Creating legacy tilesource from imageInfo ", imageInfo);
         }
         var fileExtension = config.image.mimeType;
         fileExtension = fileExtension.replace( "image/", "" );
         fileExtension = fileExtension.replace("jpeg", "jpg").replace("tiff", "tif");
         var imageLevels = [];
         var tileSource;
         if(Array.isArray(imageInfo)) {
             imageInfo.forEach(function(level) {
                 level.mimetype = config.image.mimeType;
             });
             tileSource = new OpenSeadragon.LegacyTileSource(imageInfo);
         } else if(imageInfo.sizes) {
             imageInfo.sizes.forEach(function(size, index) {
                 if(!size.height) {
                     var ratio = imageInfo.width/imageInfo.height;
                     size.height = Math.round(size.width / ratio);
                 } else if(!size.width) {
                     var ratio = imageInfo.width/imageInfo.height;
                     size.width = Math.round(size.width * ratio);
                 }
                 if(_debug) {                    
                     console.log("Image level width = ", size.width)
                     console.log("Image level height = ", size.height)
                 }
                 var sizeParam = size.width + "," + size.height;
                 if( ( !size.width || size.width >= imageInfo.width) && (!size.height || size.height >= imageInfo.height) ) {
                     sizeParam = "max";
                 }
                 
                 var level = {
                     mimetype: config.image.mimeType,
                     url: imageInfo["@id"].replace( "/info.json", "" ) + "/full/" + sizeParam + "/0/default." + fileExtension,
                     width: imageInfo.width,
                     height: imageInfo.height,
                 };
                 
                 if(_debug) {
                     console.log("Created level ", level);
                 }
                 
                 imageLevels.push( level );
             });
             
             tileSource = new OpenSeadragon.LegacyTileSource(imageLevels);
         } else {
             tileSource = new OpenSeadragon.ImageTileSource({
                 url: imageInfo["@id"].replace( "/info.json", "" ) + "/full/full/0/default." + fileExtension,
                 crossOriginPolicy: "Anonymous",
                 buildPyramid: false
             });
         }
         tileSource["@id"] =  imageInfo["@id"] //keep original source @id to create image fragment urls later on 
         return tileSource;
     }
     
     /**
      * Inserts the given image sizes into the imageInfo object
      * @param imageInfo    the imageInfo object in which the sizes are inserted
      * @param sizes        the sizes to be inserted
      */
     function _setImageSizes(imageInfo, sizes) {
         if(sizes) {             
             if(typeof sizes == 'string') {                 
             var string = sizes.replace(/[\{\}]/, "");
             var sizes = JSON.parse(sizes);
             }
             var iiifSizes = [];
             sizes.forEach(function(size) {
                 if(size.width || size.height) {
                     iiifSizes.push(size);
                 } else {                     
                     iiifSizes.push({"width": parseInt(size), "height": parseInt(size)});
                 }
             });
             if(iiifSizes.length > 0) {              
                 imageInfo.sizes = iiifSizes;
             }
         }
     }
     /**
      * Inserts the given tiles into the imageInfo object
      * @param imageInfo    the imageInfo object in which the tiles are inserted
      * @param tiles        the tiles to be inserted
      */
     function _setTileSizes(imageInfo, tiles) {
         if(tiles) {             
             if(typeof tiles === 'string') {                 
                 var tileString = tiles.replace(/(\d+)/, '"$1"').replace("=", ":");
                 tiles = JSON.parse(tileString);
             }
             var iiifTiles = [];
             if(Array.isArray(tiles)) {
                 iiifTiles = tiles;
             } else {                 
                 Object.keys(tiles).forEach(function(size) {
                     var scaleFactors = tiles[size];
                     iiifTiles.push({"width": parseInt(size), "height": parseInt(size), "scaleFactors": scaleFactors})
                 });
             }
             if(iiifTiles.length > 0) {                 
                 imageInfo.tiles = iiifTiles;
             }
         }
     }
     
     function _loadSources(sources, config) {
         if(typeof sources === 'string' && sources.startsWith("[")) {
             if(_debug)console.log("Sources = ", sources);
             sources = JSON.parse(sources);
         } else if(!Array.isArray(sources)) {
             sources = [sources];
         }
         //create promises for loading of image sources
         var promises = [];
         for ( var i=0; i<sources.length; i++) {
             var source = sources[i];
             // returns the OpenSeadragon.TileSource if it can be created,
             // otherweise
             // rejects the promise
             var promise = _createTileSource(source, config);
             promises.push(promise); 
         }        
         return promises;
     }
     
     function _scaleTileSources(tileSources, image) {
         var minWidth = Number.MAX_VALUE;  
         var minHeight = Number.MAX_VALUE;
         var minAspectRatio = Number.MAX_VALUE;
         for ( var j=0; j<tileSources.length; j++) {
             var tileSource = tileSources[j];
             minWidth = Math.min(minWidth, tileSource.width);
             minHeight = Math.min(minHeight, tileSource.height);
             minAspectRatio = Math.min(minAspectRatio, tileSource.aspectRatio);
             //make sure we have some values for original image size in config
             if(!image.config.image.originalImageWidth) {
                 image.config.image.originalImageWidth = tileSource.width;
             }
             if(!image.config.image.originalImageHeight) {
                 image.config.image.originalImageHeight = tileSource.height;
             }
         }
         if(_debug) {      
             console.log("original image size: ",  image.config.image.originalImageWidth,  image.config.image.originalImageHeight )
             console.log("Min aspect ratio = " + minAspectRatio);                    
         }
         var x = 0;
         for ( var i=0; i<tileSources.length; i++) {
             var tileSource = tileSources[i];
             tileSources[i] = {
                     tileSource: tileSource,
                     width: tileSource.aspectRatio/minAspectRatio,
                     x : x,
                     y: 0,
                 }
             x += tileSources[i].width;
         }
         return tileSources;
     }
     
     return imageView;
})();

//browser backward compability
if(!String.prototype.startsWith) {
    String.prototype.startsWith = function(subString) {
        var start = this.substring(0,subString.length);
        return start.localeCompare(subString) === 0;
    }
}
if(!String.prototype.endsWith) {
    String.prototype.endsWith = function(subString) {
        var start = this.substring(this.length-subString.length,this.length);
        return start.localeCompare(subString) === 0;
    }
}
if(!Array.prototype.find) {
    Array.prototype.find = function(comparator) {
        for ( var int = 0; int < this.length; int++ ) {
            var element = this[int];
            if(comparator(element)) {
                return element;
            }
        }
    }
}
if(!Number.isNaN) {
    Number.isNaN = function(number) {
        return number !== number;
    }
}




var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView) {
        throw "Image view must exist";
    }    
    
    /**
     * rect must be in openSeadragon image coordinates (0 <= x <= 1 / 0 <= y <= height/width)
     */
    imageView.Overlay = function(rect, viewer, style, rotateWithImage) {
        if(viewer === undefined) {
            let config = rect;
            this.viewer = config.viewer;
            this.rect = config.rect;
            this.style = config.style;
            this.rotateWithImage = config.rotateWithImage ? true : false;
            this.fixed = config.fixed ? config.fixed : null;
            this.allowMove = config.allowMove ? true : false;
            this.element = config.element;
            this.label = config.label;
        } else {            
            // OpenSeadragon viewer
            this.viewer = viewer;
            // OpenSeadragon rect
            this.rect = rect;
            // object containing properties borderWidth and borderColor
            this.style = style;
            this.rotateWithImage = rotateWithImage ? true : false;
            this.fixed = null;
            this.allowMove = false;
        }
        
    }
    
    imageView.Overlay.prototype.getRotation = function() {
        return this.viewer.viewport.getRotation();
    }
    
    imageView.Overlay.prototype.remove = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            if(this.viewer.isOpen()) {
            	this.viewer.forceRedraw();
			}            
        }
    }

    imageView.Overlay.prototype.draw = function() {
        
        //DRAW OVERLAY AS ELEMENT
        if(this.element) {
            this.viewer.removeOverlay(this.element);
            if(!this.hidden) {
                this.viewer.addOverlay({
                    element: this.element,
                    location: this.rect,                
                });               
            }
        //DRAW OVERLAY ON CANVAS
        } else {
            if(this.eventHandler) {            
                this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            }
            _drawRect({userData: this});
            this.eventHandler = function(event) {
                _drawRect(event)
            }
            this.viewer.addHandler( 'update-viewport', this.eventHandler, this );
        }
        //DRAW LABEL ELEMENT
        if(this.label) {
            this.viewer.removeOverlay(this.label);
            if(!this.hidden) {
                let rect = this.rect.clone();
                rect.y += rect.height;
                let $svg = $(this.label).find("svg");
                $svg.attr("viewBox", "0 0 100 100");
                this.viewer.addOverlay({
                    element: this.label,
                    location: rect,                
                });                
            }
        }
        
    }
    
    imageView.Overlay.prototype.contains = function(point, extra, pointInCanvas) {
        var rect = pointInCanvas ? imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(this.rect, this.viewer) : this.rect;
        return _isInside(rect, point, extra);
    }
    
    imageView.Overlay.prototype.getHitArea = function(point, extra, pointInCanvas) {
        var rect = pointInCanvas ? imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(this.rect, this.viewer) : this.rect;
        if(_isInside(rect, point, extra)) {
            var area = _findCorner(rect, point, extra);
            if(!area) {
                area = _findEdge(rect, point, extra);
            }
            if(this.allowMove && !area && _isInside(rect, point, 0)){
                area = imageView.Overlay.HitAreas.CENTER;
            }
          //prohibit fixed areas
            if(_isFixed(area, this.fixed)) {
                return imageView.Overlay.HitAreas.FIXED;
            }
        }
        return area;
    }
    
    imageView.Overlay.prototype.hide = function( immediate) {
        this.hidden = true;
        if(this.element || this.label) {
           this.draw();
        }
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    imageView.Overlay.prototype.show = function(immediate) {
        this.hidden = false;
        if(this.element || this.label) {
            this.draw();
        }
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    imageView.Overlay.convertStringToRect = function(string) {
        var parts = string.split(",");
        if(parts && parts.length == 4) {            
            var rect = new OpenSeadragon.Rect(parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
            return rect;
        } else {
            throw "Cannot convert string '" + string + "' to Rectangle";
        }
    }
    
    imageView.Overlay.convertRectToString = function(rect, decimalPlaces) {
        if(!decimalPlaces) {
            decimalPlaces = 0;
        }
        return rect.x.toFixed(decimalPlaces) + "," +  rect.y.toFixed(decimalPlaces) + "," +  rect.width.toFixed(decimalPlaces) + "," +  rect.height.toFixed(decimalPlaces);
    }
    
    imageView.Overlay.drawPoint = function(point, viewer, color, radius) {
        _drawPoint({userData: [point, viewer, color, radius] });
    }
    
    imageView.Overlay.HitAreas = {
            TOP: "t",
            BOTTOM: "b",
            RIGHT: "r",
            LEFT: "l",
            TOPLEFT: "tl",
            TOPRIGHT: "tr",
            BOTTOMLEFT: "bl",
            BOTTOMRIGHT: "br",
            CENTER: "c",
            FIXED: "f",
            isCorner: function( area ) {
                return area === this.TOPRIGHT || area === this.TOPLEFT || area === this.BOTTOMLEFT || area === this.BOTTOMRIGHT;
            },
            isEdge: function( area ) {
                return area === this.TOP || area === this.BOTTOM || area === this.LEFT || area === this.RIGHT;
            },
            getCursor: function( area ) {
                var rotated = false;//draw.viewer.viewport.getRotation() % 180 === 90;
                if ( area === this.TOPLEFT || area === this.BOTTOMRIGHT ) {
                    return rotated ? "nesw-resize" : "nwse-resize";
                }
                else if ( area === this.TOPRIGHT || area === this.BOTTOMLEFT ) {
                    return rotated ? "nwse-resize" : "nesw-resize";
                }
                else if ( area === this.TOP || area === this.BOTTOM ) {
                    return rotated ? "ew-resize" : "ns-resize";
                }
                else if ( area === this.RIGHT || area === this.LEFT ) {
                    return rotated ? "ns-resize" : "ew-resize";
                }
                else if ( area === this.CENTER ) {
                    return "move";
                } else if( area === this.FIXED ) {
                    return "not-allowed";
                } else {
                    return undefined;
                }
            }
        }
    
    function _drawRect(event) {
        var overlay = event.userData;
        if(!overlay.hidden) {
            var context = overlay.viewer.drawer.context;
            var rect;
        	let imageRect = overlay.rect;
			if(overlay.rotateWithImage) {
				imageRect = imageRect.rotate(overlay.viewer.viewport.getRotation());
			}
            rect = ImageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(imageRect, overlay.viewer).times(window.devicePixelRatio);
			//console.log("rect", rect);
            context.beginPath();        
            context.lineWidth = overlay.style.borderWidth;
            context.strokeStyle = overlay.style.borderColor;
            context.fillStyle = overlay.style.fillColor;
            context.rect(rect.x, rect.y, rect.width, rect.height);
            context.stroke();
            if(overlay.style.fillColor && overlay.style.opacity) {
            	context.globalAlpha = overlay.style.opacity;
                context.fill(); 
                context.globalAlpha = 1;
            }
            
        }
    }
    
    
    
    function _drawPoint(event) {
        var point = event.userData[0].times(window.devicePixelRatio);
        var viewer = event.userData[1];
        var color = event.userData[2];
        var radius = event.userData[3];
        var context = viewer.drawer.context;
        context.beginPath();
        if(color) {
            context.fillStyle = color;
        }
        context.arc(point.x, point.y, radius, 0, 2*Math.PI, true);
        context.fill();
    }
    
    function _isInside( rect, point, extra ) {
//        console.log("point = " + point.x.toFixed(3) + "/" + point.y.toFixed(3));
//        console.log("rect ul = " + rect.getTopLeft().x.toFixed(3) + "/" + rect.getTopLeft().y.toFixed(3));
        return point.x > (rect.getTopLeft().x - extra) && point.x < ( rect.getBottomRight().x + extra ) && 
        point.y > (rect.getTopLeft().y - extra)  && point.y < ( rect.getBottomRight().y + extra );
    }

    /*
     * Determine the side of the rectangle rect the point lies on or closest at <=maxDist
     * distance
     */
    function _findEdge( rect, point, maxDist ) {
        var distanceToLeft = _distToSegment( point, rect.getTopLeft(), rect.getBottomLeft() );
        var distanceToBottom = _distToSegment( point, rect.getBottomLeft(), rect.getBottomRight() );
        var distanceToRight = _distToSegment( point, rect.getTopRight(), rect.getBottomRight() );
        var distanceToTop = _distToSegment( point, rect.getTopLeft(), rect.getTopRight() );
        
        var minDistance = Math.min( distanceToLeft, Math.min( distanceToRight, Math.min( distanceToTop, distanceToBottom ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToLeft === minDistance ) {
                return imageView.Overlay.HitAreas.LEFT;
            }
            if ( distanceToRight === minDistance ) {
                return imageView.Overlay.HitAreas.RIGHT;
            }
            if ( distanceToTop === minDistance ) {
                return imageView.Overlay.HitAreas.TOP;
            }
            if ( distanceToBottom === minDistance ) {
                return imageView.Overlay.HitAreas.BOTTOM;
            }
        }
        return "";
    }
    
    function _isFixed(area, fixed) {
        if(area && fixed) {
            switch(area) {
                case imageView.Overlay.HitAreas.TOP: 
                    return fixed.y || fixed.height;
                case imageView.Overlay.HitAreas.BOTTOM: 
                    return fixed.height;
                case imageView.Overlay.HitAreas.LEFT: 
                    return fixed.x || fixed.width;
                case imageView.Overlay.HitAreas.RIGHT: 
                    return fixed.width;
                case imageView.Overlay.HitAreas.TOPLEFT: 
                    return fixed.x || fixed.y || fixed.width || fixed.height;
                case imageView.Overlay.HitAreas.TOPRIGHT: 
                    return fixed.y || fixed.width || fixed.height;
                case imageView.Overlay.HitAreas.BOTTOMLEFT: 
                    return fixed.height || fixed.x || fixed.width;
                case imageView.Overlay.HitAreas.BOTTOMRIGHT: 
                    return fixed.width || fixed.height;
                case imageView.Overlay.HitAreas.CENTER: 
                    return fixed.y || fixed.x;
                case imageView.Overlay.HitAreas.FIXED:
                    return true;
            }
        }
        return false;
    }

    /*
     * Determine the cornder of the rectangle rect the point lies on or closest at
     * <=maxDist distance
     */
    function _findCorner( rect, point, maxDist ) {
        var distanceToTopLeft = _dist( point, rect.getTopLeft() );
        var distanceToBottomLeft = _dist( point, rect.getBottomLeft() );
        var distanceToTopRight = _dist( point, rect.getTopRight() );
        var distanceToBottomRight = _dist( point, rect.getBottomRight() );
        
        var minDistance = Math.min( distanceToTopLeft, Math.min( distanceToTopRight, Math.min( distanceToBottomLeft, distanceToBottomRight ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToTopLeft === minDistance ) {
                return imageView.Overlay.HitAreas.TOPLEFT;
            }
            if ( distanceToTopRight === minDistance ) {
                return imageView.Overlay.HitAreas.TOPRIGHT;
            }
            if ( distanceToBottomLeft === minDistance ) {
                return imageView.Overlay.HitAreas.BOTTOMLEFT;
            }
            if ( distanceToBottomRight === minDistance ) {
                return imageView.Overlay.HitAreas.BOTTOMRIGHT;
            }
        }
        return "";
    }

    function _sqr( x ) {
        return x * x
    }
    function _dist2( v, w ) {
        return _sqr( v.x - w.x ) + _sqr( v.y - w.y )
    }
    function _dist( v, w ) {
        return Math.sqrt( _dist2( v, w ) )
    }
    function _distToSegmentSquared( p, v, w ) {
        var l2 = _dist2( v, w );
        if ( l2 == 0 )
            return _dist2( p, v );
        var t = ( ( p.x - v.x ) * ( w.x - v.x ) + ( p.y - v.y ) * ( w.y - v.y ) ) / l2;
        if ( t < 0 )
            return _dist2( p, v );
        if ( t > 1 )
            return _dist2( p, w );
        return _dist2( p, {
            x: v.x + t * ( w.x - v.x ),
            y: v.y + t * ( w.y - v.y )
        } );
    }
    function _distToSegment( point, lineP1, lineP2 ) {
        return Math.sqrt( _distToSegmentSquared( point, lineP1, lineP2 ) );
    }



    


    
return imageView;

})( ImageView );
 

var ImageView = ( function( imageView ) {
    imageView.ColorIterator = function(colors) {
        
        if(Array.isArray(colors)) {
            this.index = 0;
            this.colors = colors;
            this.next = function() {
                let color = this.colors[this.index];
                this.index = (this.index < this.colors.length-1) ? this.index+1 : 0;
                return color;
            }
        } else if(_isFunction(colors)){
            this.next = colors;
        } else {
            throw "No valid constructor parameter. Must be either an array or a function";
        }
        
    }
    
    imageView.ColorIterator.randomColor = function() {
        return '#'+Math.floor(Math.random()*16777215).toString(16);

    }
    
    function _isFunction(functionToCheck) {
        return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
       }
    
    return imageView;
     
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
//    var _currentZoom;
//    var _zoomedOut = true;
//    var _panning = false;
//    var _fadeout = null;
      
    imageView.Controls = function(config, image) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'imageView.controls.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            var controls = this;
            
            if(imageView.Controls.Persistence) {
                this.persistence = new imageView.Controls.Persistence(config, image)
//                imageView.controls.persistence.init(config);
            }
            if(_debug) {                
                console.log("Setting viewer location to", config.image.location);
            }
            if(this.config.global.controls) {
                $(this.config.global.controls.rotateLeft).on("click", function() {
                    controls.rotateLeft();
                })
                $(this.config.global.controls.rotateRight).on("click", function() {
                    controls.rotateRight();
                })
                $(this.config.global.controls.reset).on("click", function() {
                    controls.reset(true);
                })
            }
            if( image.observables ) {
                // set location after viewport update
                image.observables.redrawRequired.pipe(
                    RxOp.merge(image.observables.viewerOpen),
                    RxOp.sample(image.observables.viewportUpdate))
                .subscribe(function(event) {
                    controls.setLocation(event)
                    controls.setPanning( false );
                });
                
                // zoom home if min zoom reached
                if(image.config.global.panHomeOnZoomOut) {                    
                    image.observables.viewerZoom.subscribe( function( event ) {
                        if ( _debug ) {
                            console.log( "zoom to " + image.viewer.viewport.getZoom( true ) );
                        }
                        if ( !controls.isPanning() ) {
                            var currentZoom = image.viewer.viewport.getZoom();
                            if ( currentZoom <= image.viewer.viewport.minZoomLevel ) {
//                                if ( _debug ) {
//                                    console.log( "Zoomed out: Panning home" );
//                                }
                                
                                controls.setPanning(true);
                                controls.goHome( true );
                                controls.setPanning(false);
                            }
                        }
                    } );
                    image.observables.viewerRotate.subscribe( function(event) {
                        if(_debug)console.log("rotate viewer; zoomed out: ", this.zoomedOut);
                        if(this.zoomedOut) {
//                            controls.setPanning(true);
//                            controls.goHome( true );
//                            controls.setPanning(false);
                        }
                    }.bind(this))
                }
            }
            
            image.observables.viewerZoom.subscribe( function(event) {
                var currentZoom = image.viewer.viewport.getZoom( true );
                var targetZoom = image.viewer.viewport.getZoom( false );
                var homeZoom = image.viewer.viewport.getHomeZoom();
                var minZoom = image.viewer.viewport.getMinZoom();
                if(currentZoom < targetZoom) {
                    //zoom in
                    this.zoomedOut = false;
                } else if(targetZoom === homeZoom) {
                    this.zoomedOut = true;
                }
            }.bind(this))
            
            // fade out fullscreen controls
            if ( $( '#fullscreenTemplate' ).length > 0 ) {
                $( '#fullscreenTemplate' ).on( 'mousemove', function() {  
                    controls.fullscreenControlsFadeout();
                } )
                
                $('#fullscreenMap').on('touchmove', function() {
                	controls.fullscreenControlsFadeout();
                }).on('touchend', function() {
                	controls.fullscreenControlsFadeout();
                });
            }
        }
        imageView.Controls.prototype.getLocation = function() {
            return {
                x: this.zoomedOut ? 0 : this.getCenter().x,
                y: this.zoomedOut ? 0 : this.getCenter().y,
                zoom: this.zoomedOut ? 0 : this.getZoom()/this.getCurrentRotationZooming(),
                rotation: this.getRotation(),
            }
        },
        imageView.Controls.prototype.getCenter = function() {
            if ( _debug ) {
                console.log( "image center is " + this.image.viewer.viewport.getCenter( true ) );
            }
            return this.image.viewer.viewport.getCenter( true );
        }
        imageView.Controls.prototype.setCenter = function( center ) {
            
            if ( _debug ) {
                console.log( "Setting image center to " );
                console.log( center );
            }
            
            this.image.viewer.viewport.panTo( center, true );
            
        },
        imageView.Controls.prototype.getZoom = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.getZoom' );
            }
            return this.image.viewer.viewport.getZoom( true );
        }
        imageView.Controls.prototype.zoomTo = function( zoomTo ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.myZoomTo: zoomTo - ' + zoomTo );
            }
            
            var zoomBy = parseFloat( zoomTo ) / this.image.viewer.viewport.getZoom();
            
            if ( _debug ) {
                console.log( 'osViewer.controls.myZoomTo: zoomBy - ' + zoomBy );
            }
            
            this.image.viewer.viewport.zoomBy( zoomBy, this.image.viewer.viewport.getCenter( false ), true );
        }
        imageView.Controls.prototypesetFullScreen = function( enable ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.setFullScreen: enable - ' + enable );
            }
            
            this.image.viewer.setFullScreen( enable );
        }
        imageView.Controls.prototype.goHome = function( immediate ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.panHome - zoom : ' + this.image.viewer.viewport.getHomeZoom() );
            }
            this.image.viewer.viewport.goHome( immediate );
            this.zoomedOut = true;
        }
        imageView.Controls.prototype.reset = function( resetRotation ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.goHome: bool - ' + resetRotation );
            }
            
            // osViewer.viewer.viewport.goHome( true );
            this.goHome( true );
            this.image.viewer.viewport.zoomTo( this.image.viewer.viewport.getHomeZoom(), null, true );
            if ( resetRotation ) {
                this.rotateTo( 0 );
            }
        }
        imageView.Controls.prototype.zoomIn = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.zoomIn: zoomSpeed - ' + this.config.global.zoomSpeed );
            }
            
            this.image.viewer.viewport.zoomBy( this.config.global.zoomSpeed, this.image.viewer.viewport.getCenter( false ), false );
        }
        imageView.Controls.prototype.zoomOut = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.zoomOut: zoomSpeed - ' + this.config.global.zoomSpeed );
            }
            
            this.image.viewer.viewport.zoomBy( 1 / this.config.global.zoomSpeed, this.image.viewer.viewport.getCenter( false ), false );
        }
//        imageView.Controls.prototype.getHomeZoom: function( rotated ) {
//            if ( rotated && this.image.getCanvasSize().x / osViewer.getCanvasSize().y <= osViewer.getImageSize().x / osViewer.getImageSize().y ) {
//                osViewer.viewer.viewport.homeFillsViewer = true;
//            }
//            var zoom = osViewer.viewer.viewport.getHomeZoom();
//            osViewer.viewer.viewport.homeFillsViewer = false;
//            return zoom;
//        },
        imageView.Controls.prototype.rotateRight = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.rotateRight' );
            }
            
            var newRotation = this.image.viewer.viewport.getRotation() + 90;
            this.rotateTo( newRotation );
        }
        imageView.Controls.prototype.rotateLeft = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.rotateLeft' );
            }
            
            var newRotation = this.image.viewer.viewport.getRotation() - 90;
            this.rotateTo( newRotation );
        },
        imageView.Controls.prototype.getRotation = function() {
            if ( _debug ) {
                console.log( 'osViewer.controls.getRotation' );
            }
            
            return this.image.viewer.viewport.getRotation();
        }
        imageView.Controls.prototype.setRotation = function( rotation ) {
            if ( _debug ) {
                console.log( 'osViewer.controls.setRotation: rotation - ' + rotation );
            }
            
            return this.rotateTo( rotation );
        }
        imageView.Controls.prototype.rotateTo = function( newRotation ) {
            if ( newRotation < 0 ) {
                newRotation = newRotation + 360;
            }

            newRotation = newRotation % 360;

            if ( _debug ) {
            	console.log( 'osViewer.controls.rotateTo: newRotation - ' + newRotation );
            }
                        
            this.panning = true;        
            this.currentZoom = null;
            this.image.viewer.viewport.setRotation( newRotation );
            this.panning = false;

        }
        imageView.Controls.prototype.getCurrentRotationZooming = function() {
            var sizes = this.image.getSizes();
            if(sizes && sizes.rotated()) {
                return 1/sizes.ratio(sizes.originalImageSize);
            } else {
                return 1;
            }
        }
        imageView.Controls.prototype.setPanning = function(panning) {
            this.panning = panning;
        }
        imageView.Controls.prototype.isPanning = function() {
            return this.panning;
        }
        imageView.Controls.prototype.fullscreenControlsFadeout = function() {
            if ( _debug ) {
                console.log( '---------- osViewer.controls.fullscreenControlsFadeout() ----------' );
            }
            
            if ( this.fadeout ) {
                clearTimeout( this.fadeout );
                this.showFullscreenControls();
            }
            
            this.fadeout = setTimeout( this.hideFullscreenControls, 3000 );
        },
        imageView.Controls.prototype.hideFullscreenControls = function() {
            if ( _debug ) {
                console.log( '---------- osViewer.controls.hideFullscreenControls() ----------' );
            }
            
            $( '#fullscreenRotateControlsWrapper, #fullscreenZoomSliderWrapper, #fullscreenExitWrapper, #fullscreenPrevWrapper, #fullscreenNextWrapper' ).stop().fadeOut( 'slow' );
        }
        imageView.Controls.prototype.showFullscreenControls = function() {
            if ( _debug ) {
                console.log( '---------- osViewer.controls.showFullscreenControls() ----------' );
            }
            
            $( '#fullscreenRotateControlsWrapper, #fullscreenZoomSliderWrapper, #fullscreenExitWrapper, #fullscreenPrevWrapper, #fullscreenNextWrapper' ).show();
        }
        // set correct location, zooming and rotation once viewport has been updated after
        // redraw
        imageView.Controls.prototype.setLocation = function(event) {
            if(_debug) {                    
                console.log("Viewer changed from " + event.osState + " event");
                console.log("target location: ", event.targetLocation);
                console.log("Home zoom = ", this.image.viewer.viewport.getHomeZoom());
            }
            this.image.viewer.viewport.minZoomLevel = this.image.viewer.viewport.getHomeZoom() * this.config.global.minZoomLevel;
//            if(true) {
//                return;
//            }
            var targetZoom = event.targetLocation.zoom;
            if(event.targetLocation.zoom === 0) {
                targetZoom =  this.image.viewer.viewport.getHomeZoom();
                this.zoomedOut = true;
            }
                var targetLocation = undefined;
                if(event.targetLocation.x || event.targetLocation.y) {    
                    if(event.targetLocation.panTo !== false) {
                        this.zoomedOut = false;
                    }
                    targetLocation = new OpenSeadragon.Point(event.targetLocation.x, event.targetLocation.y);
                }
//                var zoomDiff = targetZoom * this.image.viewer.viewport.getHomeZoom() - (this.image.viewer.viewport.minZoomLevel);
//                this.zoomedOut = Math.abs(zoomDiff) < 0.001 || !targetZoom;
//                console.log("zoomDiff ", zoomDiff, "=", targetZoom, "*", this.image.viewer.viewport.getHomeZoom(), "-", this.image.viewer.viewport.minZoomLevel )
                if(this.zoomedOut && this.image.config.global.fitToContainer) {
                    if(_debug) {                         
                        console.log("Zooming home") 
                    }
                    this.goHome( true );
                } else {
                    if(_debug) {                         
                        console.log( "Zooming to " + targetZoom + " * " + this.getCurrentRotationZooming() );
                    }
                    if(this.image.config.global.fitToContainer) {
                        this.image.viewer.viewport.zoomTo( targetZoom * this.getCurrentRotationZooming(), null, true);
                    }
                    if(targetLocation && targetLocation.x < 2 && targetLocation.y < 2) {   
                        if(_debug) {                            
                            console.log("panning to ", targetLocation);
                        }
                        this.setCenter( targetLocation);
                    }
                }
                if(event.osState === "open" && event.targetLocation.rotation && !isNaN(event.targetLocation.rotation) && event.targetLocation.rotation !== 0) {
                    this.rotateTo(event.targetLocation.rotation);
                }
        }

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false; 
    
    imageView.Controls.Persistence = function(config, image) {
        
            if ( typeof ( Storage ) !== 'undefined' ) {
                
                /**
                 * Set Location from local storage
                 */
                var location = null;
                var currentPersistenceId = config.global.persistenceId;
                if ( config.global.persistZoom || config.global.persistRotation ) {
                    try {
                        var location = JSON.parse( sessionStorage.imageLocation );
                    }
                    catch ( err ) {
                        if ( _debug ) {
                            console.debug( "No readable image location in local storage" );
                        }
                    }
                    if ( location && _isValid( location ) && location.persistenceId === currentPersistenceId ) {
                        if ( _debug ) {
                            console.log( "Reading location from local storage", location );
                        }
                        config.image.location = {};
                        if ( config.global.persistZoom ) {
                            if ( _debug ) {
                                console.log( "setting zoom from local storage" );
                            }
                            config.image.location.zoom = location.zoom;
                            config.image.location.x = location.x;
                            config.image.location.y = location.y;
                        }
                        if ( config.global.persistRotation ) {
                            if ( _debug ) {
                                console.log( "setting rotation from local storage" );
                            }
                            config.image.location.rotation = location.rotation;
                        }
                        else {
                            config.image.location.rotation = 0;
                        }
                        
                    }
                    
                    this.saveLocation = function(event) {
                    	var loc = image.controls.getLocation();
                    	loc.persistenceId = config.global.persistenceId;
                    	sessionStorage.imageLocation = JSON.stringify( loc );
                    	if ( _debug ) {
                    	    console.log( "storing zoom " + sessionStorage.imageLocation );
                    	}
                    }
                    
                    /**
                     * save current location to local storage before navigating away
                     */
//                    this.saveLocation();
                    image.observables.close.subscribe(() =>  this.saveLocation());
                    $(window).bind("beforeunload", this.saveLocation);
                }
                
            }

        }

    function _isValid( location ) {
        return _isNumber( location.x ) && _isNumber( location.y ) && _isNumber( location.zoom ) && _isNumber( location.rotation );
    }
    
    function _isNumber( x ) {
        return typeof x === "number" && !Number.isNaN( x );
    }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    var _debug = false;
    
    imageView.CoordinateConversion = {};
    var cc = imageView.CoordinateConversion;
    
    /**
     * Scale the given point or rectangle in the original image to OpenSeadragon coordinates
     * This is the inverse of scaleToImage
     */
    imageView.CoordinateConversion.scaleToOpenSeadragon = function(coords, viewer, originalImageSize) {
        originalImageSize = cc.getAsDimension(originalImageSize);
        coords = cc.convertToOpenSeadragonObject(coords);
    	var displayImageSize = viewer.world.getItemAt(0).source.dimensions;
        var scale = originalImageSize.x/displayImageSize.x;
        coords = coords.times(1/displayImageSize.x);
        coords = coords.times(1/scale);     
        return coords;
    }
    
    /**
     * Scale the given point or rectangle in OpenSeadragon coordinates to original image coordinates
     * This is the inverse of scaleToOpenseadragon
     */
    imageView.CoordinateConversion.scaleToImage = function(coords, viewer, originalImageSize) {
        originalImageSize = cc.getAsDimension(originalImageSize);
        coords = cc.convertToOpenSeadragonObject(coords);
        var displayImageSize = viewer.world.getItemAt(0).source.dimensions;
        var scale = originalImageSize.x/displayImageSize.x;
        coords = coords.times(displayImageSize.x);
        coords = coords.times(scale);
        return coords;
    }

    
    /**
     * Scale the given point or rectangle in OpenSeadragon coordinates of the rotated image to coordinates of the original rotated image.
     * This is the inverse of scaleToOpenSeadragonCoordinates
     */
    imageView.CoordinateConversion.scaleToRotatedImage = function(roi, viewer, originalImageSize) {
    	var displayImageSize = viewer.world.getItemAt(0).source.dimensions;

        var displayImageRect = new OpenSeadragon.Rect(0,0,displayImageSize.x, displayImageSize.y);
        var originalImageRect = cc.convertToOpenSeadragonObject(cc.getAsRect(originalImageSize));
        var rotation = viewer.viewport.getRotation();
        var displayImageRect_rotated = cc.getRotatedBounds(displayImageRect, rotation);
        var originalImageRect_rotated = cc.getRotatedBounds(originalImageRect, rotation);
        
        var scale = originalImageRect_rotated.width/displayImageRect_rotated.width;
        roi = roi.times(displayImageSize.x);
        roi = roi.times(scale);
        return roi;
    }
    
    /**
     * input: a rectangle or point in the original image rotated by the current viewport rotation
     * output: the same rectangle/point scaled to OpenSeadragon coordinates of the rotated image
     * This is the inverse of scaleToRotatedImage
     */
    imageView.CoordinateConversion.scaleToOpenSeadragonCoordinates = function(roi, viewer, originalImageSize) {
    	var displayImageSize = viewer.world.getItemAt(0).source.dimensions;
        var displayImageRect = new OpenSeadragon.Rect(0,0,displayImageSize.x, displayImageSize.y);
        var originalImageRect = cc.convertToOpenSeadragonObject(cc.getAsRect(originalImageSize));
        
        var rotation = viewer.viewport.getRotation();
        var displayImageRect_rotated = cc.getRotatedBounds(displayImageRect, rotation);
        var originalImageRect_rotated = cc.getRotatedBounds(originalImageRect, rotation);
        
        var scale = originalImageRect_rotated.width/displayImageRect_rotated.width;
        roi = cc.convertToOpenSeadragonObject(roi);
        roi = roi.times(1/displayImageSize.x);
        roi = roi.times(1/scale);
        return roi;
    }
    
    /**
     * Converts a rectangle from the OpenSeadragon image to the rotated original image
     * This is the inverse of convertRectFromImageToOpenSeadragon
     */
    imageView.CoordinateConversion.convertRectFromOpenSeadragonToImage = function(rect, viewer, originalImageSize) {
        var rectInCanvas = ImageView.CoordinateConversion.convertRectFromImageToRotatedImage(rect, viewer);
        var rectInImage = cc.scaleToRotatedImage(rectInCanvas, viewer, originalImageSize);
        return rectInImage;
    }
    
    /**
     * Converts a rectangle from the rotated original image to the OpenSeadragon image
     * This is the inverse of convertRectFromOpenSeadragonToImage
     */
    imageView.CoordinateConversion.convertRectFromImageToOpenSeadragon = function(rect, viewer, originalImageSize) {
        var rectInCanvas = cc.scaleToOpenSeadragonCoordinates(rect, viewer, originalImageSize);
        var rectInOS = cc.convertRectFromRotatedImageToImage(rectInCanvas, viewer.viewport.getRotation(), originalImageSize);

        return rectInOS;
    }
    
    /**
     * Converts a rectangle from the rotated original image to the OpenSeadragon image
     * This is the inverse of convertPointFromOpenSeadragonToImage
     */
    imageView.CoordinateConversion.convertPointFromImageToOpenSeadragon = function(point, viewer, originalImageSize) {
    	var rectInOS = cc.convertPointFromRotatedImageToImage(point, viewer.viewport.getRotation(), originalImageSize);
        var rectInCanvas = cc.scaleToOpenSeadragonCoordinates(rectInOS, viewer, originalImageSize);
        return rectInCanvas;
    }
    
    /**
     * Converts a rectangle from the OpenSeadragon image to the rotated original image
     * This is the inverse of convertPointFromImageToOpenSeadragon
     */
    imageView.CoordinateConversion.convertPointFromOpenSeadragonToImage = function(point, viewer, originalImageSize) {
    	var pos_image = cc.scaleToImage(point, viewer, originalImageSize);
		var pos_image_rot = cc.convertPointFromImageToRotatedImage(pos_image, viewer.viewport.getRotation(), originalImageSize);
        return pos_image_rot;
    }
    
    /**
     * Converts a rectangle from the OpenSeadragon image to the canvas
     */
    imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas = function(rect, viewer) {
        var scale = viewer.drawer.context.canvas.width/viewer.viewport.getBoundsNoRotate(true).width;
        scale /= window.devicePixelRatio;
        
        var topLeft = cc.convertPointFromImageToCanvas(rect.getTopLeft(), viewer);
        var bottomRight = cc.convertPointFromImageToCanvas(rect.getBottomRight(), viewer);
        var centerX = topLeft.x + 0.5*(bottomRight.x-topLeft.x);
        var centerY = topLeft.y + 0.5*(bottomRight.y-topLeft.y);

        var canvasRect = new OpenSeadragon.Rect(centerX-0.5*rect.width*scale, centerY-0.5*rect.height*scale, rect.width*scale, rect.height*scale);
        return canvasRect;
    }
    
    /**
     * Converts a rectangle fom canvas coordinates to the OpenSeadragon image
     */
    imageView.CoordinateConversion.convertCoordinatesFromCanvasToImage = function(rect, viewer) {
        
        var scale = viewer.drawer.context.canvas.width/viewer.viewport.getBoundsNoRotate(true).width;
        scale /= window.devicePixelRatio;
        
        var topLeft = cc.convertPointFromCanvasToImage(rect.getTopLeft(), viewer);
        var bottomRight = cc.convertPointFromCanvasToImage(rect.getBottomRight(), viewer);
        var centerX = topLeft.x + 0.5*(bottomRight.x-topLeft.x);
        var centerY = topLeft.y + 0.5*(bottomRight.y-topLeft.y);
        var canvasRect = new OpenSeadragon.Rect(centerX-0.5*rect.width/scale, centerY-0.5*rect.height/scale, rect.width/scale, rect.height/scale);
        return canvasRect;
    }

    /**
     * Converts a point in the OpenSeadragon coordinate system (of the unrotated image) to the coordinate system of the canvas
     * This is affected by window.devicePixelRatio
     * This is the inverse of {@link ImageView.CoordinateConversion.convertPointFromCanvasToImage}
     */
    imageView.CoordinateConversion.convertPointFromImageToCanvas = function(point, viewer) {
    	
        var canvasWidth = viewer.drawer.context.canvas.width;
        var viewportWidth = viewer.viewport.getBoundsNoRotate(true).width;

        var scale = canvasWidth/viewportWidth;
        scale /= window.devicePixelRatio;
        var aspectRatio = viewer.source.width/viewer.source.height;
        var rotation = viewer.viewport.getRotation();
        var imageTopLeft_fromImageCenter = new OpenSeadragon.Point(0.5, 0.5/aspectRatio).times(-1);
        var canvasCenter_fromImageTopLeft = viewer.viewport.getCenter(true);
        var canvasCenter_fromCanvasTopLeft = new OpenSeadragon.Point(viewer.viewport.getBoundsNoRotate(true).width/2.0, viewer.viewport.getBoundsNoRotate(true).height/2.0);
        
        var canvasCenter_fromImageCenter = imageTopLeft_fromImageCenter.plus(canvasCenter_fromImageTopLeft);
        var canvasCenter_fromImageCenter_rotated = cc.rotate(canvasCenter_fromImageCenter, rotation, true);
        
        var imageCenter_fromCanvasTopLeft = canvasCenter_fromCanvasTopLeft.minus(canvasCenter_fromImageCenter_rotated);

        var point_fromImageCenter = imageTopLeft_fromImageCenter.plus(point);
        var point_fromImageCenter_rotated = cc.rotate(point_fromImageCenter, rotation, true);
        
        var point_FromCanvasTopLeft = imageCenter_fromCanvasTopLeft.plus(point_fromImageCenter_rotated);

        var p = point_FromCanvasTopLeft.times(scale);
        
        return p;
    }
    
    /**
     * Converts a point in the canvas coordinate system to the OpenSeadragon coordinate system (of the unrotated image)
     * This is affected by window.devicePixelRatio
     * This is the inverse of {@link ImageView.CoordinateConversion.convertPointFromImageToCanvas}
     */
    imageView.CoordinateConversion.convertPointFromCanvasToImage = function(point, viewer) {
        var scale = viewer.drawer.context.canvas.width/viewer.viewport.getBoundsNoRotate(true).width;
        scale /= window.devicePixelRatio;
        
        var aspectRatio = viewer.source.width/viewer.source.height;
        var rotation = viewer.viewport.getRotation();
        var imageTopLeft_fromImageCenter = new OpenSeadragon.Point(0.5, 0.5/aspectRatio).times(-1);
        var canvasCenter_fromImageTopLeft = viewer.viewport.getCenter(true);
        var canvasCenter_fromCanvasTopLeft = new OpenSeadragon.Point(viewer.viewport.getBoundsNoRotate(true).width/2.0, viewer.viewport.getBoundsNoRotate(true).height/2.0);
        
        var canvasCenter_fromImageCenter = imageTopLeft_fromImageCenter.plus(canvasCenter_fromImageTopLeft);
        var canvasCenter_fromImageCenter_rotated = cc.rotate(canvasCenter_fromImageCenter, rotation, true);
        
        var imageCenter_fromCanvasTopLeft = canvasCenter_fromCanvasTopLeft.minus(canvasCenter_fromImageCenter_rotated);
        
        var point_fromCanvasTopLeft = point.times(1/scale);
        var point_fromImageCenter_rotated = point_fromCanvasTopLeft.minus(imageCenter_fromCanvasTopLeft);
        var point_fromImageTopLeft = cc.rotate(point_fromImageCenter_rotated, rotation, false).minus(imageTopLeft_fromImageCenter);

        return point_fromImageTopLeft;
    }
    
    /**
     * input parameter rect: A rectangle in the coordinate system of the plain unrotated image in OpenSeadragon coordinates
     * output: The same rectangle in rotated image in OpenSeadragon coordinates
     * 
     * Both rectangles are defined by their center and their width and height. Width and height remain constant,
     * while the center is converted into coordinates of the rotated image
     */
    imageView.CoordinateConversion.convertRectFromImageToRotatedImage = function(rect, viewer) {
        
        var rotation = viewer.viewport.getRotation();
        var sourceBounds = new OpenSeadragon.Rect(0,0,viewer.source.width, viewer.source.height);
        var sourceBounds_rotated = cc.getRotatedBounds(sourceBounds, rotation);
        var aspectRatio_unrotated = sourceBounds.width/sourceBounds.height;
        var aspectRatio_rotated = sourceBounds_rotated.width/sourceBounds_rotated.height;
        
        var imageBounds_unrotated = new OpenSeadragon.Rect(0,0, 1.0, 1/aspectRatio_unrotated); 
        var imageBounds_rotated = cc.getRotatedBounds(imageBounds_unrotated, rotation);

        
        var rect_fromTopLeft_unrotated = rect.getCenter();
        var topLeft_fromCenter_unrotated = imageBounds_unrotated.getCenter().times(-1);
        var rect_fromCenter_unrotated = topLeft_fromCenter_unrotated.plus(rect_fromTopLeft_unrotated);

        var rect_fromCenter_rotated = cc.rotate(rect_fromCenter_unrotated, rotation, true);

        
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
        var rect_fromTopLeft_rotated = rect_fromCenter_rotated.minus(topLeft_fromCenter_rotated);
        var rect_rotated = new OpenSeadragon.Rect(rect_fromTopLeft_rotated.x-rect.width/2.0, rect_fromTopLeft_rotated.y-rect.height/2.0, rect.width, rect.height);
        return rect_rotated;
    }
    
    /**
     * input parameter rect: A rectangle in OpenSeadragon coordinates as if the image was the actual image rotated by the
     * current viewport rotation
     * output: The same rectangle in the displayed (unrotated) image in OpenSeadragon coordinates
     * 
     * Both rectangles are defined by their center and their width and height. Width and height remain constant,
     * while the center is converted into coordinates of the rotated image
     */
    imageView.CoordinateConversion.convertRectFromRotatedImageToImage = function(rect, rotation, imageBounds) {
        var sourceBounds = cc.convertToOpenSeadragonObject(cc.getAsRect(imageBounds));
        var sourceBounds_rotated = cc.getRotatedBounds(sourceBounds, rotation);
        var aspectRatio_unrotated = sourceBounds.width/sourceBounds.height;
        var aspectRatio_rotated = sourceBounds_rotated.width/sourceBounds_rotated.height;
        
        var imageBounds_unrotated = new OpenSeadragon.Rect(0,0, 1.0, 1/aspectRatio_unrotated); 
        var imageBounds_rotated = cc.getRotatedBounds(imageBounds_unrotated, rotation);
        var topLeft_fromCenter_unrotated = imageBounds_unrotated.getCenter().times(-1);
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
        
        var rect_fromTopLeft_rotated = rect.getCenter();
        var rect_fromCenter_rotated = topLeft_fromCenter_rotated.plus(rect_fromTopLeft_rotated);

        var rect_fromCenter_unrotated = cc.rotate(rect_fromCenter_rotated, rotation, false);

        var rect_fromTopLeft_unrotated = rect_fromCenter_unrotated.minus(topLeft_fromCenter_unrotated);
        var rect_unrotated = new OpenSeadragon.Rect(rect_fromTopLeft_unrotated.x-rect.width/2.0, rect_fromTopLeft_unrotated.y-rect.height/2.0, rect.width, rect.height);
        return rect_unrotated;
    }
    
    /**
     * Converts a point in any image coordinates to the same point in the coordinate system of the bounding rectangle of the same image if it was rotated by the viewport rotation
     */
    imageView.CoordinateConversion.convertPointFromImageToRotatedImage = function(point, rotation, imageBounds) {
        
        var imageBounds_rotated = cc.getRotatedBounds(imageBounds, rotation);
        imageBounds = cc.convertToOpenSeadragonObject(cc.getAsRect(imageBounds));

        var topLeft_fromCenter_unrotated = imageBounds.getCenter().times(-1);
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
        
        var point_fromTopLeft_unrotated = cc.convertToOpenSeadragonObject(point);
        var point_fromCenter_unrotated = point_fromTopLeft_unrotated.plus(topLeft_fromCenter_unrotated);

        var point_fromCenter_rotated = point_fromCenter_unrotated.rotate(rotation);
        var point_fromTopLeft_rotated = point_fromCenter_rotated.minus(topLeft_fromCenter_rotated);
        
        return point_fromTopLeft_rotated;
    }
    
    /**
     * Converts a point in the coordinate system of the bounding rectangle of a rotated image to the coordinate system of the image itself.
     */
    imageView.CoordinateConversion.convertPointFromRotatedImageToImage = function(point, rotation, imageBounds) {

        var imageBounds_rotated = cc.getRotatedBounds(imageBounds, rotation);
        imageBounds = cc.convertToOpenSeadragonObject(cc.getAsRect(imageBounds));

        var topLeft_fromCenter_unrotated = imageBounds.getCenter().times(-1);
        var topLeft_fromCenter_rotated = new OpenSeadragon.Point(imageBounds_rotated.width/2.0, imageBounds_rotated.height/2.0).times(-1);
       
        var point_fromTopLeft_rotated = cc.convertToOpenSeadragonObject(point);
        var point_fromCenter_rotated = point_fromTopLeft_rotated.plus(topLeft_fromCenter_rotated);
        var point_fromCenter_unrotated = point_fromCenter_rotated.rotate(-rotation);
        var point_fromTopLeft_unrotated = point_fromCenter_unrotated.minus(topLeft_fromCenter_unrotated);

        return point_fromTopLeft_unrotated;
    }
    
    /**
     * Converts a rectangle in a rotated image to the rectangle in the unrotated image
     */
    imageView.CoordinateConversion.convertImageAreaFromRotatedImageToImage = function(area, rotation, imageBounds) {
        let topLeft = new OpenSeadragon.Point(area.x, area.y);
        let bottomRight = new OpenSeadragon.Point(area.x + area.width, area.y + area.height);
        
        let topLeft_unrotated = cc.convertPointFromRotatedImageToImage(topLeft, rotation, imageBounds);
        let bottomRight_unrotated = cc.convertPointFromRotatedImageToImage(bottomRight, rotation, imageBounds);
        
        let top = Math.min(topLeft_unrotated.y, bottomRight_unrotated.y);
        let left = Math.min(topLeft_unrotated.x, bottomRight_unrotated.x);
        let bottom = Math.max(topLeft_unrotated.y, bottomRight_unrotated.y);
        let right = Math.max(topLeft_unrotated.x, bottomRight_unrotated.x);
        
        let area_unrotated = new OpenSeadragon.Rect(left, top, right-left, bottom-top);
        return area_unrotated;
    }




/**
 * Rotates around the coordinate system origin in clockwise direction. If the 'anticockwise' parameter is set and is true then the rotation direction is reversed.
 * 
 */
    imageView.CoordinateConversion.rotate = function(point, degrees, antiClockwise) {

	    var rad = degrees*Math.PI/180.0;
	    
	    var x,y;
	    if(antiClockwise === true) {
	        x = point.x*Math.cos(rad) - point.y*Math.sin(rad);
	        y = point.x*Math.sin(rad) + point.y*Math.cos(rad);
	    } else {
	        x =  point.x*Math.cos(rad) + point.y*Math.sin(rad);
	        y = -point.x*Math.sin(rad) + point.y*Math.cos(rad);
	    }
	    
	    return new OpenSeadragon.Point(x,y);
    }
    
    /**
     * Calculates the bounding rectangle that just encompasses the given rectangle rotated by the given angle in degrees.
     * The given rectangle is assumed to start at coordinates 0,0; and the returned rectangle will be given in the same coordinate frame,
     * i.e. with x and y values holding the offset from the original origin point (x and y are thus always negative, width and height always
     * larger than those of the original rectangle)
     * 
     * @param rect  the rectangle to rotate. must be an object with properties height and width
     * @param degrees   the rotation angle in degrees
     * @return     An OpenSeadragon.Rect containing the rotated rectangle in the original coordinate system
     */
    imageView.CoordinateConversion.getRotatedBounds = function(rect, degrees) {
            var width = rect.width === undefined ? rect.x : rect.width;
            var height = rect.height === undefined ? rect.y : rect.height;

            var rad = degrees * Math.PI/180.0;
        
            var sint = Math.abs(Math.sin(rad));
            var cost = Math.abs(Math.cos(rad));

            var hh = (width * sint + height * cost);
            var ww = (width * cost + height * sint);
            
            var w = Math.abs(ww);
            var h = Math.abs(hh);
            
            var dw = w - width;
            var dh = h - height;
            return new OpenSeadragon.Rect(-dw/2.0, -dh/2.0, w, h);
    }
    
    /**
     * If the argument has width and height, return an object which contains width and height as x and y
     */
    imageView.CoordinateConversion.getAsDimension = function(rect) {
    		var size =  {
    			x: rect.width === undefined ? rect.x : rect.width,
    	    	y: rect.height === undefined ? rect.y : rect.height,
    		};
    		return cc.convertToOpenSeadragonObject(size);
    }
    
    imageView.CoordinateConversion.getAsRect = function(coords) {
		var rect =  {
			x: coords.width === undefined ? 0 : coords.x,
	    	y: coords.height === undefined ? 0 : coords.y,			
	    	width: coords.width === undefined ? coords.x : coords.width,
	    	height: coords.height === undefined ? coords.y : coords.height,
		}
		return cc.convertToOpenSeadragonObject(rect);
}
    
    imageView.CoordinateConversion.convertToOpenSeadragonObject = function(object) {
    	if(object instanceof OpenSeadragon.Point || object instanceof OpenSeadragon.Rect) {
    		return object;
    	} else if(object.width !== undefined) {
    		return new OpenSeadragon.Rect(object.x, object.y, object.width, object.height);
    	} else if(typeof object === 'string') {
    	    let coords = object.split(",").map( i => i.trim()).map( i => parseFloat(i));
    	    if(coords.length == 2) {
    	        return new OpenSeadragon.Point(coords[0], coords[1]);
    	    } else if(coords.length == 4) {
    	        return new OpenSeadragon.Rect(coords[0], coords[1], coords[2], coords[3]);
    	} else {
    	    console.log("cannot convert ", object);
    	        throw "Cannot convert " + object + " to OpenSeadragon object";
    	    }
    	} else if(object.x !== undefined) {
    		return new OpenSeadragon.Point(object.x, object.y);
    	} else {
    	    console.log("cannot convert ", object);
            throw "Cannot convert " + object + " to OpenSeadragon object";
    	}
    }
    
    
    return imageView;
    
})(ImageView)
    
var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView) {
        throw "Image view must exist";
    }    
    
    /**
     * points must be in openSeadragon image coordinates (0 <= x <= 1 / 0 <= y <= height/width)
     */
    imageView.DataPoint = function(point, viewer, style) {
            
        // OpenSeadragon viewer
        this.viewer = viewer;
        // OpenSeadragon Points
        this.point = new OpenSeadragon.Point(point.x, point.y);
        // object containing properties borderWidth and borderColor
        this.style = style;
        this.hidden = false;
            
    };
    
    /**
     * Creates a styleobject for displaying a {@link ImageView.DataPoint}.
     * @param	pointStyle:	The style of the point itself. May be constructed by {@link ImageView.DataPoint.getPointStyle(radius, color)}. If undefined, the point will not be rendered.
     * @param	lineStyleX:	The style of the the line through the point, parallel to the x-axis. May be constructed by {@link ImageView.DataPoint.getLineStyle(width, color)}. If undefined, the line will not be rendered.
     * @param	lineStyleY:	The style of the line through the point, parallel to the y-axis. May be constructed by {@link ImageView.DataPoint.getPLineStyle(width, color)}. If undefined, the line will not be rendered.
     */
    imageView.DataPoint.getStyle = function(pointStyle, lineStyleX, lineStyleY) {
    	return {
    		point: pointStyle,
    		lineX: lineStyleX,
    		lineY: lineStyleY
    	}
    }
    
    /**
     * Creates a styleobject for displaying the point of a {@link ImageView.DataPoint).
     * @param	radius	The radius of the point in canvas coordinates
     * @param	color	The color of the point
     */
    imageView.DataPoint.getPointStyle = function(radius, color) {
    	return {
    		pointRadius: radius,
    		pointColor: color
    	}
    }
    
    /**
     * Creates a styleobject for displaying a line of a {@link ImageView.DataPoint).
     * @param	width	The width of the line in canvas coordinates
     * @param	color	The color of the line
     */
    imageView.DataPoint.getLineStyle = function(width, color) {
    	return {
    		lineWidth: width,
    		lineColor: color
    	}
    }
    
    /**
     * The rotation of the undelying OpenSeadragon Viewport
     */
    imageView.DataPoint.prototype.getRotation = function() {
        return this.viewer.viewport.getRotation();
    }
    
    /**
     * Set the position of the marker to the given x/y coordinates in OpenSeadragon coordinates.
     * If one of x and y is undefined, this position will not be set
     */
    imageView.DataPoint.prototype.setPosition = function(x, y) {
    	if(x !== undefined) {
    		this.point.x = x;
    	}
    	if(y !== undefined) {
    		this.point.y = y;
    	}
    }
    
    /**
     * Return the current position as OpenSeadragon.Point - in OpenSeadragon coordinates.
     * Note that the returned point is a clone of the actual position, so changing it will not affect the DataPoint
     */
    imageView.DataPoint.prototype.getPosition = function() {
    	return this.point.clone();
    }
    
    /**
     * Removes the point from the canvas. It will no longer be drawn until {@link this.draw()} is called on it
     */
    imageView.DataPoint.prototype.remove = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            this.viewer.forceRedraw();
        }
    }

    /**
     * Adds the point to the canvas, setting it up to be drawn every time the canvas changes
     */
    imageView.DataPoint.prototype.draw = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
        }
        _drawPoint({userData: this});
        this.eventHandler = function(event) {
        	_drawPoint(event)
        }
        this.viewer.addHandler( 'update-viewport', this.eventHandler, this );
    }
    
    /**
     * Checks if the given point is either on the datapoint itself or on one of its lines if they are drawn (i.e. associated with a style)
     * @param	point	The point to check
     * @param 	extra	The maximal distance the point may have from the data to count as a hit (in canvas coordinates)
     * @param	pointInCanvas	if true, the given point is assumed to be in canvas coordinates, otherwise in OpenSeadragon coordinates
     */
    imageView.DataPoint.prototype.contains = function(point, extra, pointInCanvas) {
    	
    	var pCanvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.point, this.viewer) : this.point;

        var dx = Math.abs(point.x-pCanvas.x);
        var dy = Math.abs(point.y-pCanvas.y);
        
        if( this.style.point && dx <= this.style.point.pointRadius + extra && dy <= this.style.point.pointRadius + extra ){
        	return true;
        } else if(dx <= extra && this.style.lineY) {
        	return true;
        } else if(dy <= extra && this.style.lineX) {
        	return true;
        } else {
        	return false;
        }
    }
    
    /**
     * Gets the {@link ImageView.DataPoint.HitArea} of the point, either the point itself ({@link ImageView.DataPoint.HitArea.POINT}),
     * the line parallel to the x-axis ({@link ImageView.DataPoint.HitArea.LINE_X}) or the line parallel to the y-axis ({@link ImageView.DataPoint.HitArea.LINE_Y}) 
     * If the point is not on any area of the DataPoint, undefined is returned
     * @param	point	The point to check
     * @param 	extra	The maximal distance the point may have from the area to be considered touching it (in canvas coordinates). The point takes precedence over the lines
     * @param	pointInCanvas	if true, the given point is assumed to be in canvas coordinates, otherwise in OpenSeadragon coordinates
     */
    imageView.DataPoint.prototype.getHitArea = function(point, extra, pointInCanvas) {
    	
    	var pCanvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.point, this.viewer) : this.point;
    	    	
    	var dx = Math.abs(point.x-pCanvas.x);
        var dy = Math.abs(point.y-pCanvas.y);
        
        if( this.style.point && dx <= this.style.point.pointRadius + extra && dy <= this.style.point.pointRadius + extra ){
        	return imageView.DataPoint.HitAreas.POINT;
        } else if(this.style.lineY && dx <= extra) {
        	return imageView.DataPoint.HitAreas.LINE_Y;
        } else if(this.style.lineX && dy <= extra) {
        	return imageView.DataPoint.HitAreas.LINE_X;
        } else {
        	return undefined;
        }
    }
    
    /**
     * temporarily hide the point, i.e. exlude it from being drawn
     */
    imageView.DataPoint.prototype.hide = function( immediate) {
        this.hidden = true;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    /**
     * show a formerly hidden point
     */
    imageView.DataPoint.prototype.show = function(immediate) {
        this.hidden = false;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    /**
     * reads a string in the form "x,y" and interprets it as the coordinates of the point (x,y).
     * Returns an object containing the points as properties x and y; 
     */
    imageView.DataPoint.convertStringToPoint = function(string) {
        var parts = string.split(",");
        if(parts && parts.length == 2) {       
        	return {
        		x : parseFloat(parts[0]),
        		y : parseFloat(parts[1])
        	}
        } else {
            throw "Cannot convert string '" + string + "' to Point";
        }
    }
    
    /**
     * Takes an an object containing the numeric properties x and y and returns it as String in the form "x,y"
     */
    imageView.DataPoint.convertPointsToString = function(point, decimalPlaces) {
        if(!decimalPlaces) {
            decimalPlaces = 0;
        }
        return point.x.toFixed(decimalPlaces) + "," +  point.y.toFixed(decimalPlaces);
    }

    imageView.DataPoint.HitAreas = {
            POINT : "point",
            LINE_Y : "lineY",
            LINE_X : 'lineX',
            isCorner: function( area ) {
                return area === this.POINT;
            },
            isEdge: function( area ) {
                return area === this.LINE_Y || area === this.LINE_X;
            },
            getCursor: function( area, style) {
            	if(area === this.POINT && style.point) {
            			return "move";
            	} else if(area === this.LINE_X && style.lineX) {
            		return "ns-resize";
            	} else if(area === this.LINE_Y && style.lineY) {
            			return "ew-resize";
            	} else {
            		return undefined;
            	}
            }
        }
    
    function _drawPoint(event) {
        var dp = event.userData;
        if(!dp.hidden) {     
            var context = dp.viewer.drawer.context;
        	var p = ImageView.CoordinateConversion.convertPointFromImageToCanvas(dp.point, dp.viewer);
        	if(dp.style.lineX) {
        		//draw line parallel to x
        		context.beginPath();
        		context.lineWidth = dp.style.lineX.lineWidth;
                context.strokeStyle = dp.style.lineX.lineColor;
                context.moveTo(0, p.y);
                context.lineTo(context.canvas.width, p.y);
            	context.stroke();
        	}
        	if(dp.style.lineY) {
        		//draw line parallel to y
        		context.beginPath();
        		context.lineWidth = dp.style.lineY.lineWidth;
                context.strokeStyle = dp.style.lineY.lineColor;
                context.moveTo(p.x, 0);
                context.lineTo(p.x, context.canvas.height);
            	context.stroke();
        	}
        	if(dp.style.point) {
        		//draw point
        		context.beginPath();
        		context.fillStyle = dp.style.point.pointColor;
        		context.lineWidth = 0;
        		context.arc(p.x, p.y, dp.style.point.pointRadius, 0, 2*Math.PI);
        		context.fill();
        	}
        }

    }

return imageView;

})( ImageView );


var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.DataPoint) {
        throw "imageView and imageView.DataPoint must be initialized first";
    }
    
    var DEFAULT_CURSOR = "default";

    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.DataPoint.Transform = function(viewer, startCondition) {
        this.viewer = viewer;
        this.startCondition = startCondition;
        this.active = true;
        this.transforming = false;
        this.currentDataPoint = null;
        this.drawArea = null;
        this.dataPoints = [];
        this.finishedObservable = new Rx.Subject();
        this.cursor = undefined;
        _addInputHook(this);
    }
    imageView.DataPoint.Transform.prototype.addDataPoint = function(dataPoint) {
        if(!this.dataPoints.includes(dataPoint)) {
            this.dataPoints.push(dataPoint);
            return true;
        }
        return false;
    }
    imageView.DataPoint.Transform.prototype.removeDataPoint = function(dataPoint) {
        if(this.dataPoints.includes(dataPoint)) {
            var index = this.dataPoints.indexOf(dataPoint);
            this.dataPoints.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.DataPoint.Transform.prototype.finishedTransforming = function() {
        return this.finishedObservable;
    }
    imageView.DataPoint.Transform.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.DataPoint.Transform.prototype.isActive = function() {
        return this.active;
    }
    imageView.DataPoint.Transform.prototype.isTransforming = function() {
        return this.transforming;
    }
    imageView.DataPoint.Transform.prototype.getContainingDataPoint = function(point) {
        for(var index in this.dataPoints) {
            var dataPoint = this.dataPoints[index];
            if(dataPoint.contains(point, _sideClickPrecision, true)) {
                return dataPoint;
            } 
        }
        return null;
    }

    
    function _addInputHook(transform) {
        var hook = transform.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, transform) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, transform) }
            }, {
                tracker: "viewer",
                handler: "releaseHandler",
                hookHandler: function(event) { _onViewerRelease(event, transform) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, transform) }
            } ]
        } );
        return hook;
    }


    function _onViewerMove( event, transform ) {
        if ( !transform.isTransforming() && transform.isActive() && transform.startCondition(event.originalEvent) ) {
            var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
            var dataPoint = transform.getContainingDataPoint(coords);
            var viewerElement = transform.viewer.element;
            if(dataPoint) {
                transform.currentDataPoint = dataPoint;
                transform.drawArea = dataPoint.getHitArea(coords, _sideClickPrecision, true);
            } else {
                transform.currentDataPoint = null;
                transform.drawArea = null;
            }
            if ( transform.drawArea ) {
            	var cursor = imageView.DataPoint.HitAreas.getCursor( transform.drawArea, dataPoint.style );
            	if(transform.cursor != cursor) {
            		transform.cursor = cursor;
            		$( viewerElement ).css( {cursor: cursor} );
            	}
            } else if(transform.cursor) {
            	transform.cursor = undefined;
            	$( viewerElement ).css( {cursor: DEFAULT_CURSOR} );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, transform ) {
        if ( transform.isActive()  && transform.startCondition(event.originalEvent)) {
            if ( transform.currentDataPoint && transform.drawArea ) {
                var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
                transform.startPoint = coords;
                transform.transforming = true;
                event.preventDefaultAction = true;
                return true;
            } else {
                transform.transforming = false;
                return false;
            }
        }
    }
    
    function _onViewerDrag( event, transform ) {
        if ( transform.isTransforming() ) {
            var newPoint = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var oldPoint = imageView.CoordinateConversion.convertPointFromImageToCanvas(transform.currentDataPoint.point, transform.viewer)
            var pNew = null;//rect.getTopLeft();
            if ( transform.drawArea === imageView.DataPoint.HitAreas.POINT ) {
            	pNew = newPoint;
            } else if ( transform.drawArea === imageView.DataPoint.HitAreas.LINE_X ) {
            	pNew = new OpenSeadragon.Point(oldPoint.x,newPoint.y);
            } else if ( transform.drawArea === imageView.DataPoint.HitAreas.LINE_Y ) {
            	pNew = new OpenSeadragon.Point(newPoint.x,oldPoint.y);
            } else {
            	pNew = oldPoint;
            }
            var pImage = imageView.CoordinateConversion.convertPointFromCanvasToImage(pNew, transform.viewer);
            transform.currentDataPoint.point = pImage;
            transform.viewer.forceRedraw();
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerRelease( event, transform ) {
        if ( transform.isActive() ) {
            if ( transform.transforming ) {
                transform.finishedObservable.next(transform.currentDataPoint);
            }
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, transform ) {
        if ( transform.isTransforming() ) {
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, transform ) {
        if ( transform.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    
    var drawingStyleClass = "drawing";
    var _hbAdd = 5;
    var _minDistanceToExistingRect = 0.01;
    
    var _active = false;
    var _drawing = false;
    var _overlayGroup = null;
    var _finishHook = null;
    var _viewerInputHook = null;
    var _deleteOldDrawElement = true;
    var _drawElement = null;
    var _drawPoint = null;
    
    imageView.DrawRect = function(config, image) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'osViewer.drawRect.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            var draw = this;
            this.viewerInputHook = image.viewer.addViewerInputHook( {
                hooks: [ {
                    tracker: "viewer",
                    handler: "clickHandler",
                    hookHandler: function(event) { _disableViewerEvent(event, draw) }
                // }, {
                // tracker: "viewer",
                // handler: "scrollHandler",
                // hookHandler: _disableViewerEvent
                }, {
                    tracker: "viewer",
                    handler: "dragHandler",
                    hookHandler: function(event) { _onViewerDrag(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "pressHandler",
                    hookHandler: function(event) { _onViewerPress(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "dragEndHandler",
                    hookHandler: function(event) { _onViewerDragEnd(event, draw) }
                } ]
            } );
        }
       imageView.DrawRect.prototype.startDrawing = function( overlayGroup, finishHook ) {
            this.active = true;
            this.overlayGroup = overlayGroup;
            this.finishHook = finishHook;
        }
        imageView.DrawRect.prototype.endDrawing = function( removeLastElement ) {
            this.active = false;
            this.overlayGroup = null;
            this.finishHook = null;
            if ( this.drawElement && removeLastElement ) {
                this.image.viewer.removeOverlay( this.drawElement );
            }
            else {
                $( this.drawElement ).removeClass( drawingStyleClass );
            }
        }
        imageView.DrawRect.prototype.isActive = function() {
            return this.active;
        }
        imageView.DrawRect.prototype.isDrawing = function() {
            return this.drawing;
        }
        imageView.DrawRect.prototype.removeLastDrawnElement = function() {
            if ( this.drawElement ) {
                this.image.viewer.removeOverlay( this.drawElement );
            }
        }

    function _onViewerPress( event, draw) {
        if ( draw.active ) {
            draw.drawPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            
            event.preventDefaultAction = false;
            return true;
        }
    }
    
    function _onViewerDrag( event, draw ) {
        // if(_debug) {
        // console.log("Dragging: ");
        // console.log("_active = " + _active);
        // console.log("_drawing = " + _drawing);
        // console.log("_drawPoint = " + _drawPoint);
        // }
        if ( draw.drawing ) {
            var newPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var rect = new OpenSeadragon.Rect( draw.drawPoint.x, draw.drawPoint.y, newPoint.x - draw.drawPoint.x, newPoint.y - draw.drawPoint.y );
            if ( newPoint.x < draw.drawPoint.x ) {
                rect.x = newPoint.x;
                rect.width = draw.drawPoint.x - newPoint.x;
            }
            if ( newPoint.y < draw.drawPoint.y ) {
                rect.y = newPoint.y;
                rect.height = draw.drawPoint.y - newPoint.y;
            }
            draw.image.viewer.updateOverlay( draw.drawElement, rect, 0 );
            event.preventDefaultAction = true;
            return true;
            
        }
        else if ( draw.active && draw.drawPoint ) {
            var activeOverlay = draw.image.overlays.getDrawingOverlay();
            if ( activeOverlay && draw.image.transformRect && draw.image.transformRect.isActive()
                    && draw.image.overlays.contains( activeOverlay.rect, draw.drawPoint, _minDistanceToExistingRect ) ) {
                draw.drawPoint = null;
                if ( _debug )
                    console.log( "Action overlaps active overlay" );
            }
            else {
                draw.drawing = true;
                if ( activeOverlay && _deleteOldDrawElement ) {
                    draw.image.overlays.removeOverlay( activeOverlay );
                }
                
                draw.drawElement = document.createElement( "div" );
                if ( draw.overlayGroup ) {
                    $( draw.drawElement ).addClass( draw.overlayGroup.styleClass );
                }
                $( draw.drawElement ).addClass( drawingStyleClass );
                var rect = new OpenSeadragon.Rect( draw.drawPoint.x, draw.drawPoint.y, 0, 0 );
                draw.image.viewer.addOverlay( draw.drawElement, rect, 1 );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, draw ) {
        if ( draw.drawing ) {
            draw.drawing = false;
            var newPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var rect = new OpenSeadragon.Rect( draw.drawPoint.x, draw.drawPoint.y, newPoint.x - draw.drawPoint.x, newPoint.y - draw.drawPoint.y );
            if ( newPoint.x < draw.drawPoint.x ) {
                rect.x = newPoint.x;
                rect.width = draw.drawPoint.x - newPoint.x;
            }
            if ( newPoint.y < draw.drawPoint.y ) {
                rect.y = newPoint.y;
                rect.height = draw.drawPoint.y - newPoint.y;
            }
            rect.hitBox = {
                l: rect.x - _hbAdd,
                t: rect.y - _hbAdd,
                r: rect.x + rect.width + _hbAdd,
                b: rect.y + rect.height + _hbAdd
            };
            
            var overlay = {
                type: imageView.Overlays.OverlayTypes.RECTANGLE,
                element: draw.drawElement,
                rect: rect,
                group: draw.overlayGroup.name,
            };
            draw.image.overlays.setDrawingOverlay( overlay );
            if ( draw.finishHook ) {
                draw.finishHook( overlay );
            }
            
            event.preventDefaultAction = true;
            return true;
        }
        
    }
    
    function _disableViewerEvent( event ) {
        if ( _active ) {
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function checkForRectHit( point ) {
        var i;
        for ( i = 0; i < _rects.length; i++ ) {
            var x = _rects[ i ];
            if ( point.x > x.hitBox.l && point.x < x.hitBox.r && point.y > x.hitBox.t && point.y < x.hitBox.b ) {
                var topLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + _hbAdd
                };
                var topRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + _hbAdd
                };
                var bottomRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var bottomLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var topHb = {
                    l: x.x + _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + _hbAdd
                };
                var rightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
                var bottomHb = {
                    l: x.x + _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var leftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
            }
        }
    }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView) {
        throw "Image view must exist";
    }    
    
    /**
     * points must be in openSeadragon image coordinates (0 <= x <= 1 / 0 <= y <= height/width)
     */
    imageView.Line = function(point1, point2, viewer, style) {
            
        // OpenSeadragon viewer
        this.viewer = viewer; 
        // OpenSeadragon Points 
        this.p1 = new OpenSeadragon.Point(point1.x, point1.y);
        this.p2 = new OpenSeadragon.Point(point2.x, point2.y);
        // object containing properties borderWidth and borderColor
        this.style = style;
        this.fixed = imageView.Line.getFixed(false);
        this.hidden = false;
            
    }
    
    /**
     * Return an object for the fixed property of ImageView.Line. 
     * The fixed property controls which of the six coordinates (two end point with two x/y coordinates each as well as the line as a whole) are allowed to change.
     * Depending on the passed argument all coordinates are set as fixed or not.
     */
    imageView.Line.getFixed = function(fixed) {
    	var object = {
    			p1: {
    				x:	fixed,
    				y: fixed
    			},
    			p2: {
    				x: fixed,
    				y: fixed
    			},
    			line : {
    				x: fixed,
    				y: fixed
    			}
    	}
    	return object;
    }
    
    imageView.Line.prototype.getRotation = function() {
        return this.viewer.viewport.getRotation();
    }
    
    imageView.Line.prototype.remove = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
            this.viewer.forceRedraw();
        }
    }

    imageView.Line.prototype.draw = function() {
        if(this.eventHandler) {            
            this.viewer.removeHandler( 'update-viewport', this.eventHandler, this );
        }
        _drawLine({userData: this});
        this.eventHandler = function(event) {
        	_drawLine(event)
        }
        this.viewer.addHandler( 'update-viewport', this.eventHandler, this );
    }
    
    imageView.Line.prototype.contains = function(point, extra, pointInCanvas) {
    	
    	var p1Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p1, this.viewer) : this.p1;
    	var p2Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p2, this.viewer) : this.p2;

        return _isBetween(p1Canvas, p2Canvas, point, extra);
    }
    
    imageView.Line.prototype.getHitArea = function(point, extra, pointInCanvas) {
    	
    	var p1Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p1, this.viewer) : this.p1;
    	var p2Canvas = pointInCanvas ? imageView.CoordinateConversion.convertPointFromImageToCanvas(this.p2, this.viewer) : this.p2;

    	    	
    	if(_dist(point, p1Canvas) <= extra) {
    		return imageView.Line.HitAreas.POINT_1;
    	} else if(_dist(point, p2Canvas) <= extra) {
    		return imageView.Line.HitAreas.POINT_2;
    	} else if(_isBetween(p1Canvas, p2Canvas, point, extra)) {
            return imageView.Line.HitAreas.LINE;
        } else {        	
        	return undefined;
        }
    }
    
    imageView.Line.prototype.hide = function( immediate) {
        this.hidden = true;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    imageView.Line.prototype.show = function(immediate) {
        this.hidden = false;
        if(immediate) {
            this.viewer.forceRedraw();
        }
    }
    
    /**
     * reads a string in the form "m,n,k,l" and interprets it as the coordinates of two points (m,n) and (k,l).
     * Returns an object containing the points as properties p1 and p2; 
     */
    imageView.Line.convertStringToPoints = function(string) {
        var parts = string.split(",");
        if(parts && parts.length == 4) {       
        	var p1 = new OpenSeadragon.Point(parseFloat(parts[0]), parseFloat(parts[1]));
        	var p2 = new OpenSeadragon.Point(parseFloat(parts[2]), parseFloat(parts[3]));
        	return {p1: p1, p2: p2};
        } else {
            throw "Cannot convert string '" + string + "' to Points";
        }
    }
    
    /**
     * Takes an object containing to points as properties p1 and p2 and returns it as String in the form "p1.x,p1.y,p2.x,p2.y"
     */
    imageView.Line.convertPointsToString = function(points, decimalPlaces) {
        if(!decimalPlaces) {
            decimalPlaces = 0;
        }
        return points.p1.x.toFixed(decimalPlaces) + "," +  points.p1.y.toFixed(decimalPlaces) + "," +  points.p2.x.toFixed(decimalPlaces) + "," +  points.p2.y.toFixed(decimalPlaces);
    }

    imageView.Line.HitAreas = {
            POINT_1 : "point1",
            POINT_2 : "point2",
            LINE : 'line',
            isCorner: function( area ) {
                return area === this.POINT_1 || area === this.POINT_2;
            },
            isEdge: function( area ) {
                return area === this.LINE;
            },
            getCursor: function( area, fixed) {
            	if(area === this.POINT_1) {
            		if(!fixed.p1.x && !fixed.p1.y) {
            			return "move";
            		} else if(fixed.p1.x) {
            			return "ns-resize";
            		} else if(fixed.p1.y) {
            			return "ew-resize";
            		} else {
            			return "not-allowed";
            		}
            	} else if(area === this.POINT_2) {
            		if(!fixed.p2.x && !fixed.p2.y) {
            			return "move";
            		} else if(fixed.p2.x) {
            			return "ns-resize";
            		} else if(fixed.p2.y) {
            			return "ew-resize";
            		} else {
            			return "not-allowed";
            		}
            	} else if(area === this.LINE) {
            		if(!fixed.line.x && !fixed.line.y) {
            			return "move";
            		} else if(fixed.line.x) {
            			return "ns-resize";
            		} else if(fixed.line.y) {
            			return "ew-resize";
            		} else {
            			return "not-allowed";
            		}
            	} else {
            		return undefined;
            	}
            }
        }
    
    function _drawLine(event) {
        var line = event.userData;
        if(!line.hidden) {        
            var context = line.viewer.drawer.context;
//            var center = new OpenSeadragon.Point(line.p1.x+(line.p2.x-line.p1.x)/2.0, line.p1.y+(line.p2.y-line.p1.y)/2.0);
//            var centerCanvas = ImageView.CoordinateConversion.convertPointFromImageToCanvas(center, line.viewer);
//            var p1 = {
//            		x: centerCanvas.x,
//            		y: 0
//            }
//            var p2 = {
//            		x: centerCanvas.x,
//            		y: context.canvas.height
//            }
            var p1 = ImageView.CoordinateConversion.convertPointFromImageToCanvas(line.p1, line.viewer);
            var p2 = ImageView.CoordinateConversion.convertPointFromImageToCanvas(line.p2, line.viewer);
            context.beginPath();        
            context.lineWidth = line.style.lineWidth;
            context.strokeStyle = line.style.lineColor;
            context.moveTo(p1.x, p1.y);
            context.lineTo(p2.x, p2.y);
            context.stroke();
        }
    }
    
    
    
    function _drawPoint(event) {
        var point = event.userData[0].times(window.devicePixelRatio);
        var viewer = event.userData[1];
        var color = event.userData[2];
        var radius = event.userData[3];
        var context = viewer.drawer.context;
//        console.log("draw on canvas ", viewer.drawer.context)
//        var point_canvas = ImageView.convertPointFromImageToCanvas(point, viewer);
        context.beginPath();
        if(color) {
            context.fillStyle = color;
        }
        context.arc(point.x, point.y, radius, 0, 2*Math.PI, true);
        context.fill();
    }

    
    function _isBetween( p1, p2, point, extra ) {
    	var dist = _distToSegment(point, p1, p2);
    	return dist <= extra;
    }


    function _sqr( x ) {
        return x * x
    }
    function _dist2( v, w ) {
        return _sqr( v.x - w.x ) + _sqr( v.y - w.y )
    }
    function _dist( v, w ) {
        return Math.sqrt( _dist2( v, w ) )
    }
    function _distToSegmentSquared( p, v, w ) {
        var l2 = _dist2( v, w );
        if ( l2 == 0 )
            return _dist2( p, v );
        var t = ( ( p.x - v.x ) * ( w.x - v.x ) + ( p.y - v.y ) * ( w.y - v.y ) ) / l2;
        if ( t < 0 )
            return _dist2( p, v );
        if ( t > 1 )
            return _dist2( p, w );
        return _dist2( p, {
            x: v.x + t * ( w.x - v.x ),
            y: v.y + t * ( w.y - v.y )
        } );
    }
    function _distToSegment( point, lineP1, lineP2 ) {
        return Math.sqrt( _distToSegmentSquared( point, lineP1, lineP2 ) );
    }

return imageView;

})( ImageView );


var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Line) {
        throw "imageView and imageView.Overlay must be initialized first";
    }
    
    var DEFAULT_CURSOR = "default";

    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.Line.Transform = function(viewer, style, startCondition) {

        this.viewer = viewer;
        this.style = style;
        this.startCondition = startCondition;
        this.active = true;
        this.transforming = false;
        this.currentLine = null;
        this.drawArea = null;
        this.startPoint = null;
        this.lines = [];
        this.finishedObservable = new Rx.Subject();
        this.cursor = undefined;
        this.fixed = imageView.Line.getFixed(false);
        _addInputHook(this);
    }
    imageView.Line.Transform.prototype.addLine = function(line) {
        if(!this.lines.includes(line)) {
            this.lines.push(line);
            return true;
        }
        return false;
    }
    imageView.Line.Transform.prototype.removeLine = function(line) {
        if(this.lines.includes(line)) {
            var index = this.lines.indexOf(line);
            this.lines.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.Line.Transform.prototype.finishedTransforming = function() {
        return this.finishedObservable;
    }
    imageView.Line.Transform.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Line.Transform.prototype.isActive = function() {
        return this.active;
    }
    imageView.Line.Transform.prototype.isTransforming = function() {
        return this.transforming;
    }
    imageView.Line.Transform.prototype.getContainingLine = function(point) {
        for(var index in this.lines) {
            var line = this.lines[index];
            if(line.contains(point, _sideClickPrecision, true)) {
                return line;
            } 
        }
        return null;
    }

    
    function _addInputHook(transform) {
        var hook = transform.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, transform) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, transform) }
            }, {
                tracker: "viewer",
                handler: "releaseHandler",
                hookHandler: function(event) { _onViewerRelease(event, transform) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, transform) }
            } ]
        } );
        return hook;
    }


    function _onViewerMove( event, transform ) {
        if ( !transform.isTransforming() && transform.isActive() && transform.startCondition(event.originalEvent) ) {
            
            var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
            var line = transform.getContainingLine(coords);
            var viewerElement = transform.viewer.element;
            if(line) {
                transform.currentLine = line;
                transform.drawArea = line.getHitArea(coords, _sideClickPrecision, true);
            } else {
                transform.currentLine = null;
                transform.drawArea = null;
            }
            if ( transform.drawArea ) {
            	var cursor = imageView.Line.HitAreas.getCursor( transform.drawArea, line.fixed );
            	if(transform.cursor != cursor) {
            		transform.cursor = cursor;
            		$( viewerElement ).css( {cursor: cursor} );
            	}
            } else if(transform.cursor) {
            	transform.cursor = undefined;
            	$( viewerElement ).css( {cursor: DEFAULT_CURSOR} );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, transform ) {
        if ( transform.isActive()  && transform.startCondition(event.originalEvent)) {
            if ( transform.currentLine && transform.drawArea ) {
            	console.log("transform draw area ", transform.drawArea);
                var coords = new OpenSeadragon.Point(event.position.x, event.position.y);
                transform.startPoint = coords;
                transform.transforming = true;
                event.preventDefaultAction = true;
                return true;
            } else {
                transform.transforming = false;
                return false;
            }
        }
    }
    
    function _onViewerDrag( event, transform ) {
        if ( transform.isTransforming() ) {
            var newPoint = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var p1 = imageView.CoordinateConversion.convertPointFromImageToCanvas(transform.currentLine.p1, transform.viewer)
        	var p2 = imageView.CoordinateConversion.convertPointFromImageToCanvas(transform.currentLine.p2, transform.viewer);
            var p1New = null;//rect.getTopLeft();
            var p2New = null;//rect.getBottomRight();
            if ( transform.drawArea === imageView.Line.HitAreas.POINT_1 ) {
            	var x = transform.currentLine.fixed.p1.x ? p1.x : newPoint.x;
            	var y = transform.currentLine.fixed.p1.y ? p1.y : newPoint.y;
            	p1New = new OpenSeadragon.Point(x,y);
            	p2New = p2;
            } else if ( transform.drawArea === imageView.Line.HitAreas.POINT_2 ) {
            	var x = transform.currentLine.fixed.p2.x ? p2.x : newPoint.x;
            	var y = transform.currentLine.fixed.p2.y ? p2.y : newPoint.y;
            	p1New = p1;
            	p2New = new OpenSeadragon.Point(x,y);
            } else if ( transform.drawArea === imageView.Line.HitAreas.LINE && transform.startPoint ) {
                var dx = transform.currentLine.fixed.line.x ? 0 : transform.startPoint.x - newPoint.x;
                var dy = transform.currentLine.fixed.line.y ? 0 : transform.startPoint.y - newPoint.y;
                var dist = new OpenSeadragon.Point(dx, dy);
                p1New = p1.minus(dist);
                p2New = p2.minus(dist);
                transform.startPoint = newPoint;
            } else {
            	p1New = p1;
            	p2New = p2;
            }
            var p1Image = imageView.CoordinateConversion.convertPointFromCanvasToImage(p1New, transform.viewer);
            var p2Image = imageView.CoordinateConversion.convertPointFromCanvasToImage(p2New, transform.viewer);
            transform.currentLine.p1 = p1Image;
            transform.currentLine.p2 = p2Image;
            transform.viewer.forceRedraw();
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerRelease( event, transform ) {
        if ( transform.isActive() ) {
            if ( transform.transforming ) {
                transform.finishedObservable.next(transform.currentLine);
            }
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, transform ) {
        if ( transform.isTransforming() ) {
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, transform ) {
        if ( transform.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    
    imageView.Measures = function( imageView ) {
        this.config = imageView.getConfig();
        this.$container = $( "#" + this.config.global.divId );
//        console.log("init measures");
        this.originalImageSize = new OpenSeadragon.Point( this.getTotalImageWidth( imageView.getImageInfo() ), this.getMaxImageHeight( imageView.getImageInfo() ) );

        this.outerCanvasSize = new OpenSeadragon.Point( this.$container.outerWidth(), this.$container.outerHeight() );
        this.innerCanvasSize = new OpenSeadragon.Point( this.$container.width(), this.$container.height() );
        // console.log("Original image size = ", this.originalImageSize);
        this.footerHeight = this.config.global.bottomMargin();
        this.rotation = imageView.viewer != null ? imageView.viewer.viewport.getRotation() : 0;
//        this.xPadding = this.outerCanvasSize.x - this.innerCanvasSize.x;
//        this.yPadding = this.outerCanvasSize.y - this.innerCanvasSize.y;
        this.innerCanvasSize.y -= this.footerHeight;
        // calculate image size as it should be displayed in relation to canvas size
        var originalSizeRotated = this.getRotatedSize(this.originalImageSize);
        if(this.config.global.adaptContainerHeight || this.fitToWidth()) {
        	//image display width is container width, height is calculated
        	var scale = this.innerCanvasSize.x/originalSizeRotated.x;
        	this.imageDisplaySize = originalSizeRotated.times(scale);
        } else if(this.config.global.adaptContainerWidth || this.fitToHeight()) {
        	var scale = this.innerCanvasSize.y/originalSizeRotated.y;
        	this.imageDisplaySize = originalSizeRotated.times(scale);
        } else {
        	this.imageDisplaySize = new OpenSeadragon.Point( 0, 0 );
        }
//        console.log("outer canvas size", this.outerCanvasSize)
//        console.log("inner canvas size", this.innerCanvasSize)
//        console.log("imageDisplaySize", this.imageDisplaySize)

    };
    imageView.Measures.prototype.getMaxImageWidth = function( imageInfo ) {
        var width = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                width = Math.max( width, tileSource.width * correction );
            }
        }
        return width;
    };
    imageView.Measures.prototype.getMaxImageHeight = function( imageInfo ) {
        var height = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                var correction = 1;
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                height = Math.max( height, tileSource.height * correction );
            }
        }
        return height;
    };
    imageView.Measures.prototype.getTotalImageWidth = function( imageInfo ) {
        var width = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                var correction = 1;
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                width += ( tileSource.width * correction );
            }
        }
        return width;
    };
    imageView.Measures.prototype.getTotalImageHeight = function( imageInfo ) {
        var height = 0;
        if ( imageInfo && imageInfo.length > 0 ) {
            for ( var i = 0; i < imageInfo.length; i++ ) {
                var tileSource = imageInfo[ i ];
                var aspectRatio
                if ( tileSource.tileSource ) {
                    correction = tileSource.width;
                    tileSource = tileSource.tileSource;
                }
                height += tileSource.height * correction;
            }
        }
        return height;
    };
    imageView.Measures.prototype.getImageHomeSize = function() {
    	return this.imageDisplaySize;
//        var ratio = this.rotated() ? 1 / this.ratio( this.originalImageSize ) : this.ratio( this.originalImageSize );
//        if ( this.fitToHeight() ) {
//            var height = this.innerCanvasSize.y;
//            var width = height / ratio;
//        }
//        else {
//            var width = this.innerCanvasSize.x;
//            var height = width * ratio;
//        }
//        return this.getRotatedSize( new OpenSeadragon.Point( width, height ) );
    };
    imageView.Measures.prototype.rotated = function() {
        return this.rotation % 180 !== 0;
    };
    imageView.Measures.prototype.landscape = function() {
        return this.ratio( this.originalImageSize ) < 1;
    };
    imageView.Measures.prototype.ratio = function( size ) {
        return size.y / size.x;
    }; 
    imageView.Measures.prototype.getRotatedSize = function( size ) {
	    if(size) { 
	    	var bounds = ImageView.CoordinateConversion.getRotatedBounds(size, this.rotation);
	    	return ImageView.CoordinateConversion.getAsDimension(bounds);
	    }
    };
    imageView.Measures.prototype.fitToHeight = function() {
        return !this.config.global.adaptContainerHeight && !this.config.global.adaptContainerWidth && this.ratio( this.getRotatedSize( this.originalImageSize ) ) > this.ratio( this.innerCanvasSize );
    };
    imageView.Measures.prototype.fitToWidth = function() {
        return !this.config.global.adaptContainerHeight && !this.config.global.adaptContainerWidth && this.ratio( this.getRotatedSize( this.originalImageSize ) ) < this.ratio( this.innerCanvasSize );
    };
    imageView.Measures.prototype.resizeCanvas = function() {
        // Set height of container if required
        if ( this.config.global.adaptContainerHeight ) {
            if ( _debug ) {
                console.log( "adapt container height" );
            }
            this.$container.height(this.imageDisplaySize.y + this.footerHeight );
        }
        if ( this.config.global.adaptContainerWidth ) {
            if ( _debug ) {
                console.log( "adapt container width" );
            }
            this.$container.width(this.imageDisplaySize.x);
        }
        this.outerCanvasSize = new OpenSeadragon.Point( this.$container.outerWidth(), this.$container.outerHeight() );
        this.innerCanvasSize = new OpenSeadragon.Point( this.$container.width(), this.$container.height() - this.footerHeight );
    };
    imageView.Measures.prototype.calculateExcessHeight = function() {
        var imageSize = this.getRotatedSize( this.getImageHomeSize() );
        var excessHeight = this.config.global.adaptContainerHeight || this.config.global.adaptContainerWidth || this.fitToHeight() ? 0 : 0.5 * ( this.innerCanvasSize.y - imageSize.y );
        return excessHeight;
    };
    imageView.Measures.prototype.getAspectRatio = function() {
    	return this.originalImageSize.y/this.originalImageSize.x;
    };
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Overlay) {
        throw "imageView and imageView.Overlay must be initialized first";
    }

    var _hbAdd = 5;
    var _minDistanceToExistingRect = 0.01;

    
    imageView.Draw = function(viewer, style, startCondition) {
        this.viewer = viewer;
        this.style = style;
        this.startCondition = startCondition;
        this.active = true;
        this.drawing = false;
        this.currentRect = null;
        this.startPoint = null;
        this.finishedObservable = new Rx.Subject();
         
        _addInputHook(this);
    }
    imageView.Draw.prototype.finishedDrawing = function() {
        return this.finishedObservable;
    }
    imageView.Draw.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Draw.prototype.isActive = function() {
        return this.active;
    }
    imageView.Draw.prototype.isDrawing = function() {
        return this.drawing;
    }
    /*
     * Position is in viewer element coordinates
     */
    imageView.Draw.prototype.createEmptyRectAt = function(position) {
        this.currentRect = new OpenSeadragon.Rect(position.x, position.y, 0,0);
        this.startPoint = position;
        _drawRect(this.currentRect, this.style, this.viewer.drawer.context);
        
    }
    imageView.Draw.prototype.updateOverlay = function(position) {
            this.viewer.forceRedraw();
            var draw = this;
            this.viewer.addOnceHandler( 'update-viewport', function( event ) {
                if(draw.isDrawing()) {
                    draw.currentRect.x = Math.min(draw.startPoint.x, position.x);
                    draw.currentRect.y = Math.min(draw.startPoint.y, position.y);
                    draw.currentRect.width = Math.abs(draw.startPoint.x-position.x);
                    draw.currentRect.height = Math.abs(draw.startPoint.y-position.y);
                    _drawRect(draw.currentRect, draw.style, draw.viewer.drawer.context);
                }
            });
    }
    
    function _drawRect(rect, style, context) {
        rect = rect.times(window.devicePixelRatio);
        context.beginPath();        
        context.lineWidth = style.borderWidth;
        context.strokeStyle = style.borderColor;
        context.fillStyle = style.fillColor;
        context.rect(rect.x, rect.y, rect.width, rect.height);
        context.stroke();
        if(style.fillColor) {
            context.fill();
        }
    }
    
    function _addInputHook(draw) {
        var hook = draw.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, draw) }
            // }, {
            // tracker: "viewer",
            // handler: "scrollHandler",
            // hookHandler: _disableViewerEvent
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, draw) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, draw) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, draw) }
            } ]
        } );
        return hook;
    }


    function _onViewerPress( event, draw) {
        if ( draw.isActive() && draw.startCondition(event.originalEvent)) {
        
            var position = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            draw.createEmptyRectAt(position);
            event.preventDefaultAction = false;
            draw.drawing = true;
            return true;
        }
    }
    
    function _onViewerDrag( event, draw) {
        if ( draw.isDrawing() ) {
            var position = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            draw.updateOverlay(position);
            event.preventDefaultAction = true;
            return true; 
        }
    }
    
    function _onViewerDragEnd( event, draw) {
        if ( draw.isDrawing() ) {
            draw.drawing = false;
            var rect = ImageView.CoordinateConversion.convertCoordinatesFromCanvasToImage(draw.currentRect, draw.viewer);
            var overlay = new ImageView.Overlay(rect, draw.viewer, draw.style);
            draw.finishedObservable.next(overlay);
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, draw) {
        if ( draw.isActive() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _rotatePoint(point, angle, center) {
        if(angle !== 0 && !angle) {
            angle = drawRect.viewer.viewport.getRotation();
        }
        if(!center) {
            center = drawRect.viewer.viewport.getCenter();
        }
        angle = angle*Math.PI/180.0;
        var rotated = {
                x : Math.cos(angle) * (point.x-center.x) - Math.sin(angle) * (point.y-center.y) + center.x,
                y : Math.sin(angle) * (point.x-center.x) + Math.cos(angle) * (point.y-center.y) + center.y
        }
        return rotated;
    }
    
    function _checkForRectHit( point ) {
        var i;
        for ( i = 0; i < _rects.length; i++ ) {
            var x = _rects[ i ];
            if ( point.x > x.hitBox.l && point.x < x.hitBox.r && point.y > x.hitBox.t && point.y < x.hitBox.b ) {
                var topLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + _hbAdd
                };
                var topRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + _hbAdd
                };
                var bottomRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var bottomLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var topHb = {
                    l: x.x + _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + _hbAdd
                };
                var rightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
                var bottomHb = {
                    l: x.x + _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var leftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
            }
        }
    }
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Overlay) {
        throw "imageView and imageView.Overlay must be initialized first";
    }
    
    var DEFAULT_CURSOR = "default";
    var REMOVE_CURSOR = "not-allowed";

    var _hbAdd = 5;
    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.Remove = function(viewer, startCondition) {
        this.viewer = viewer;
        this.startCondition = startCondition;
        this.active = true;
        this.currentOverlay = null;
        this.overlays = [];
        this.finishedObservable = new Rx.Subject();
        _addInputHook(this);
    }
    imageView.Remove.prototype.addOverlay = function(overlay) {
        if(!this.overlays.includes(overlay)) {
            this.overlays.push(overlay);
            this.overlays.sort((o1,o2) => {
            	return o1.highlight ? -1 : o2.highlight ? 1 : 0
            } );
            return true;
        }
        return false;
    }
    imageView.Remove.prototype.removeOverlay = function(overlay) {
        if(this.overlays.includes(overlay)) {
            var index = this.overlays.indexOf(overlay);
            this.overlays.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.Remove.prototype.finishedRemoving = function() {
        return this.finishedObservable;
    }
    imageView.Remove.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Remove.prototype.isActive = function() {
        return this.active;
    }
    imageView.Remove.prototype.getContainingOverlay = function(point) {
        for(var index in this.overlays) {
            var overlay = this.overlays[index];
            if(overlay.contains(point, _sideClickPrecision, true)) {
                return overlay;
            } 
        }
        return null;
    }

    
    function _addInputHook(remove) {
        var hook = remove.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _onViewerPress(event, remove) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, remove) }
            } ]
        } );
        return hook;
    }

    
    
    function _isInside( rect, point, extra ) {

        return point.x > rect.getTopLeft().x - extra && point.x < ( rect.x + rect.width + extra ) && point.y > rect.y - extra
                && point.y < ( rect.y + rect.height + extra );
    }

    function _onViewerMove( event, remove ) {
        if (remove.isActive() && remove.startCondition(event.originalEvent) ) {
            
            var coords = event.position;
            var overlay = remove.getContainingOverlay(coords);
            var viewerElement = remove.viewer.element;
            if(overlay) {
                remove.currentOverlay = overlay;
            } else {
                remove.currentOverlay = null;
            }
            
            if ( remove.currentOverlay ) {
                $( viewerElement ).css( {
                    cursor: REMOVE_CURSOR
                } );
            } else {
                $( viewerElement ).css( {
                    cursor: DEFAULT_CURSOR
                } );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, remove ) {
        if ( remove.isActive()  && remove.startCondition(event.originalEvent)) {
            if ( remove.currentOverlay) {
                remove.currentOverlay.remove();
                remove.finishedObservable.next(remove.currentOverlay);
                remove.currentOverlay = null;
                return true;
            } else {
                return false;
            }
        }
    }
    function _disableViewerEvent( event, remove ) {
        if ( remove.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

var ImageView = ( function(imageView) {
    'use strict';
    
    if(!imageView || !imageView.Overlay) {
        throw "imageView and imageView.Overlay must be initialized first";
    }
    
    var _hbAdd = 5;
    var _sideClickPrecision = 4;
    var _debug = false;
    
    imageView.Transform = function(viewer, style, startCondition) {

        this.viewer = viewer;
        this.style = style;
        this.startCondition = startCondition;
        this.active = true;
        this.transforming = false;
        this.currentOverlay = null;
        this.drawArea = null;
        this.startPoint = null;
        this.overlays = [];
        this.finishedObservable = new Rx.Subject();
        this.cursor = undefined;	//current cursor css
        _addInputHook(this);
    }
    imageView.Transform.prototype.addOverlay = function(overlay) {
        if(!this.overlays.includes(overlay)) {
            this.overlays.push(overlay);
            this.overlays.sort((o1,o2) => {
            	return o1.highlight ? -1 : o2.highlight ? 1 : 0
            } );
            return true;
        }
        return false;
    }
    imageView.Transform.prototype.removeOverlay = function(overlay) {
        if(this.overlays.includes(overlay)) {
            var index = this.overlays.indexOf(overlay);
            this.overlays.splice(index, 1);
            return true;
        }
        return false;
    }
    imageView.Transform.prototype.finishedTransforming = function() {
        return this.finishedObservable;
    }
    imageView.Transform.prototype.close = function() {
        this.active = false;
        this.finishedObservable.onCompleted();
    }
    imageView.Transform.prototype.isActive = function() {
        return this.active;
    }
    imageView.Transform.prototype.isTransforming = function() {
        return this.transforming;
    }
    imageView.Transform.prototype.getContainingOverlay = function(point) {
        for(var index in this.overlays) {
            var overlay = this.overlays[index];
            if(overlay.contains(point, _sideClickPrecision, true)) {
                return overlay;
            } 
        }
        return null;
    }

    
    function _addInputHook(transform) {
        var hook = transform.viewer.addViewerInputHook( {
            hooks: [ {
                tracker: "viewer",
                handler: "clickHandler",
                hookHandler: function(event) { _disableViewerEvent(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragHandler",
                hookHandler: function(event) { _onViewerDrag(event, transform) }
            }, {
                tracker: "viewer",
                handler: "pressHandler",
                hookHandler: function(event) { _onViewerPress(event, transform) }
            }, {
                tracker: "viewer",
                handler: "dragEndHandler",
                hookHandler: function(event) { _onViewerDragEnd(event, transform) }
            }, {
                tracker: "viewer",
                handler: "releaseHandler",
                hookHandler: function(event) { _onViewerRelease(event, transform) }
            }, {
                tracker: "viewer",
                handler: "moveHandler",
                hookHandler: function(event) { _onViewerMove(event, transform) }
            } ]
        } );
        return hook;
    }


    function _onViewerMove( event, transform ) {
        if ( !transform.isTransforming() && transform.isActive() && transform.startCondition(event.originalEvent) ) {
            
            var coords = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var overlay = transform.getContainingOverlay(coords);
            var viewerElement = transform.viewer.element;
            if(overlay) {
                transform.currentOverlay = overlay;
                transform.drawArea = overlay.getHitArea(coords, _sideClickPrecision, true);
            } else {
                transform.currentOverlay = null;
                transform.drawArea = null;
            }
            
            if ( transform.drawArea ) {
            	var cursor = imageView.Overlay.HitAreas.getCursor( transform.drawArea );
            	if(transform.cursor != cursor) {
            		transform.cursor = cursor;
            		$( viewerElement ).css( {cursor: cursor} );
            	}
            } else if(transform.cursor) {
            	transform.cursor = undefined;
            	$( viewerElement ).css( {cursor: DEFAULT_CURSOR} );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, transform ) {
        if ( transform.isActive()  && transform.startCondition(event.originalEvent)) {
            if ( transform.currentOverlay && transform.drawArea ) {
                var coords = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
                transform.startPoint = coords;
                transform.transforming = true;
                event.preventDefaultAction = true;
                return true;
            } else {
                transform.transforming = false;
                return false;
            }
        }
    }
    
    function _onViewerDrag( event, transform ) {
        if ( transform.isTransforming() ) {
            var newPoint = new OpenSeadragon.Point(event.position.x, event.position.y);//.times(1/window.devicePixelRatio);
            var rect = imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(transform.currentOverlay.rect, transform.viewer);
            var topLeft = null;//rect.getTopLeft();
            var bottomRight = null;//rect.getBottomRight();
            // if(_debug)console.log("Draw location = " + newPoint);
            if ( transform.drawArea === imageView.Overlay.HitAreas.TOPLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.TOPRIGHT ) {
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.BOTTOMLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.BOTTOMRIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.LEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = rect.getBottomRight();
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.RIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.TOP ) {
//                var rectOrig = new OpenSeadragon.Rect(rect.x, newPoint.y, rect.width, rect.height+(rect.y-newPoint.y));
//                var rectRotated = _createOverlay(rectOrig); 
//                rect = _normalize(rectRotated);
//                rect = rectOrig;
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.BOTTOM ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( transform.drawArea === imageView.Overlay.HitAreas.CENTER && transform.startPoint ) {
                var dx = transform.startPoint.x - newPoint.x;
                var dy = transform.startPoint.y - newPoint.y;
                rect.x -= dx;
                rect.y -= dy;
                transform.startPoint = newPoint;
            }
            
            if(topLeft && bottomRight) {
                rect = new OpenSeadragon.Rect(topLeft.x, topLeft.y, bottomRight.x-topLeft.x, bottomRight.y-topLeft.y);
            }

            transform.currentOverlay.rect = imageView.CoordinateConversion.convertCoordinatesFromCanvasToImage(rect, transform.viewer);
            transform.viewer.forceRedraw();
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _createOverlay(rect) {
        var topLeft = rect.getTopLeft();
        var bottomRight = rect.getBottomRight();
//        var topLeft = {x: Math.min(p1.x, p2.x), y : Math.min(p1.y, p2.y)};
//        var bottomRight = {x: Math.max(p1.x, p2.x),y: Math.max(p1.y, p2.y)}
//        console.log("top left ", topLeft);
//        console.log("bottom right ", bottomRight);
        var topLeftRotated = _rotatePoint(topLeft);
        var bottomRightRotated = _rotatePoint(bottomRight);
        
        var x = topLeft.x;
        var y = topLeft.y;
        var width = bottomRightRotated.x-topLeftRotated.x;
        var height = bottomRightRotated.y-topLeftRotated.y;
        
        var rectRotated = new OpenSeadragon.Rect(x,y, width, height);
        return rectRotated;
    }
    
    function _normalize(rect) {
        var p1 = rect.getTopLeft();
        var p2 = rect.getBottomRight();
        var topLeft = {x: Math.min(p1.x, p2.x), y : Math.min(p1.y, p2.y)};
        var bottomRight = {x: Math.max(p1.x, p2.x),y: Math.max(p1.y, p2.y)}
//        console.log("top left ", topLeft);
//        console.log("bottom right ", bottomRight);
        var norm = new OpenSeadragon.Rect(topLeft.x, topLeft.y, bottomRight.x-topLeft.x, bottomRight.y-topLeft.y);
        return norm;
    }
    
    function _onViewerRelease( event, transform ) {
        if ( transform.isActive() ) {
            if ( transform.transforming ) {
                transform.finishedObservable.next(transform.currentOverlay);
            }
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
     
    function _onViewerDragEnd( event, transform ) {
        if ( transform.isTransforming() ) {
            transform.transforming = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, transform ) {
        if ( transform.isTransforming() ) {
            event.preventDefaultAction = true;
            return true;
        }
    }

    
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    var _focusStyleClass = 'focus';
    var _highlightStyleClass = 'highlight';
//    var _overlayFocusHook = null;
//    var _overlayClickHook = null;
//    var _drawingOverlay = null;
//    var _overlays = [];
    
//    var _initializedCallback = null;

    imageView.Overlays = function(config, image){
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'osViewer.overlays.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            this.overlays = [];
            var overlays = this;
            
            this.image.observables.overlayRemove.subscribe(function( event ) {
                if ( event.element ) {
                    $( event.element ).remove();
                }
            });
            if(this.config.image.highlightCoords) {
               	this.image.observables.viewerOpen.subscribe( function( data ) {
            		for ( var index=0; index<overlays.config.image.highlightCoords.length; index++) {
            			var highlightCoords = overlays.config.image.highlightCoords[ index ];
            			var imageIndex = highlightCoords.pageIndex;
            			overlays.draw( highlightCoords.name, highlightCoords.displayTooltip, imageIndex);
            		}
            		if ( overlays.initializedCallback ) {
            			overlays.initializedCallback();
            		}
            	} );
            }
        }
        imageView.Overlays.prototype.onInitialized = function( callback ) {
            var oldCallback = this.initializedCallback;
            this.initializedCallback = function() {
                if ( oldCallback ) {
                    oldCallback();
                }
                callback();
            }
        }
        imageView.Overlays.prototype.onFocus = function( hook ) {
            var tempHook = this.overlayFocusHook;
            this.overlayFocusHook = function( overlay, focus ) {
                if ( tempHook )
                    tempHook( overlay, focus );
                hook( overlay, focus );
            }
        }
        imageView.Overlays.prototype.onClick = function( hook ) {
            var tempHook = this.overlayClickHook;
            this.overlayClickHook = function( overlay ) {
                if ( tempHook )
                    tempHook( overlay );
                hook( overlay );
            }
        },
        imageView.Overlays.prototype.getOverlays = function() {
            return this.overlays.slice();
        }
        imageView.Overlays.prototype.getRects = function() {
            return this.overlays.filter( function( overlay ) {
                return overlay.type === imageView.Overlays.OverlayTypes.RECTANGLE
            } ).slice();
        }
        imageView.Overlays.prototype.getLines = function() {
            return this.overlays.filter( function( overlay ) {
                return overlay.type === imageView.Overlays.OverlayTypes.LINE
            } ).slice();
        },
        imageView.Overlays.prototype.draw = function( group, displayTitle, imageIndex ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.draw: group - ' + group );
                console.log( 'osViewer.overlays.draw: displayTitle - ' + displayTitle );
                console.log( 'osViewer.overlays.draw: imageIndex - ' + imageIndex );
            }
            
            var coordList = this.image.getHighlightCoordinates( group );
            if ( coordList ) {
                if(typeof coordList.coordinates == 'string') {
                    if(_debug) console.log("convert " + coordList + " to coordinate list");
                    coordList.coordinates = _getCoordinatesFromUrlFragment(coordList.coordinates, this.image.getOriginalImageSize());
                }
                for ( var index=0; index<coordList.coordinates.length; index++ ) {
                    var coords = coordList.coordinates[ index ];
                    var title = displayTitle && coords.length > 4 ? coords[ 4 ] : '';
                    var id = coords.length > 5 ? coords[ 5 ] : index;
                    this.createRectangle( coords[ 0 ], coords[ 1 ], coords[ 2 ] - coords[ 0 ], coords[ 3 ] - coords[ 1 ], title, id, group, imageIndex );
                }
            }
        }
        imageView.Overlays.prototype.unDraw = function( group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.unDraw: group - ' + group );
            }
            
            var newRects = [];
            this.overlays = this.overlays.filter( function( overlay ) {
                if ( overlay.group === group ) {
                    this.image.viewer.removeOverlay( overlay.element );
                    return false;
                }
                else {
                    return true;
                }
            }.bind(this) );
        }
        imageView.Overlays.prototype.highlight = function( group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.highlight: group - ' + group );
            } 
            
            this.overlays.filter( function( overlay ) {
                return overlay.group === group;
            } ).forEach( function( overlay ) {
                if ( overlay.element ) {
                    overlay.element.highlight( true );
                }
            } );
            
        }
        imageView.Overlays.prototype.unHighlight = function( group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.unHighlight: group - ' + group );
            }
            
            this.overlays.filter( function( overlay ) {
                return overlay.group === group;
            } ).forEach( function( overlay ) {
                if ( overlay.element ) {
                    overlay.element.highlight( false );
                }
            } );
            
        }
        imageView.Overlays.prototype.focusBox = function( group, id ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.highlightBox: group - ' + group );
                console.log( 'osViewer.overlays.highlightBox: id - ' + id );
            }
            this.overlays
            .filter( function( overlay ) {
                return overlay.group === group;
            } )
            .forEach( function( overlay ) {
                if ( overlay.element ) {
                    overlay.element.focus( overlay.id === id );
                }
            } );
            
        }
        imageView.Overlays.prototype.addOverlay = function( overlay ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.addOverlay: overlay - ' + overlay );
            }
            
            this.overlays.push( overlay );
            if ( overlay.element ) {
                this.image.viewer.updateOverlay( overlay.element, overlay.rect, 0 );
            }
        }
        imageView.Overlays.prototype.removeOverlay = function( overlay ) {
            if ( overlay ) {
                if ( _debug )
                    console.log( "Removing overlay " + overlay.id );
                var index = this.overlays.indexOf( overlay );
                this.overlays.splice( index, 1 );
                if ( overlay.element ) {
                    this.image.viewer.removeOverlay( overlay.element );
                }
            }
        }
        imageView.Overlays.prototype.drawRect = function( rectangle, group, title, id ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.drawRect: rectangle - ' + rectangle );
                console.log( 'osViewer.overlays.drawRect: group - ' + group );
            }
            
            this.createRectangle( rectangle.x, rectangle.y, rectangle.width, rectangle.height, title ? title : "", id ? id : "", group );
        }
        imageView.Overlays.prototype.drawLine = function( point1, point2, group ) {
            if ( _debug ) {
                console.log( 'osViewer.overlays.drawLine: point1 - ' + point1 );
                console.log( 'osViewer.overlays.drawLine: point2 - ' + point2 );
                console.log( 'osViewer.overlays.drawLine: group - ' + group );
            }
            
            this.createLine( point1.x, point1.y, point2.x, point2.y, "", "", group );
        }
        imageView.Overlays.prototype.showOverlay = function( overlay ) {
            if ( overlay && !overlay.element ) {
                _drawOverlay( overlay, this );
                if ( this.overlayFocusHook ) {
                    this.overlayFocusHook( overlay, true );
                }
            }
            
        }
        imageView.Overlays.prototype.hideOverlay = function( overlay ) {
            if ( overlay && overlay.element && this.drawingOverlay != overlay ) {
                _undrawOverlay( overlay, this );
                if ( this.overlayFocusHook ) {
                    this.overlayFocusHook( overlay, false );
                }
            }
        }
        imageView.Overlays.prototype.getOverlay = function( id, group ) {
            var overlay =  this.overlays.find( function( overlay ) {
                if ( group ) {
                    return overlay.id === id && overlay.group === group;
                }
                else {
                    return overlay.id === id
                }
            } );
// console.log("search for overlay with id = " + id);
// console.log("Found overlay ", overlay);
            return overlay;
        }
        imageView.Overlays.prototype.getCoordinates = function( overlay ) {
            if(_debug){
                console.log("getCoordinates - overlay", overlay);
            }
            if ( overlay.type === imageView.Overlays.OverlayTypes.RECTANGLE ) {
                var transformedRect = this.image.viewer.viewport.viewportToImageRectangle( overlay.rect );
                return transformedRect;
            }
            else if ( overlay.type === imageView.Overlays.OverlayTypes.LINE ) {
                var p1 = this.image.viewer.viewport.viewportToImageCoordinates( overlay.poin1 );
                var p2 = this.image.viewer.viewport.viewportToImageCoordinates( overlay.poin2 );
                return {
                    point1: p1,
                    point2: p2
                };
            }
        }
        imageView.Overlays.prototype.getDrawingOverlay = function() {
            return this.drawingOverlay;
        }
        imageView.Overlays.prototype.setDrawingOverlay = function( overlay ) {
            this.drawingOverlay = overlay;
        }
        imageView.Overlays.prototype.showHiddenOverlays = function() {
            var overlays = this;
            this.image.viewer.addViewerInputHook( {
                hooks: [ {
                    tracker: "viewer",
                    handler: "moveHandler",
                    hookHandler: function(event) { _onViewerMove(event, overlays) }
                } ]
            } );
        }
        imageView.Overlays.prototype.contains = function( rect, point, precision ) {
            if ( precision == null ) {
                precision = 0;
            }
            return _isInside( rect, point, precision );
        }
        imageView.Overlays.OverlayTypes = {
            RECTANGLE: "rectangle",
            LINE: "line"
        }
        
        imageView.Overlays.prototype.createLine = function( x1, y1, x2, y2, title, id, group ) {
            if ( _debug ) {
                console.log( '------------------------------' );
                console.log( 'Overlays _createLine: x1 - ' + x1 );
                console.log( 'Overlays _createLine: y1 - ' + y1 );
                console.log( 'Overlays _createLine: x2 - ' + x2 );
                console.log( 'Overlays _createLine: y2 - ' + y2 );
                console.log( 'Overlays _createLine: title - ' + title );
                console.log( 'Overlays _createLine: id - ' + id );
                console.log( 'Overlays _createLine: group - ' + group );
                console.log( '------------------------------' );
            }
            
            var p1 = new OpenSeadragon.Point( x1, y1 );
            var p2 = new OpenSeadragon.Point( x2, y2 );
            var length = p1.distanceTo( p2 );
            
            var angle = _calculateAngle( p1, p2 );
            var beta = ( 180 - angle ) / 2;
    // console.log( "drawing line with length = " + length + " and angle = " + angle );
            
            y1 += length / 2 * Math.sin( angle * Math.PI / 180 );
            x1 -= length / 2 * Math.sin( angle * Math.PI / 180 ) / Math.tan( beta * Math.PI / 180 );
     
            var rectangle = this.image.viewer.viewport.imageToViewportRectangle( x1, y1, length, 1 );
            var p1Viewer = this.image.viewer.viewport.imageToViewportCoordinates( p1 );
            var p2Viewer = this.image.viewer.viewport.imageToViewportCoordinates( p2 );
            var overlay = {
                type: imageView.Overlays.OerlayTypes.LINE,
                rect: rectangle,
                angle: angle,
                point1: p1Viewer,
                point2: p2Viewer,
                group: group,
                id: id,
                title: title
            };
            var overlayStyle = this.getOverlayGroup( overlay.group );
            if ( !overlayStyle.hidden ) {
                _drawOverlay( overlay, this );
            }
            this.overlays.push( overlay );
            
        }
        
        /**
         * coordinates are in original image space
         */
        imageView.Overlays.prototype.createRectangle = function( x, y, width, height, title, id, group, imageIndex ) {
            if ( _debug ) {
                console.log( '------------------------------' );
                console.log( 'Overlays _createRectangle: x - ' + x );
                console.log( 'Overlays _createRectangle: y - ' + y );
                console.log( 'Overlays _createRectangle: width - ' + width );
                console.log( 'Overlays _createRectangle: height - ' + height );
                console.log( 'Overlays _createRectangle: title - ' + title );
                console.log( 'Overlays _createRectangle: id - ' + id );
                console.log( 'Overlays _createRectangle: group - ' + group );
                console.log( 'Overlays _createRectangle: imageIndex - ' + imageIndex );
                console.log( '------------------------------' );
            }
            
            if(!imageIndex) {
                imageIndex = 0;
            }
                var tiledImage = this.image.viewer.world.getItemAt(imageIndex);
                var rectangle = tiledImage.imageToViewportRectangle( x, y, width, height );
    // console.log("Found rect ", rectangle);
    // var rectangle = osViewer.viewer.viewport.imageToViewportRectangle( x, y, width, height
    // );
                var overlay = {
                        type: imageView.Overlays.OverlayTypes.RECTANGLE,
                        rect: rectangle,
                        group: group,
                        id: id,
                        title: title
                };
                var overlayStyle = this.image.getOverlayGroup( overlay.group );
                if (overlayStyle && !overlayStyle.hidden ) {
                    _drawOverlay( overlay, this);
                } 
                this.overlays.push( overlay );

            
            
        }

    
    function _undrawOverlay( overlay, overlays ) {
        overlays.image.viewer.removeOverlay( overlay.element );
        overlay.element = null;
    }
    
    function _drawOverlay( overlay, overlays ) {
        if(_debug) {
            console.log("viewImage.overlays._drawOverlay");
            console.log("overlay: ", overlay);
        }
        var element = document.createElement( "div" );
        $(element).attr("id", "overlay_" + overlay.id)
        var overlayStyle = overlays.image.getOverlayGroup( overlay.group );
        if ( overlayStyle ) {
            if(_debug)console.log("overlay style", overlayStyle);

            $( element ).addClass( overlayStyle.styleClass );
            
            if ( overlay.type === imageView.Overlays.OverlayTypes.LINE ) {
                _rotate( overlay.angle, element );
            }
            if ( overlayStyle.interactive ) {
                element.focus = function( focus ) {
                    if ( focus ) {
                        $( element ).addClass( _focusStyleClass );
                        _createTooltip(element, overlay, overlays.image);

                    }
                    else {
                        $( element ).removeClass( _focusStyleClass );
                        $(".tooltipp#tooltip_" + overlay.id).remove();
                    }
                    if ( overlays.overlayFocusHook ) {
                        overlays.overlayFocusHook( overlay, focus );
                    }
                };
                
                element.highlight = function( focus ) {
                    if ( focus ) {
                        $( element ).addClass( _highlightStyleClass );
                    }
                    else {
                        $( element ).removeClass( _highlightStyleClass );
                    }
                };
                
                $( element ).on( "mouseover", function() {
                    if ( _debug ) {
                        console.log( 'Overlays _drawOverlay: mouse over - ' + overlayStyle.name );
                    }
                    overlays.focusBox( overlay.group, overlay.id );
                } );
                $( element ).on( "mouseout", function() {
                    if ( _debug ) {
                        console.log( 'Overlays _drawOverlay: mouse out - ' + overlayStyle.name );
                    }
                    element.focus( false );
                } );
                $( element ).on( "click", function() {
                    if ( overlays.overlayClickHook ) {
                        overlays.overlayClickHook( overlay );
                    }
                } );
            }
            overlay.element = element;
            overlays.image.viewer.addOverlay( element, overlay.rect, 0 );
        }
    }
    
    function _createTooltip(element, overlay, image) {
    	if(overlay.title) {    		
    		var canvasTopLeft = image.sizes.$container.offset();
    		var canvasBottomRight = {
    		        left: canvasTopLeft.left + image.sizes.$container.width(),
    		        top: canvasTopLeft.top + image.sizes.$container.height()
    		}
    		
    		var top = $( element ).offset().top;
    		var left = $( element ).offset().left;
    		var bottom = top + $( element ).outerHeight();
    		var right = left + $( element ).outerWidth();

    		
    		var $tooltip = $("<div class='tooltipp'>" + overlay.title + "</div>");
    		console.log("add tooltip", $tooltip);
    		$("body").append($tooltip);
    		var tooltipPadding = parseFloat($tooltip.css("padding-top"));
    		$tooltip.css("top", Math.max(canvasTopLeft.top + tooltipPadding, top-$tooltip.outerHeight()-tooltipPadding));
    		$tooltip.css("left", Math.max(canvasTopLeft.left + tooltipPadding, left));
    		$tooltip.attr("id", "tooltip_" + overlay.id);
    		
    		// listener for zoom
    		
    		image.observables.animation
    		.pipe(RxOp.takeWhile( () => $(".tooltipp").length > 0 ))
    		.subscribe( () => {
    		    var top = Math.max($( element ).offset().top, canvasTopLeft.top);
    		    var left = Math.max($( element ).offset().left, canvasTopLeft.left);
    		    $tooltip.css("top", Math.max(canvasTopLeft.top + tooltipPadding, top-$tooltip.outerHeight()-tooltipPadding));
    		    $tooltip.css("left", Math.max(canvasTopLeft.left + tooltipPadding, left));    		    
    		}); 
    	}
    }
    
    function _rotate( angle, mapElement ) {
        if ( _debug ) {
            console.log( 'Overlays _rotate: angle - ' + angle );
            console.log( 'Overlays _rotate: mapElement - ' + mapElement );
        }
        
        if ( angle !== 0 ) {
            $( mapElement ).css( "-moz-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "-webkit-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "-ms-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "-o-transform", "rotate(" + angle + "deg)" );
            $( mapElement ).css( "transform", "rotate(" + angle + "deg)" );
            var sin = Math.sin( angle );
            var cos = Math.cos( angle );
            $( mapElement ).css(
                    "filter",
                    "progid:DXImageTransform.Microsoft.Matrix(M11=" + cos + ", M12=" + sin + ", M21=-" + sin + ", M22=" + cos
                            + ", sizingMethod='auto expand'" );
        }
    }
    
    function _calculateAngle( p1, p2 ) {
        if ( _debug ) {
            console.log( 'Overlays _calculateAngle: p1 - ' + p1 );
            console.log( 'Overlays _calculateAngle: p2 - ' + p2 );
        }
        
        var dx = p2.x - p1.x;
        var dy = p2.y - p1.y;
        var radians = null;
        
        if ( dx > 0 ) {
            radians = Math.atan( dy / dx );
            return radians * 180 / Math.PI;
        }
        else if ( dx < 0 ) {
            radians = Math.atan( dy / dx );
            return radians * 180 / Math.PI + 180;
        }
        else if ( dy < 0 ) {
            return 270;
        }
        else {
            return 90;
        }
    }
    
    
    function _getCoordinatesFromUrlFragment(fragment, imageSize) {
        var coordsRegex = /xywh=(percent:)?([\d\.\-\+]+,[\d\.\-\+]+,[\d\.\-\+]+,[\d\.\-\+]+)/;
        if(fragment) {
            var match;// = fragment.match(coordsRegex);
            while (match = coordsRegex.exec(fragment)) {    
                var percent = match[1] != undefined;
                var coords = match[2];
                coords = coords.split(",");
                var x,y,w,h;
                if(percent) {
                    x = parseInt(coords[0])*imageSize.x/100.0;
                    y = parseInt(coords[1])*imageSize.y/100.0;
                    w = parseInt(coords[2])*imageSize.x/100.0;
                    h = parseInt(coords[3])*imageSize.y/100.0;
                } else {                
                    x = parseInt(coords[0]);
                    y = parseInt(coords[1]);
                    w = parseInt(coords[2]);
                    h = parseInt(coords[3]);
                }
                //don't exceed image bounds
                x = Math.max(Math.min(imageSize.x, x), 0);
                y = Math.max(Math.min(imageSize.y, y), 0);
                w = Math.max(Math.min(imageSize.x-x, w), 0);
                h = Math.max(Math.min(imageSize.y-y, h), 0);
                return [[x,y,x+w,y+h, "", ""]];
            }
        }
        return [];
    }
    
// function _getScaleToOriginalSize() {
// var displaySize = osViewer.viewer.world.getItemAt(0).source.dimensions.x;//
// osViewer.viewer.viewport.contentSize.x;
// return osViewer.getImageInfo().width / displaySize;
// }
//    
// function _scaleToOriginalSize( value ) {
// if ( _debug ) {
// console.log( 'Overlays _scaleToOriginalSize: value - ' + value );
// }
//        
// var displaySize = osViewer.viewer.world.getItemAt(0).source.dimensions.x;//
// osViewer.viewer.viewport.contentSize.x;
// return value / displaySize * osViewer.getImageInfo().width;
// }
//    
// function _scaleToImageSize( value ) {
// if ( _debug ) {
// console.log( 'Overlays _scaleToImageSize: value - ' + value );
// }
//        
// var displaySize = osViewer.viewer.world.getItemAt(0).source.dimensions.x;//
// osViewer.viewer.viewport.contentSize.x;
// return value * displaySize / osViewer.getImageInfo().width;
// }
    
    function _isInside( rect, point, extra ) {
        return point.x > rect.x - extra && point.x < ( rect.x + rect.width + extra ) && point.y > rect.y - extra
                && point.y < ( rect.y + rect.height + extra );
    }
    
    function _onViewerMove( event, overlays ) { 
        var position = event.position;
        var ieVersion = viewerJS.helper.detectIEVersion();
        if(ieVersion && ieVersion === 10) {
// console.log("Correct position for ie ", ieVersion);
            position.x += $(window).scrollLeft();
            position.y += $(window).scrollTop();
        }
// console.log( "viewer move ", position);
        var point = overlays.image.viewer.viewport.viewerElementToViewportCoordinates( position );
        overlays.overlays.forEach( function( o ) {
            if ( _isInside( o.rect, point, 0 ) ) {
                overlays.showOverlay( o );
            }
            else {
                overlays.hideOverlay( o );
            }
        } );
    }
    
    return imageView;
    
} )( ImageView );

ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    
    imageView.TileSourceResolver = {
        
        resolveAsJsonOrURI: function( imageInfo ) {
            return new Promise( (resolve, reject) => {
	            if ( this.isJson( imageInfo ) ) {
	                resolve( imageInfo );
	            }
	            else if ( this.isStringifiedJson( imageInfo ) ) {
	                resolve( JSON.parse( imageInfo ) );
	            }
	            else {
	                resolve( imageInfo );
	            }
            });
            
        },
        
        resolveAsJson: function( imageInfo ) {
            return new Promise( (resolve, reject) => {
	            if ( this.isURI( imageInfo ) ) {
	                if ( this.isJsonURI( imageInfo ) ) {
	                    resolve(this.loadJsonFromURL( imageInfo ));
	                }
	                else {
	                    reject( "Url does not lead to a json object" );
	                }
	            }
	            else if ( typeof imageInfo === "string" ) {
	                try {
	                    var json = JSON.parse( imageInfo );
	                    resolve( json );
	                }
	                catch ( error ) {
	                    reject( "String does not contain valid json: " + error );
	                }
	            }
	            else if ( typeof imageInfo === "object" ) {
	                resolve( imageInfo );
	            } 
	            else {
	                reject( "Neither a url nor a json object" );
	            }
            });
        },
        
        loadJsonFromURL: function( imageInfo ) {
            return new Promise( (resolve, reject) => {
	            if ( this.isJsonURI( imageInfo ) ) {
	                OpenSeadragon.makeAjaxRequest( imageInfo,
	                // success
	                function( request ) {
	                    try { 
	                        resolve( JSON.parse( request.response ) );
	                    }
	                    catch ( error ) {
	                        reject( error )
	                    }
	                },
	                // error
	                function( error ) {
	                    reject( error );
	                } )
	            }
	            else {
	                reject( "Not a json uri: " + imageInfo );
	            }
            });
        },
        
        loadIfJsonURL: function( imageInfo ) {
            return new Promise( (resolve, reject ) => {
                if ( imageView.TileSourceResolver.isURI( imageInfo ) ) {
                    var ajaxParams = {
                        url: decodeURI( imageInfo ),
                        type: "GET",
                        dataType: "JSON",
                        async: true,
                        crossDomain: true,
                        accepts: {
                            application_json: "application/json",
                            application_jsonLd: "application/ld+json",
                            text_json: "text/json",
                            text_jsonLd: "text/ld+json",
                        }
                    }
                    $.ajax( ajaxParams ).then( function( data ) {
                        resolve( data );
                    } ).fail( function( error ) {
                        reject( "Failed to retrieve json from " + imageInfo );
                    } );
                    setTimeout( function() {
                        reject( "Timeout after 10s" );
                    }, 10000 )
                }
                else {
                    reject( "Not a uri: " + imageInfo );
                }
            } );
        },
        
        isJsonURI: function( imageInfo ) {
            if ( this.isURI( imageInfo ) ) {
                var shortened = imageInfo.replace( /\?.*/, "" );
                if ( shortened.endsWith( "/" ) ) {
                    shortened = shortened.substring( 0, shortened.length - 1 );
                }
                return shortened.toLowerCase().endsWith( ".json" );
            }
            return false;
        },
        isURI: function( imageInfo ) {
            if ( imageInfo && typeof imageInfo === "string" ) {
                if ( imageInfo.startsWith( "http://" ) || imageInfo.startsWith( "https://" ) || imageInfo.startsWith( "file:/" ) ) {
                    return true;
                }
            }
            return false;
        },
        isStringifiedJson: function( imageInfo ) {
            if ( imageInfo && typeof imageInfo === "string" ) {
                try {
                    var json = JSON.parse( imageInfo );
                    return this.isJson( json );
                }
                catch ( error ) {
                    // no json
                    return false;
                }
            }
            return false;
            
        },
        isJson: function( imageInfo ) {
            return imageInfo && typeof imageInfo === "object";
        },
    
    }

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var DEFAULT_CURSOR = "default";
    
    var _debug = false;
    
    var _drawingStyleClass = "transforming";
    
    var _active = false;
    var _drawing = false;
    var _group = null;
    var _finishHook = null;
    var _viewerInputHook = null;
    var _hbAdd = 5;
    var _sideClickPrecision = 0.004;
    var _drawArea = "";
    var _enterPoint = null;
    
    imageView.TransformRect = function(config, image){
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'osViewer.transformRect.init' );
                console.log( '##############################' );
            }
            this.config = config;
            this.image = image;
            var draw = this;
            this.viewerInputHook = image.viewer.addViewerInputHook( {
                hooks: [ {
                    tracker: "viewer",
                    handler: "clickHandler",
                    hookHandler: function(event) { _disableViewerEvent(event, draw) }
                // }, {
                // tracker : "viewer",
                // handler : "scrollHandler",
                // hookHandler : _disableViewerEvent
                }, {
                    tracker: "viewer",
                    handler: "dragHandler",
                    hookHandler: function(event) { _onViewerDrag(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "pressHandler",
                    hookHandler: function(event) { _onViewerPress(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "dragEndHandler",
                    hookHandler: function(event) { _onViewerDragEnd(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "releaseHandler",
                    hookHandler: function(event) { _onViewerRelease(event, draw) }
                }, {
                    tracker: "viewer",
                    handler: "moveHandler",
                    hookHandler: function(event) { _onViewerMove(event, draw) }
                } ]
            } );
        }
    imageView.TransformRect.prototype.startDrawing = function( overlay, finishHook ) {
            if ( _debug )
                console.log( "Start drawing" );
            this.image.overlays.setDrawingOverlay( overlay );
            this.active = true;
            this.group = overlay.group;
            this.finishHook = finishHook;
            $( overlay.element ).addClass( _drawingStyleClass );
        }
    imageView.TransformRect.prototype.endDrawing = function() {
            this.drawing = false;
            this.group = null;
            this.finishHook = null;
            this.active = false;
            var drawOverlay = this.image.overlays.getDrawingOverlay();
            if ( drawOverlay != null ) {
                $( drawOverlay.element ).removeClass( _drawingStyleClass );
                $( drawOverlay.element ).css( {
                    cursor: DEFAULT_CURSOR
                } );
            }
        }
        imageView.TransformRect.prototype.isActive = function() {
            return this.active;
        }
        imageView.TransformRect.HitAreas = {
            TOP: "t",
            BOTTOM: "b",
            RIGHT: "r",
            LEFT: "l",
            TOPLEFT: "tl",
            TOPRIGHT: "tr",
            BOTTOMLEFT: "bl",
            BOTTOMRIGHT: "br",
            CENTER: "c",
            isCorner: function( area ) {
                return area === this.TOPRIGHT || area === this.TOPLEFT || area === this.BOTTOMLEFT || area === this.BOTTOMRIGHT;
            },
            isEdge: function( area ) {
                return area === this.TOP || area === this.BOTTOM || area === this.LEFT || area === this.RIGHT;
            },
            getCursor: function( area, image ) {
                var rotated = image.viewer.viewport.getRotation() % 180 === 90;
                if ( area === this.TOPLEFT || area === this.BOTTOMRIGHT ) {
                    return rotated ? "nesw-resize" : "nwse-resize";
                }
                else if ( area === this.TOPRIGHT || area === this.BOTTOMLEFT ) {
                    return rotated ? "nwse-resize" : "nesw-resize";
                }
                else if ( area === this.TOP || area === this.BOTTOM ) {
                    return rotated ? "ew-resize" : "ns-resize";
                }
                else if ( area === this.RIGHT || area === this.LEFT ) {
                    return rotated ? "ns-resize" : "ew-resize";
                }
                else if ( area === this.CENTER ) {
                    return "move";
                }
                else {
                    return DEFAULT_CURSOR;
                }
            }
        }

    function _onViewerMove( event, draw ) {
        if ( !draw.drawing && draw.active ) {
            var drawPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var overlayRect = draw.image.overlays.getDrawingOverlay().rect;
            var overlayElement = draw.image.overlays.getDrawingOverlay().element;
            var viewerElement = draw.image.viewer.element;
            var area = _findCorner( overlayRect, drawPoint, _sideClickPrecision );
            if ( !area ) {
                area = _findEdge( overlayRect, drawPoint, _sideClickPrecision );
            }
            if ( !area && draw.image.overlays.contains( overlayRect, drawPoint, 0 ) ) {
                area = imageView.TransformRect.HitAreas.CENTER;
            }
            if ( area ) {
                $( viewerElement ).css( {
                    cursor: imageView.TransformRect.HitAreas.getCursor( area, draw.image )
                } );
            }
            else {
                $( viewerElement ).css( {
                    cursor: DEFAULT_CURSOR
                } );
            }
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerPress( event, draw ) {
        if ( draw.active ) {
            if ( !draw.image.overlays.getDrawingOverlay() ) {
                return false;
            }
            var overlayRect = draw.image.overlays.getDrawingOverlay().rect;
            var overlayElement = draw.image.overlays.getDrawingOverlay().element;
            var drawPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var drawArea = _findCorner( overlayRect, drawPoint, _sideClickPrecision );
            if ( !drawArea ) {
                drawArea = _findEdge( overlayRect, drawPoint, _sideClickPrecision );
            }
            if ( !drawArea && draw.image.overlays.contains( overlayRect, drawPoint, 0 ) ) {
                drawArea = imageView.TransformRect.HitAreas.CENTER;
            }
            if ( _debug )
                console.log( "draw area = " + drawArea );
            if ( drawArea ) {
                $( overlayElement ).tooltip( 'dispose' );
                draw.enterPoint = drawPoint;
            }
            draw.drawArea = drawArea;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDrag( event, draw ) {
        if ( draw.drawing ) {
            var newPoint = draw.image.viewer.viewport.viewerElementToViewportCoordinates( event.position );
            var rect = draw.image.overlays.getDrawingOverlay().rect;
            var topLeft;
            var bottomRight;
            // if(_debug)console.log("Draw location = " + newPoint);
            if ( draw.drawArea === imageView.TransformRect.HitAreas.TOPLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.TOPRIGHT ) {
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.BOTTOMLEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.BOTTOMRIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.LEFT ) {
                topLeft = new OpenSeadragon.Point( Math.min( newPoint.x, rect.getBottomRight().x ), rect.getTopLeft().y );
                bottomRight = rect.getBottomRight();
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.RIGHT ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( Math.max( newPoint.x, rect.getTopLeft().x ), rect.getBottomRight().y );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.TOP ) {
                topLeft = new OpenSeadragon.Point( rect.getTopLeft().x, Math.min( newPoint.y, rect.getBottomRight().y ) );
                bottomRight = rect.getBottomRight();
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.BOTTOM ) {
                topLeft = rect.getTopLeft();
                bottomRight = new OpenSeadragon.Point( rect.getBottomRight().x, Math.max( newPoint.y, rect.getTopLeft().y ) );
            }
            else if ( draw.drawArea === imageView.TransformRect.HitAreas.CENTER && draw.enterPoint ) {
                var dx = draw.enterPoint.x - newPoint.x;
                var dy = draw.enterPoint.y - newPoint.y;
                rect.x -= dx;
                rect.y -= dy;
                draw.enterPoint = newPoint;
            }
            
            if ( topLeft && bottomRight ) {
                // if(_debug)console.log("Upper left point is " + rect.getTopLeft());
                // if(_debug)console.log("Lower right point is " + rect.getBottomRight());
                // if(_debug)console.log("Setting upper left point to " + topLeft);
                // if(_debug)console.log("Setting lower right point to " + bottomRight);
                rect.x = topLeft.x;
                rect.y = topLeft.y;
                rect.width = bottomRight.x - topLeft.x;
                rect.height = bottomRight.y - topLeft.y;
            }
            
            draw.image.viewer.updateOverlay( draw.image.overlays.getDrawingOverlay().element, rect, 0 );
            event.preventDefaultAction = true;
            return true;
        }
        else if ( draw.drawArea ) {
            draw.drawing = true;
            event.preventDefaultAction = true;
            return true;
            
        }
    }
    
    function _onViewerRelease( event, draw ) {
        if ( draw.active ) {
            if ( draw.drawing && draw.finishHook ) {
                draw.finishHook( draw.image.overlays.getDrawingOverlay() );
            }
            draw.drawing = false;
            if ( draw.image.overlays.getDrawingOverlay() ) {
                $( draw.image.overlays.getDrawingOverlay().element ).tooltip();
            }
            draw.drawArea = "";
            draw.enterPoint = null;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _onViewerDragEnd( event, draw ) {
        if ( draw.drawing ) {
            draw.drawing = false;
            event.preventDefaultAction = true;
            return true;
        }
    }
    
    function _disableViewerEvent( event, draw ) {
        if ( draw.drawing ) {
            event.preventDefaultAction = true;
            return true;
        }
    }
    function checkForRectHit( point ) {
        var i;
        for ( i = 0; i < _rects.length; i++ ) {
            var x = _rects[ i ];
            if ( point.x > x.hitBox.l && point.x < x.hitBox.r && point.y > x.hitBox.t && point.y < x.hitBox.b ) {
                var topLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + _hbAdd
                };
                var topRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + _hbAdd
                };
                var bottomRightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var bottomLeftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var topHb = {
                    l: x.x + _hbAdd,
                    t: x.y - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + _hbAdd
                };
                var rightHb = {
                    l: x.x + x.width - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + x.width + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
                var bottomHb = {
                    l: x.x + _hbAdd,
                    t: x.y + x.height - _hbAdd,
                    r: x.x + x.width - _hbAdd,
                    b: x.y + x.height + _hbAdd
                };
                var leftHb = {
                    l: x.x - _hbAdd,
                    t: x.y + _hbAdd,
                    r: x.x + _hbAdd,
                    b: x.y + x.height - _hbAdd
                };
            }
        }
    }
    
    /*
     * Determine the side of the rectangle rect the point lies on or closest at <=maxDist
     * distance
     */
    function _findEdge( rect, point, maxDist ) {
        var distanceToLeft = _distToSegment( point, rect.getTopLeft(), rect.getBottomLeft() );
        var distanceToBottom = _distToSegment( point, rect.getBottomLeft(), rect.getBottomRight() );
        var distanceToRight = _distToSegment( point, rect.getTopRight(), rect.getBottomRight() );
        var distanceToTop = _distToSegment( point, rect.getTopLeft(), rect.getTopRight() );
        
        var minDistance = Math.min( distanceToLeft, Math.min( distanceToRight, Math.min( distanceToTop, distanceToBottom ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToLeft === minDistance ) {
                return imageView.TransformRect.HitAreas.LEFT;
            }
            if ( distanceToRight === minDistance ) {
                return imageView.TransformRect.HitAreas.RIGHT;
            }
            if ( distanceToTop === minDistance ) {
                return imageView.TransformRect.HitAreas.TOP;
            }
            if ( distanceToBottom === minDistance ) {
                return imageView.TransformRect.HitAreas.BOTTOM;
            }
        }
        return "";
    }
    
    /*
     * Determine the cornder of the rectangle rect the point lies on or closest at
     * <=maxDist distance
     */
    function _findCorner( rect, point, maxDist ) {
        var distanceToTopLeft = _dist( point, rect.getTopLeft() );
        var distanceToBottomLeft = _dist( point, rect.getBottomLeft() );
        var distanceToTopRight = _dist( point, rect.getTopRight() );
        var distanceToBottomRight = _dist( point, rect.getBottomRight() );
        
        var minDistance = Math.min( distanceToTopLeft, Math.min( distanceToTopRight, Math.min( distanceToBottomLeft, distanceToBottomRight ) ) );
        if ( minDistance <= maxDist ) {
            if ( distanceToTopLeft === minDistance ) {
                return imageView.TransformRect.HitAreas.TOPLEFT;
            }
            if ( distanceToTopRight === minDistance ) {
                return imageView.TransformRect.HitAreas.TOPRIGHT;
            }
            if ( distanceToBottomLeft === minDistance ) {
                return imageView.TransformRect.HitAreas.BOTTOMLEFT;
            }
            if ( distanceToBottomRight === minDistance ) {
                return imageView.TransformRect.HitAreas.BOTTOMRIGHT;
            }
        }
        return "";
    }
    
    function _sqr( x ) {
        return x * x
    }
    function _dist2( v, w ) {
        return _sqr( v.x - w.x ) + _sqr( v.y - w.y )
    }
    function _dist( v, w ) {
        return Math.sqrt( _dist2( v, w ) )
    }
    function _distToSegmentSquared( p, v, w ) {
        var l2 = _dist2( v, w );
        if ( l2 == 0 )
            return _dist2( p, v );
        var t = ( ( p.x - v.x ) * ( w.x - v.x ) + ( p.y - v.y ) * ( w.y - v.y ) ) / l2;
        if ( t < 0 )
            return _dist2( p, v );
        if ( t > 1 )
            return _dist2( p, w );
        return _dist2( p, {
            x: v.x + t * ( w.x - v.x ),
            y: v.y + t * ( w.y - v.y )
        } );
    }
    function _distToSegment( point, lineP1, lineP2 ) {
        return Math.sqrt( _distToSegmentSquared( point, lineP1, lineP2 ) );
    }
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    var _zoomSlider = {};
    var _defaults = {
            /**
             * The position of the zoom-slider is "dilated" by a function d(zoom) =
             * 1/sliderDilation*tan[atan(sliderDilation)*zoom] This makes the slider
             * position change slower for small zoom and faster for larger zoom The
             * function is chosen so that d(0) = 0 and d(1) = 1
             */
            sliderDilation: 12
    };
    
    imageView.ZoomSlider = function(config, image)  {    
        this.config = $.extend( true, {}, _defaults );
        $.extend( true, this.config, config.global );
        this.image = image;
    }
    
    imageView.ZoomSlider.prototype.init = function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'imageView.zoomSlider.init', this.config );
                console.log( '##############################' );
            }
                this.addZoomSlider(this.config.zoomSlider );
        };
        imageView.ZoomSlider.prototype.exists = function() {
            return this.$element.length && this.$button.length;
        };
        


        
        imageView.ZoomSlider.prototype.addZoomSlider = function( element ) {
            if ( _debug ) {
                console.log( 'imageView.zoomSlider.addZoomSlider: element - ' + element );
            }
            
            this.$element = $( element );
            if(this.$element.length > 0) {
                Rx.fromEvent(this.$element.get(0), "input")
                .subscribe( function(event){
                    let value = event.target.value;
                    this.zoomToSliderPosition(value);
                }.bind(this));
                
                this.image.observables.viewerZoom
                .subscribe( function( event ) {
                    var scale = this.image.viewer.viewport.getZoom();
                    this.setSliderPositionToZoom(scale);
                }.bind(this));
            }
            
            this.$label = $(this.config.zoomSliderLabel);
            if(this.$label.length) {
                this.setLabel(this.image.viewer.viewport.getZoom());
                this.$label.on("change", function(event) {
                    this.inputToZoom(event.target.value)
                    return false;
                }.bind(this));
                this.$label.on("keypress", function(e) {
                    if (e.which == 13) {
                        this.inputToZoom(e.target.value)
                        return false;
                    }
                }.bind(this));
                this.image.observables.viewerZoom
                .subscribe( (event) => {
                    var zoom = this.image.viewer.viewport.getZoom();
                    this.setLabel(zoom);
                });
            }
            
            this.setSliderPositionToZoom(this.image.viewer.viewport.getZoom());
            
        };
        
        imageView.ZoomSlider.prototype.setSliderPositionToZoom = function( zoom ) {
            let minZoom = this.image.viewer.viewport.getMinZoom();
            let maxZoom = this.image.viewer.viewport.getMaxZoom();
            let factor = ( (zoom - minZoom) / (maxZoom-minZoom) );
            let position = 1 / Math.atan( this.config.sliderDilation ) * Math.atan( this.config.sliderDilation * factor );
            if(_debug) {                
                console.log("set slider to ", zoom, factor, position);
            }
            this.$element.val(position);
        }
        
        imageView.ZoomSlider.prototype.zoomToSliderPosition = function( position ) {
            let factor = 1 / this.config.sliderDilation * Math.tan( Math.atan( this.config.sliderDilation ) * position );
            let minZoom = this.image.viewer.viewport.getMinZoom();
            let maxZoom = this.image.viewer.viewport.getMaxZoom();
            let zoom = minZoom + factor * (maxZoom-minZoom);
            if(_debug) {                
                console.log("set zoom to ", position, factor, zoom);
            }
            this.zoomTo(zoom);
        }

        imageView.ZoomSlider.prototype.zoomTo = function( zoomTo ) {
            if ( _debug ) {
                console.log( 'imageView.controls.myZoomTo: zoomTo - ' + zoomTo );
            }
            
            var zoomBy = parseFloat( zoomTo ) / this.image.viewer.viewport.getZoom();
            
            if ( _debug ) {
                console.log( 'imageView.controls.myZoomTo: zoomBy - ' + zoomBy );
            }
            
            this.image.viewer.viewport.zoomBy( zoomBy, this.image.viewer.viewport.getCenter( false ), true );
        };
        
        imageView.ZoomSlider.prototype.setLabel = function(scale) {
            if(this.$label.length && this.image.sizes) {
                var imageWidth = this.image.config.image.originalImageWidth;
                var imageViewWidth = this.image.container.width();
                scale = parseFloat(scale)/imageWidth*imageViewWidth;
                scale *= window.devicePixelRatio;
                this.$label.val((scale*100).toFixed(1));
            }
        };
        imageView.ZoomSlider.prototype.inputToZoom = function(input) {
            var imageScale = parseFloat(input);
            if(imageScale && this.image.sizes) {
                if(_debug) {
                    console.log("scale to ", input);
                }
                var imageWidth = this.image.config.image.originalImageWidth;
                var imageViewWidth = this.image.container.width();
                var scale = imageScale*imageWidth/imageViewWidth/100.0;
                scale /= window.devicePixelRatio;
                if(scale < this.image.viewer.viewport.getMinZoom()) {
                    scale = this.image.viewer.viewport.getMinZoom();
                } else if(scale > this.image.viewer.viewport.getMaxZoom()) {
                    scale = this.image.viewer.viewport.getMaxZoom();
                }
                this.zoomTo( scale );
            }
        };
    
    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools) {
        imageView.Tools = {};
    }
      
    imageView.Tools.Filter = function(image, filterMethod) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.init' );
            console.log( '##############################' );
        }
        this.filterMethod = filterMethod;
        this.image = image;
        this.disabled = false;
    }
    
    imageView.Tools.Filter.prototype.start = function() {
        if(!this.subsription) {            
            this.subscription = this.image.observables.viewportUpdate
            .pipe(RxOp.takeWhile(() => !this.disabled))
            .subscribe((event) => {
                let context = this.image.getCanvasContext();
                let data = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
                data = this.filterMethod(data);
                if(data) {                    
                    context.putImageData(data, 0, 0);
                }
            });
        }
        this.apply();
    }
    
    imageView.Tools.Filter.prototype.apply = function() {
        if(this.subscription) {            
            this.image.redraw();
        }
    }
    
    imageView.Tools.Filter.prototype.close = function() {
        if(this.subscription) {            
            this.subscription.unsubscribe();
            this.subscription = undefined;
            this.image.redraw();
        } 
    }
    
    imageView.Tools.Filter.prototype.isActive = function() {
        return this.subscription;
    }
    

    imageView.Tools.Filter.prototype.createImageData = function(w,h) {
      return this.image.getCanvasContext().createImageData(w,h);
    };

    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.ConvolutionFilter = function(image, filterMatrix, opaque) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.ConvolutionFilter.init' );
            console.log( '##############################' );
        }
        this.matrix = filterMatrix;
        this.opaque = opaque;
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.ConvolutionFilter.prototype = Object.create(imageView.Tools.Filter.prototype);
    
    imageView.Tools.ConvolutionFilter.prototype.filter = function(pixels) {
        return this.convolute(pixels, this.getMatrix(), this.opaque);
    }
    
    imageView.Tools.ConvolutionFilter.prototype.getMatrix = function() {
        return this.matrix;
    }
    
    imageView.Tools.ConvolutionFilter.prototype.convolute = function(pixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = pixels.data;
        var sw = pixels.width;
        var sh = pixels.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var output = this.createImageData(w, h);
        var dst = output.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
          for (var x=0; x<w; x++) {
            var sy = y;
            var sx = x;
            var dstOff = (y*w+x)*4;
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            var r=0, g=0, b=0, a=0;
            for (var cy=0; cy<side; cy++) {
              for (var cx=0; cx<side; cx++) {
                var scy = sy + cy - halfSide;
                var scx = sx + cx - halfSide;
                if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                  var srcOff = (scy*sw+scx)*4;
                  var wt = weights[cy*side+cx];
                  r += src[srcOff] * wt;
                  g += src[srcOff+1] * wt;
                  b += src[srcOff+2] * wt;
                  a += src[srcOff+3] * wt;
                }
              }
            }
            dst[dstOff] = r;
            dst[dstOff+1] = g;
            dst[dstOff+2] = b;
            dst[dstOff+3] = a + alphaFac*(255-a);
          }
        }
        return output;
      };
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) {
    'use strict';
    
    var _debug = false;
    var _defaults = {
            removeOldAreas : true,
            drawStyle : {
                borderColor: "#0000ff",
                borderWidth: 2,
                fillColor: "#ffffff",
                fillOpacity: 0.5,
            }
    }

    if(!imageView.Tools) {
        imageView.Tools = {};
    }
      
    imageView.Tools.AreaSelect = function(image, config) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.areaSelect.init' );
            console.log( '##############################' );
        }
        this.config = $.extend({}, _defaults, config);
        this.image = image;
        this.drawing = false;
        this.areas = [];
        this.finishedHook = new Rx.Subject();
        this.currentRect = null;
        
        this.drawer = new ImageView.Draw(image.viewer, this.config.drawStyle, () => this.drawing && this.currentRect == null);
        this.transformer = new ImageView.Transform(image.viewer, this.config.drawStyle, () => this.drawing && this.currentRect != null);
        this.transformer.finishedTransforming().subscribe(function(rect) {
            let imageArea = ImageView.CoordinateConversion.convertRectFromOpenSeadragonToImage(rect.rect, this.image.viewer, this.image.getOriginalImageSize());
            imageArea = ImageView.CoordinateConversion.convertImageAreaFromRotatedImageToImage(imageArea, this.image.getRotation(), this.image.getOriginalImageSize());
            this.finishedHook.next(imageArea); 
        }.bind(this))
        this.drawer.finishedDrawing().subscribe(function(rect) {
            if(this.config.removeOldAreas) {
                let old = this.areas.pop();
                if(old) {
                    old.remove(); 
                }
            }
            this.areas.push(rect);
            rect.draw();
            
            if(this.currentRect) {
                this.transformer.removeOverlay(this.currentRect);
            }
            this.transformer.addOverlay(rect);
            rect.allowMove = true;
            rect.rotateWithImage = true;
            
            this.currentRect = rect;
            let imageArea = ImageView.CoordinateConversion.convertRectFromOpenSeadragonToImage(rect.rect, this.image.viewer, this.image.getOriginalImageSize());
            imageArea = ImageView.CoordinateConversion.convertImageAreaFromRotatedImageToImage(imageArea, this.image.getRotation(), this.image.getOriginalImageSize());
            this.finishedHook.next(imageArea);
        }.bind(this))
    }
    
    imageView.Tools.AreaSelect.prototype.startSelect = function() {
        console.log("start drawing");
        this.drawing = true;
        return this.finishedHook;
    }
        
    imageView.Tools.AreaSelect.prototype.stopSelect = function() {
        this.drawing = false;
        if(this.currentRect) {
            this.transformer.removeOverlay(this.currentRect);
        }
        this.currentRect = null;
    }
        
    imageView.Tools.AreaSelect.prototype.close = function() {
        this.stopSelect();
        this.finishedHook.complete();
        this.drawer.close();
        this.areas = [];
    }
    
    imageView.Tools.AreaSelect.prototype.remove = function(index) {
        let removed = this.areas.splice(index, 1);
        removed.forEach(area => area.remove());
    }
    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.ConvolutionFilter) {
        throw "ImageView.Tools.ConvolutionFilter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Blur = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Blur.init' );
            console.log( '##############################' );
        }
        this.value = value != undefined ? value : 3;
        imageView.Tools.ConvolutionFilter.call(this, image); 

    }
    
    imageView.Tools.Filter.Blur.prototype = Object.create(imageView.Tools.ConvolutionFilter.prototype);

    imageView.Tools.Filter.Blur.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.Blur.prototype.getValue = function() {
        return this.value;
    }

    
    imageView.Tools.Filter.Blur.prototype.getMatrix = function() {
        let size = this.value;
        let matrix = [];
        let value = 1/(size*size);
        for ( var i = 0; i < size*size; i++ ) {
            matrix.push(value);
        }
        return matrix;
    } 
    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Brightness = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Brightness.init' );
            console.log( '##############################' );
        }
        this.value = value;
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.Filter.Brightness.prototype = Object.create(imageView.Tools.Filter.prototype);

    imageView.Tools.Filter.Brightness.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.Brightness.prototype.getValue = function() {
        return this.value;
    }
    
    imageView.Tools.Filter.Brightness.prototype.filter = function(pixels) {
        let adjustment = this.value;
        let data = pixels.data;
        for(var i = 0; i < data.length; i += 4) {
            var pixelData = [data[i], data[i+1], data[i+2], data[i+3]];
            data[i] = _fitRange(pixelData[0] + adjustment);
            data[i+1] = _fitRange(pixelData[1] + adjustment);
            data[i+2] = _fitRange(pixelData[2] + adjustment);
        }
        return pixels;
    }
    
    function _fitRange(value) {
        return value > 255 ? 255 : (value < 0 ? 0 : value);
    }

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.ColorRotate = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Brightness.init' );
            console.log( '##############################' );
        }
        this.value = value;
        imageView.Tools.Filter.call(this, image, this.filter); 
        this.colorRotationMatrix = _getColorRotationMatrix();
        this.backColorRotationMatrix = _getInverseColorRotationMatrix();
    }
    
    imageView.Tools.Filter.ColorRotate.prototype = Object.create(imageView.Tools.Filter.prototype);

    imageView.Tools.Filter.ColorRotate.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.ColorRotate.prototype.getValue = function() {
        return this.value;
    }
    
    imageView.Tools.Filter.ColorRotate.prototype.filter = function(pixels) {
        let degree = this.value;
        let rad = degree * Math.PI / 180.0;
        let data = pixels.data;
        let matrix = _rotateColors(rad, this.colorRotationMatrix, this.backColorRotationMatrix);
        let r,g,b;
        for(let i = 0; i < data.length; i += 4) {
            r = matrix[0]*data[i] + matrix[1]*data[i+1] + matrix[2]*data[i+2] + matrix[3]*data[i+3];
            g = matrix[4]*data[i] + matrix[5]*data[i+1] + matrix[6]*data[i+2] + matrix[7]*data[i+3];
            b = matrix[8]*data[i] + matrix[9]*data[i+1] + matrix[10]*data[i+2] + matrix[11]*data[i+3];
            data[i] = r;
            data[i+1] = g;
            data[i+2] = b;
        } 
        return pixels;
    }
    
    function _transform(matrix, vector) {
        if(matrix.length !== vector.length*vector.length) {
            throw "Matrix size must be the square of vector size";
        }
        let result = [];
        for(let d = 0; d < vector.length; d++) {
            let matrixRowStart = d*vector.length;
            let value = 0;
            for(let i = 0; i < vector.length; i++) {
                value += matrix[i + matrixRowStart] * vector[i];
            }
            result.push(value);
        }
        return result;
    }
    
    function _rotateColors(rad, matrix, inverseMatrix) {
        let cos = Math.cos(rad);
        let sin = Math.sin(rad);
        let zrot = [
            cos,-sin,   0,  0,
            sin, cos,   0,  0,
              0,   0,   1,  0,
              0,   0,   0,  1
          ]
        let mat = _multiplyMatrices(zrot, matrix);
        mat = _multiplyMatrices(inverseMatrix, mat);
        
        return mat;
    }
    
    function _getColorRotationMatrix() {
        let xrot = [
            1,   0,   0,  0,
            0, 1/Math.sqrt(2),-1/Math.sqrt(2),  0,
            0, 1/Math.sqrt(2), 1/Math.sqrt(2),  0,
            0,   0,   0,  1
        ];
        let yrot = [
            Math.sqrt(2/3),   0, -1/Math.sqrt(3),  0,
            0,   1,   0,  0,
            1/Math.sqrt(3),   0, Math.sqrt(2/3),  0,
            0,   0,   0,  1
        ];
        let mat = _multiplyMatrices(yrot, xrot);  
        return mat;
    }
    
    function _getInverseColorRotationMatrix() {
        let xrotInv = [
            1,   0,   0,  0,
            0, 1/Math.sqrt(2), 1/Math.sqrt(2),  0,
            0, -1/Math.sqrt(2), 1/Math.sqrt(2),  0,
            0,   0,   0,  1
        ];
        let yrotInv = [
            Math.sqrt(2/3),   0, 1/Math.sqrt(3),  0,
            0,   1,   0,  0,
            -1/Math.sqrt(3),   0, Math.sqrt(2/3),  0,
            0,   0,   0,  1
        ];
        let mat = _multiplyMatrices(xrotInv, yrotInv);  
        return mat;
    }
    
    function _multiplyMatrices(m1, m2) {
        let rows = Math.sqrt(m1.length);
        var result = new Array(m1.length);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < rows; j++) {
                var sum = 0;
                for (var k = 0; k < rows; k++) {
                    sum += m1[i*rows+k] * m2[k*rows+j];
                }
                result[i*rows+j] = sum;
            }
        }
        return result;
    }

    
    function _getRotationMatrix(radians, axis) {
        let result = [];
        let cos = Math.cos(radians);
        let sin = Math.sin(radians);
        switch(axis) {
            case 0:
            case 'x':
            case 'X':
                result = [
                    1,   0,   0,  0,
                    0, cos,-sin,  0,
                    0, sin, cos,  0,
                    0,   0,   0,  1
                ];
                break;
            case 1:
            case 'y':
            case 'Y':
                result = [
                  cos,   0, sin,  0,
                    0,   1,   0,  0,
                 -sin,   0, cos,  0,
                    0,   0,   0,  1
                ];
                break;
            case 2:
            case 'z':
            case 'Z':
                result = [
                  cos,-sin,   0,  0,
                  sin, cos,   0,  0,
                    0,   0,   1,  0,
                    0,   0,   0,  1
                ];
                break;
            case 3: 
                throw "rotation around fourth axis not implemented";
            default:
                throw "Illigal rotation axis " +  axis; 
        }
        return result;
    }

    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;
    const _Pr = .299
    const _Pg = .587
    const _Pb = .114

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.ColorSaturation = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.ColorSaturation.init' );
            console.log( '##############################' );
        }
        this.value = value;
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.Filter.ColorSaturation.prototype = Object.create(imageView.Tools.Filter.prototype);

    imageView.Tools.Filter.ColorSaturation.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.ColorSaturation.prototype.getValue = function() {
        return this.value;
    }
    
    imageView.Tools.Filter.ColorSaturation.prototype.filter = function(pixels) {
        let factor = this.value;
        let data = pixels.data;

        for(var i = 0; i < data.length; i += 4) {
            var pixelData = [data[i], data[i+1], data[i+2]];
            let p = _getColorVectorlength(pixelData[0], pixelData[1], pixelData[2]);
            data[i] = _fitRange(factor * (pixelData[0] - p) + p);
            data[i+1] = _fitRange(factor * (pixelData[1] - p) + p);
            data[i+2] = _fitRange(factor * (pixelData[2] - p) + p);
        }

        return pixels;
    }
    
    function _getColorVectorlength(r,g,b) {
        let l = Math.sqrt(r*r*_Pr + g*g*_Pg + b*b*_Pb);
        return l;
    }
    
    function _fitRange(value) {
        return value > 255 ? 255 : (value < 0 ? 0 : value);
    }
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Contrast = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Contrast.init' );
            console.log( '##############################' );
        }
        this.value = value;
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.Filter.Contrast.prototype = Object.create(imageView.Tools.Filter.prototype);

    imageView.Tools.Filter.Contrast.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.Contrast.prototype.getValue = function() {
        return this.value;
    }
    
    imageView.Tools.Filter.Contrast.prototype.filter = function(pixels) {
        let factor = this.value;
        let data = pixels.data;
        for(var i = 0; i < data.length; i += 4) {
            var pixelData = [data[i], data[i+1], data[i+2], data[i+3]];
            data[i] = _fitRange(factor * (pixelData[0] - 128) + 128);
            data[i+1] = _fitRange(factor * (pixelData[1] - 128) + 128);
            data[i+2] = _fitRange(factor * (pixelData[2] - 128) + 128);
        }
        return pixels;
    } 
    
    function _fitRange(value) {
        return value > 255 ? 255 : (value < 0 ? 0 : value);
    }
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Grayscale = function(image) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Grayscale.init' );
            console.log( '##############################' );
        }
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.Filter.Grayscale.prototype = Object.create(imageView.Tools.Filter.prototype);
    
    imageView.Tools.Filter.Grayscale.prototype.filter = function(pixels) {
        let data = pixels.data;
        for (var i=0; i<data.length; i+=4) {
            var r = data[i];
            var g = data[i+1];
            var b = data[i+2];
            // CIE luminance for the RGB
            // The human eye is bad at seeing red and blue, so we de-emphasize them.
            var v = 0.2126*r + 0.7152*g + 0.0722*b;
            data[i] = data[i+1] = data[i+2] = v
          }
          return pixels;
    }
    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.HighlightArea = function(image, shade, rect, viewerCoordinates) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.HighlightArea.init' );
            console.log( '##############################' );
        }
        this.shade = shade;
        imageView.Tools.Filter.call(this, image, this.filter); 
        this.setRect(rect, viewerCoordinates);
    }
    
    imageView.Tools.Filter.HighlightArea.prototype = Object.create(imageView.Tools.Filter.prototype);

    imageView.Tools.Filter.HighlightArea.prototype.setRect = function(rect, viewerCoordinates) {
        if(!viewerCoordinates) {            
            let osRect = imageView.CoordinateConversion.convertRectFromImageToOpenSeadragon(rect, this.image.viewer, this.image.getOriginalImageSize());
            this.rect = osRect;
        } else {
            this.rect = rect;
        }
        this.apply();
    }
    
    imageView.Tools.Filter.HighlightArea.prototype.getValue = function(viewerCoordinates) {
        if(!viewerCoordinates) {            
            let imageRect = imageView.CoordinateConversion.convertRectFromOpenSeadragonToImage(this.rect, this.image.viewer, this.image.getOriginalImageSize());
            return imageRect;
        } else {
            return this.rect;
        }
    }
    
    imageView.Tools.Filter.HighlightArea.prototype.setShade = function(value) {
        this.shade = value;
        this.apply();
    }   

    imageView.Tools.Filter.HighlightArea.prototype.getShade = function() {
        return this.shade;
    }
    
    imageView.Tools.Filter.HighlightArea.prototype.filter = function(pixels) {
        let context = this.image.getCanvasContext();
        let canvas = context.canvas;
        
        let rects = [];
        if(Array.isArray(this.rect)) {
			this.rect.forEach( r => {
				let rect = imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(r, this.image.viewer).times(window.devicePixelRatio);
				rects.push(rect);
			});
		} else if(this.rect != undefined) {
			let rect = imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(this.rect, this.image.viewer).times(window.devicePixelRatio);
			rects.push(rect);
		}
                
        context.fillStyle = "rgba(0,0,0," + this.shade + ")";
        context.beginPath();
        
        context.moveTo(0,0);
        context.lineTo(canvas.width, 0);
        context.lineTo(canvas.width, canvas.height);
        context.lineTo(0, canvas.height);
        context.lineTo(0, 0);
//        context.closePath();
//        
//        context.beginPath();
		rects.forEach(rect => {			
	        context.moveTo(rect.x, rect.y);
	        context.lineTo(rect.x, rect.y + rect.height);
	        context.lineTo(rect.x + rect.width, rect.y + rect.height);
	        context.lineTo(rect.x + rect.width, rect.y);
	        context.moveTo(rect.x, rect.y);
		});
        context.closePath();
        
        context.fill();
    }
    
    imageView.Tools.Filter.HighlightArea.prototype.filter_old = function(pixels) {
        let adjustment = this.shade;
        let data = pixels.data;
        let rect = imageView.CoordinateConversion.convertCoordinatesFromImageToCanvas(this.rect, this.image.viewer).times(window.devicePixelRatio);
        let rotation = this.image.getRotation();
        if(rotation % 180 === 90) {
            rect = rect.rotate(rotation);
        }
        for(var i = 0; i < data.length; i += 4) {
            let p = i/4;
            let x = p % pixels.width;
            let y = Math.floor(p/pixels.width);
            if (x >= rect.x && x < rect.x+rect.width-1 && y >= rect.y && y < rect.y+rect.height ) {
                continue;
            } else {                
                var pixelData = [data[i], data[i+1], data[i+2], data[i+3]];
                data[i] = pixelData[0] * adjustment;
                data[i+1] = pixelData[1] * adjustment;
                data[i+2] = pixelData[2] * adjustment;
                data[i+3] = pixelData[3] * adjustment;
            }
        }
        return pixels; 
    }
    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Invert = function(image) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Grayscale.init' );
            console.log( '##############################' );
        }
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.Filter.Invert.prototype = Object.create(imageView.Tools.Filter.prototype);
    
    imageView.Tools.Filter.Invert.prototype.filter = function(pixels) {
        let data = pixels.data;
        for (var i=0; i<data.length; i+=4) {
            data[i] = 255 - data[i];
            data[i+1] = 255 - data[i+1];
            data[i+2] = 255 - data[i+2];
          }
          return pixels;
    }
    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.ConvolutionFilter) {
        throw "ImageView.Tools.ConvolutionFilter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Sharpen = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Sharpen.init' );
            console.log( '##############################' );
        }
        this.value = value != undefined ? value : 1;
        imageView.Tools.ConvolutionFilter.call(this, image); 

    }
    
    imageView.Tools.Filter.Sharpen.prototype = Object.create(imageView.Tools.ConvolutionFilter.prototype);

    imageView.Tools.Filter.Sharpen.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.Sharpen.prototype.getValue = function() {
        return this.value;
    }

    
    imageView.Tools.Filter.Sharpen.prototype.getMatrix = function() {
        let factor = this.value;
        let matrix = [  0, -factor,  0,
            -factor,  5*factor, -factor,
            0, -factor,  0 ];
        return matrix;
    } 
    
    

    return imageView;
    
} )( ImageView );

var ImageView = ( function( imageView ) { 
    'use strict';
    
    var _debug = false;

    if(!imageView.Tools.Filter) {
        throw "ImageView.Tools.Filter must be initialized first"; 
    } 
      
    imageView.Tools.Filter.Threshold = function(image, value) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'imageView.tools.Filter.Threshold.init' );
            console.log( '##############################' );
        }
        this.value = value;
        imageView.Tools.Filter.call(this, image, this.filter); 

    }
    
    imageView.Tools.Filter.Threshold.prototype = Object.create(imageView.Tools.Filter.prototype);

    imageView.Tools.Filter.Threshold.prototype.setValue = function(value) {
            this.value = value;
            this.apply();
    }
    
    imageView.Tools.Filter.Threshold.prototype.getValue = function() {
        return this.value;
    }
    
    imageView.Tools.Filter.Threshold.prototype.filter = function(pixels) {
        let threshold = this.value;
        let data = pixels.data;
        for(var i = 0; i < data.length; i += 4) {
            var r = data[i];
            var g = data[i+1];
            var b = data[i+2];
            var v = (0.2126*r + 0.7152*g + 0.0722*b >= threshold) ? 255 : 0;
            data[i] = data[i+1] = data[i+2] = v
        }
        return pixels;
    }
    
    

    return imageView;
    
} )( ImageView );
